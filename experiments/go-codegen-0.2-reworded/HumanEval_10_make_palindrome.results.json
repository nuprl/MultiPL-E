{
  "name": "HumanEval_10_make_palindrome",
  "language": "go_test.go",
  "prompt": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n",
  "tests": "func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // The longest palindrome that starts with myString is the longest palindrome that is a substring of myString\n    // So we need to find the longest palindrome that is a substring of myString\n    // We can do this by finding the longest palindrome that is a substring of myString,\n    // and then appending the reverse of that substring to the end of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // We can do this by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    // and return it.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:len(myString)]) {\n            myString = myString[0:i] + reverse(myString[i:len(myString)]) + myString[i:]\n            break\n        }\n    }\n    \n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that begins with a supplied string.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        myString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // (i.e. the longest string that is a palindrome)\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - myString's longest palindrome is \"cat\"\n    // - myString's longest palindrome's postfix is \"cat\"\n    // - myString's longest palindrome's postfix's prefix is \"ca\"\n    // - myString's longest palindrome's postfix's prefix's reverse is \"ac\"\n    // - myString's longest palindrome's postfix's prefix's reverse + myString's longest palindrome's postfix = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - myString's longest palindrome is \"cat\"\n    // - myString's longest palindrome's postfix is \"cat\"\n    // - myString's longest palindrome's postfix's prefix is \"ca\"\n    // - myString's longest palindrome's postfix's prefix's reverse is \"ac\"\n    // - myString's longest palindrome's postfix's prefix's reverse + myString's longest palindrome's postfix = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - myString's longest palindrome is \"cat\"\n    // - myString's longest palindrome's postfix is \"cat\"\n    // - myString's longest palindrome's\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if i == 0 {\n            return longestPalindrome\n        }\n        \n        if longestPalindrome[i] != longestPalindrome[i-1] {\n            return longestPalindrome\n        }\n    }\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return reverse_string(reverse_string(myString))\n}\n\n// Reverse a string.\n// >>> reverse_string(\"\")\n// \"\"\n// >>> reverse_string(\"cat\")\n// \"tac\"\n// >>> reverse_string(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // We'll use this to find the reverse of the string\n    // that comes before the palindromic suffix.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // If we didn't find a palindrome, return an empty string\n    if len(longestPalindrome) == 0 {\n        return \"\"\n    }\n    // Reverse the string that comes before the palindromic suffix\n    reverseOfPrefix := reverse(longestPalindrome[0:len(longestPalindrome)/2])\n    // Concatenate the reverse of the string that comes before the palindromic suffix\n    // with the palindromic suffix\n    return reverseOfPrefix + longestPalindrome\n}\n\n// Check if a string is a palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the result.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the result.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longest_palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if is_palindrome(myString[i:]) {\n            longest_palindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var new_string string\n    for i := len(longest_palindrome) - 1; i >= 0; i-- {\n        new_string = new_string + longest_palindrome[i]\n    }\n\n    return new_string\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenation of the two strings.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\n// Test make_palindrome()\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var longest_palindrome string\n    var longest_palindrome_length int\n    \n    for i := 0; i < len(myString); i++ {\n        for j := 0; j < len(myString); j++ {\n            if i == j {\n                continue\n            }\n            \n            if myString[i] == myString[j] {\n                if len(myString) - i - j < longest_palindrome_length {\n                    longest_palindrome = myString[i:j+1]\n                    longest_palindrome_length = len(myString) - i - j\n                }\n            }\n        }\n    }\n    \n    if len(longest_palindrome) == 0 {\n        return myString\n    }\n    \n    return myString[0:longest_palindrome_length] + reverse(myString[0:longest_palindrome_length])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        result = result + longestPalindrome[i]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return string(make_palindrome_helper(myString))\n}\n\n// Helper function for make_palindrome.\n// >>> make_palindrome_helper(\"\")\n// \"\"\n// >>> make_palindrome_helper(\"cat\")\n// \"catac\"\n// >>> make_palindrome_helper(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and append it to the end of myString\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        // Check if the string is a palindrome starting with the current character.\n        // If it is, then we can add it to the longest palindrome.\n        if isPalindrome(myString[i:]) {\n            longestPalindrome += myString[i]\n        }\n        \n        // If the string is not a palindrome starting with the current character,\n        // then we can add it to the longest palindrome.\n        if len(longestPalindrome) > len(myString) {\n            longestPalindrome = myString[i:]\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        longestPalindrome = longestPalindrome[:len(longestPalindrome)-1] + longestPalindrome[len(longestPalindrome)-1]\n    }\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the result.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacat\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // This is the longest substring that is a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + longestPalindrome[i+1:]\n            break\n        }\n    }\n    \n    return longestPalindrome\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := 0; i < len(longestPalindrome); i++ {\n        result += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome[0:len(longestPalindrome) - 1])\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // The longest palindrome that starts with myString is the longest palindrome that is a substring of myString\n    // So we need to find the longest substring of myString that is a palindrome\n    // We can do this by using a string slice and a reverse string slice\n    // We'll use the string slice to find the longest palindrome that starts with myString\n    // We'll use the reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - If the string is empty, return true.\n// - Check if the string is a single character.\n// - If the string is a single character, return true.\n// - Check if the string is a palindrome.\n// - If the string is a palindrome, return true.\n// - Otherwise, return false.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\n// >>> isPalindrome(\"catac\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := 0; i < len(longestPalindrome); i++ {\n        result += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - 1])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i+1] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if longestPalindrome[i] == longestPalindrome[i+1] {\n            longestPalindrome = longestPalindrome[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - len(palindrome(myString))])\n}\n\n// Find the longest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenation of the two strings.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if is_palindrome(myString[i:]) {\n            palindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    if palindrome != \"\" {\n        return myString + palindrome[::-1]\n    } else {\n        return myString\n    }\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(longestPalindrome[0:i+1]) {\n            longestPalindrome = longestPalindrome[0:i+1]\n            break\n        }\n    }\n    \n    return longestPalindrome\n}\n\n// Check if a string is a palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var result string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i + 1] {\n            result = myString[i] + result\n        } else {\n            break\n        }\n    }\n    for i := 0; i < len(myString) - len(result) + 1; i++ {\n        result = myString[i] + result\n    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Return true if the string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        myString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n    \n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // The longest palindrome is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the longest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest palindrome that begins with a supplied string.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"cat\"\n// >>> make_palindrome(\"cata\")\n// \"cat\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"abc\")\n    // \"cba\"\n    // >>> make_palindrome(\"abcd\")\n    // \"dcba\"\n    // >>> make_palindrome(\"abcdc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcba\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaa\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaab\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcd\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdca\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcab\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcabc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcabcd\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcabcdc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcabcdca\")\n    // \"dcbca\"\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // We'll use the longest palindrome to build a palindrome\n    // that begins with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Test make_palindrome()\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - 1])\n}\n\n// Reverse a string.\n// >>> reverse(\"cat\")\n// \"tac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // Start with the longest palindrome that begins with myString.\n    // If it's not a palindrome, then return myString.\n    // If it is a palindrome, then append the reverse of the string\n    // that comes before the palindrome.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(longestPalindrome[0:i+1]) {\n            longestPalindrome = longestPalindrome[0:i+1] + reverse(longestPalindrome[i+1:])\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + reverse(longestPalindrome)\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            palindrome = myString[i:] + palindrome\n        } else {\n            break\n        }\n    }\n    return palindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // (i.e. the longest substring that is a palindrome)\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catc\")\n    // \"catc\"\n    // >>> make_palindrome(\"catca\")\n    // \"catca\"\n    // >>> make_palindrome(\"catcac\")\n    // \"catcac\"\n    // >>> make_palindrome(\"catcacat\")\n    // \"catcacat\"\n    // >>> make_palindrome(\"catcacatc\")\n    // \"catcacatc\"\n    // >>> make_palindrome(\"catcacatca\")\n    // \"catcacatca\"\n    // >>> make_palindrome(\"catcacatcaa\")\n    // \"catcacatcaa\"\n    // >>> make_palindrome(\"catcacatcaaa\")\n    // \"catcacatcaaa\"\n    // >>> make_palindrome(\"catcacatcaaaa\")\n    // \"catcacatcaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaa\")\n    // \"catcacatcaaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaaa\")\n    // \"catcacatcaaaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaaaa\")\n    // \"catcacatcaaaaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaaaaa\")\n    // \"catcacatcaaaaaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaaaaaa\")\n    // \"catcacatcaaaaaaaaa\"\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // We'll use a stack to keep track of the longest palindrome.\n    // We'll also keep track of the longest palindrome's length.\n    // We'll also keep track of the longest palindrome's start index.\n    // We'll also keep track of the longest palindrome's end index.\n    var longestPalindrome string\n    var longestPalindromeLength int\n    var longestPalindromeStartIndex int\n    var longestPalindromeEndIndex int\n    var stack []string\n    for i := 0; i < len(myString); i++ {\n        // Push the current character onto the stack.\n        stack = append(stack, myString[i])\n        // If the stack is empty, we've reached the end of the string.\n        // We can't find a palindrome that starts with the string.\n        if len(stack) == 0 {\n            break\n        }\n        // If the stack is not empty, we've found a palindrome.\n        // We can stop looking for palindromes.\n        if len(stack) > 1 {\n            // Pop the top element off the stack.\n            top := stack[len(stack) - 1]\n            // If the top element is a palindrome, we've found a palindrome.\n            if isPalindrome(top) {\n                // If the palindrome is longer than the previous palindrome,\n                // update the variables.\n                if len(top) > longestPalindromeLength {\n                    longestPalindrome = top\n                    longestPalindromeLength = len(top)\n                    longestPalindromeStartIndex = i - longestPalindromeLength + 1\n                    longestPalindromeEndIndex = i + 1\n                }\n            }\n        }\n    }\n    // If we found a palindrome, we can return it.\n    if len(longestPalindrome) > 0 {\n        return myString[longestPalindromeStartIndex:longestPalindromeEndIndex]\n    }\n    // If we didn't find a palindrome, return the empty string.\n    return \"\"\n}\n\n// Check if a string is a palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i+1] {\n            longestPalindrome = myString[i:] + myString[:i+1]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n    //fmt.Println(\"longestPalindrome:\", longestPalindrome)\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return string(make_palindrome_helper(myString))\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            palindrome = myString[i:] + palindrome\n        } else {\n            break\n        }\n    }\n    return palindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>>\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that begins with myString.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        if i == 0 {\n            return longestPalindrome\n        }\n        longestPalindrome = longestPalindrome[0:i] + longestPalindrome[i:len(longestPalindrome)]\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome[0:len(longestPalindrome)-1])\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that begins with myString.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and append it to the end of myString\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    if len(longestPalindrome) == 0 {\n        return myString\n    }\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Test make_palindrome()\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - If the string is empty, return true.\n// - If the string is not empty, check if the first and last characters are the same.\n// - If the first and last characters are the same, return true.\n// - If the first and last characters are not the same, return false.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if longestPalindrome[i] == longestPalindrome[i] {\n            longestPalindrome = longestPalindrome[:i] + longestPalindrome[i+1:]\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - 1])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // and append it to the end of myString\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString.\n    // We'll use this to find the longest palindrome that starts with myString.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(longestPalindrome[0:i+1]) {\n            return myString + longestPalindrome[i:]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            return myString + longestPalindrome[i:]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // and append it to the end of myString\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Assumptions:\n    // - myString is not empty\n    // - myString is not a palindrome\n    // - myString is not a prefix of another palindrome\n    //\n    // Algorithm:\n    // - Start with the longest palindrome that begins with myString\n    // - If myString is a palindrome, return myString\n    // - If myString is a prefix of another palindrome, return myString\n    // - If myString is a postfix of another palindrome, return myString\n    // - If myString is not a palindrome, return myString\n    // - If myString is not a prefix of another palindrome, return myString\n    // - If myString is not a postfix of another palindrome, return myString\n    // - If myString is empty, return myString\n    // - If myString is not empty, return myString\n    //\n    // Algorithm idea:\n    // - Start with the longest palindrome that begins with myString\n    // - If myString is a palindrome, return myString\n    // - If myString is a prefix of another palindrome, return myString\n    // - If myString is a postfix of another palindrome, return myString\n    // - If myString is not a palindrome, return myString\n    // - If myString is not a prefix of another palindrome, return myString\n    // - If myString is not a postfix of another palindrome, return myString\n    // - If myString is empty, return myString\n    // - If myString is not empty, return myString\n    //\n    // Algorithm idea:\n    // - Start with the longest palindrome that begins with myString\n    // - If myString is a palindrome, return myString\n    // - If myString is a prefix of another\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if i == 0 {\n            return longestPalindrome\n        }\n        longestPalindrome = longestPalindrome[0:i] + longestPalindrome[i:len(longestPalindrome)]\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    if len(longestPalindrome) > 0 {\n        return myString + reverse(longestPalindrome)\n    }\n    \n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a string.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    var longestPalindrome string\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            if len(myString[0:i+1]) > len(longestPalindrome) {\n                longestPalindrome = myString[0:i+1]\n            }\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[0:i+1]) {\n            return myString + longestPalindrome[i:]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // The longest palindrome is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[0:len(myString)-1])\n}\n\n// Reverse a string.\n// Algorithm idea is simple:\n// - Reverse the string.\n// - Return the string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the longest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        result = result + longestPalindrome[i]\n    }\n    return result\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - Check if the string is a single character.\n// - Check if the string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"a\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // This is the longest substring that is a palindrome.\n    // We'll use this to build the final palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // This is the string that will be appended to the end of the final palindrome.\n    // We'll use this to build the final palindrome.\n    palindrome := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        palindrome = palindrome + longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return palindrome\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Use a stack to keep track of the longest palindrome\n    // that starts with myString\n    stack := make([]string, 0)\n    for i := 0; i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n            stack = append(stack, myString[i:])\n        }\n    }\n    // If stack is empty, return myString\n    if len(stack) == 0 {\n        return myString\n    }\n    // If stack is not empty, pop the last element and append to the end of myString\n    myString = myString + stack[len(stack)-1]\n    return myString\n}\n\n// Check if a string is a palindrome\n// >>> is_palindrome(\"\")\n// true\n// >>> is_palindrome(\"cat\")\n// true\n// >>> is_palindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the result.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the longest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // The postfix is the string that comes after the last character of the string.\n    // The prefix is the string that comes before the first character of the string.\n    // The palindromic suffix is the string that comes after the last character of the postfix.\n    // The palindromic prefix is the string that comes before the first character of the postfix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    postfix := myString\n    prefix := myString\n    palindrome_suffix := \"\"\n    palindrome_prefix := \"\"\n    for i := len(postfix) - 1; i >= 0; i-- {\n        if postfix[i] == postfix[i] {\n            palindrome_suffix = postfix[i:]\n            palindrome_prefix = postfix[:i]\n            break\n        }\n    }\n    if palindrome_suffix == \"\" {\n        palindrome_suffix = myString\n    }\n    if palindrome_prefix == \"\" {\n        palindrome_prefix = myString\n    }\n    return palindrome_prefix + palindrome_suffix\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[0:len(myString) - 1])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cat\")\n// \"tac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return reverse_string(reverse_string(myString))\n}\n\n// Reverse a string.\n// Algorithm idea is simple:\n// - Reverse the string.\n// - Return the resulting string.\n// >>> reverse_string(\"\")\n// \"\"\n// >>> reverse_string(\"cat\")\n// \"tac\"\n// >>> reverse_string(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // This is the longest substring that is a palindrome\n    // that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if i == 0 {\n            myString += longestPalindrome[len(longestPalindrome) - 1]\n        } else {\n            myString += longestPalindrome[len(longestPalindrome) - i - 1]\n        }\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // (i.e. the longest substring that is a palindrome)\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with the string.\n    // This is the longest substring that is a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // This is the string that comes before the palindromic suffix.\n    previousString := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            previousString = longestPalindrome[:i]\n            break\n        }\n    }\n\n    return previousString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if is_palindrome(myString[i:]) {\n            palindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    if palindrome == \"\" {\n        return myString\n    } else {\n        return myString + palindrome[::-1]\n    }\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := 0; i < len(longestPalindrome); i++ {\n        result += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n    if len(longestPalindrome) == 0 {\n        return myString\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString[:len(myString) - len(longestPalindrome)] + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // We'll use this to build the new string\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Build the new string\n    newString := myString\n    if len(longestPalindrome) > 0 {\n        newString = myString[:len(myString)-len(longestPalindrome)] + longestPalindrome[::-1]\n    }\n\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Time complexity: O(n)\n    // Space complexity: O(1)\n    //\n    // Note:\n    // - myString is guaranteed to be a palindrome.\n    // - myString is guaranteed to be at least one character long.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    var longestPalindrome string\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            if len(myString[i:]) > len(longestPalindrome) {\n                longestPalindrome = myString[i:]\n            }\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[:i] + reverse(longestPalindrome[i:])\n        }\n    }\n\n    return longestPalindrome\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Test make_palindrome()\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var longestPalindrome string\n    var longestPalindromeLength int\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            if len(myString[i:]) > longestPalindromeLength {\n                longestPalindrome = myString[i:]\n                longestPalindromeLength = len(myString[i:])\n            }\n        }\n    }\n    if len(longestPalindrome) == 0 {\n        return myString\n    }\n    return myString + reverse(myString[0:longestPalindromeLength])\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        result += longestPalindrome[i]\n    }\n\n    return result\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - Check if the string is a single character.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome by reversing it and comparing the first and last characters.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"a\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := 0; i < len(longestPalindrome); i++ {\n        result += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            palindrome = myString[i:] + palindrome\n        } else {\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(palindrome) / 2; i++ {\n        palindrome = palindrome[i] + palindrome[len(palindrome) - i - 1]\n    }\n    return palindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            palindrome = myString[i:] + palindrome\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + palindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i + 1] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if longestPalindrome[i] == longestPalindrome[i + 1] {\n            longestPalindrome = longestPalindrome[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += longestPalindrome[len(longestPalindrome) - i - 1]\n    }\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var longest_palindrome string\n    var longest_palindrome_index int\n    for i := 0; i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n            if len(myString) - i > len(longest_palindrome) {\n                longest_palindrome = myString[i:]\n                longest_palindrome_index = i\n            }\n        }\n    }\n    return myString[0:longest_palindrome_index] + reverse(myString[longest_palindrome_index:])\n}\n\n// Check if a string is a palindrome.\n// >>> is_palindrome(\"\")\n// true\n// >>> is_palindrome(\"cat\")\n// true\n// >>> is_palindrome(\"cata\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n    if len(longestPalindrome) == 0 {\n        return myString\n    }\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == longestPalindrome[len(longestPalindrome) - 1] {\n            myString = myString[0:i] + longestPalindrome[0:len(longestPalindrome) - 1] + myString[i + 1:]\n            break\n        }\n    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if myString == \"\" {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:len(myString)]) {\n            myString = myString[0:i] + myString[i+1:len(myString)] + myString[i:len(myString)]\n            break\n        }\n    }\n    \n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var palindrome string\n    var i int\n    for i = 0; i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n            palindrome = myString[i:] + palindrome\n        }\n    }\n    return palindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if longestPalindrome[i] == longestPalindrome[i] {\n            longestPalindrome = longestPalindrome[:i] + longestPalindrome[i+1:]\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // We'll use a stack to track the longest palindrome.\n    // We'll also use a string to store the longest palindrome.\n    // We'll start with an empty string.\n    var longestPalindrome string\n    var longestPalindromeStack []string\n    for i := 0; i < len(myString); i++ {\n        // Push the current character onto the stack.\n        // If the stack is empty, then we've found a palindrome.\n        // We'll store the string in longestPalindrome.\n        // We'll also store the stack in longestPalindromeStack.\n        // We'll also store the current character in the string.\n        // We'll also store the current character in the stack.\n        if len(longestPalindromeStack) == 0 {\n            longestPalindromeStack = append(longestPalindromeStack, myString[i])\n        } else {\n            if myString[i] == longestPalindromeStack[len(longestPalindromeStack) - 1] {\n                longestPalindromeStack = append(longestPalindromeStack, myString[i])\n            } else {\n                // Pop the last character off the stack.\n                // If the stack is empty, then we've found a palindrome.\n                // We'll store the string in longestPalindrome.\n                // We'll also store the stack in longestPalindromeStack.\n                // We'll also store the current character in the string.\n                // We'll also store the current character in the stack.\n                if len(longestPalindromeStack) == 0 {\n                    longestPalindromeStack = append(longestPalindromeStack, myString[i])\n                } else {\n                    // Pop the last character off the stack.\n                    // If the stack is empty, then we've found a palindrome.\n                    // We'll store the string in longestPalindrome.\n                    // We'll also store the stack in longestPalindromeStack.\n                    // We'll also store the current character in the string.\n                    // We'll also store the current character in the stack.\n                    if len(longestPalindromeStack) == 0 {\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\n// Test make_palindrome()\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if myString[i] != longestPalindrome[i] {\n            myString += longestPalindrome[i]\n            break\n        }\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>>\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacat\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    var longestPalindrome string\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            if len(longestPalindrome) < len(myString[i:]) {\n                longestPalindrome = myString[i:]\n            }\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        myString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n    \n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palind\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var longest_palindrome string\n    for i := 0; i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n            if len(longest_palindrome) < len(myString[i:]) {\n                longest_palindrome = myString[i:]\n            }\n        }\n    }\n    if len(longest_palindrome) == 0 {\n        return myString\n    }\n    return myString + longest_palindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i + 1] {\n            longestPalindrome = myString[i:i + 2]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += myString[i]\n    }\n    for i := len(newString) - 1; i >= 0; i-- {\n        newString += myString[i]\n    }\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - myString = \"cata\"\n    // - palindrome = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - myString = \"cata\"\n    // - palindrome = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - myString = \"cata\"\n    // - palindrome = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - myString = \"cata\"\n    // - palindrome = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        result += longestPalindrome[i]\n    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292857,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenation of the two strings.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // (i.e. the longest postfix that is a palindrome)\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    if len(longestPalindrome) > 0 {\n        return myString + reverse(longestPalindrome)\n    } else {\n        return \"\"\n    }\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        if longestPalindrome[i] == longestPalindrome[len(longestPalindrome) - 1 - i] {\n            longestPalindrome = longestPalindrome[i] + longestPalindrome[len(longestPalindrome) - 1 - i]\n        } else {\n            break\n        }\n    }\n    // Return the concatenation of the two strings.\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"abc\")\n    // \"cba\"\n    // >>> make_palindrome(\"abcd\")\n    // \"dcba\"\n    // >>> make_palindrome(\"abcdc\")\n    // \"dcbac\"\n    // >>> make_palindrome(\"abcdab\")\n    // \"dcbac\"\n    // >>> make_palindrome(\"abcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\")\n    // \"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that begins with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // This is the longest substring that is a palindrome.\n    // We'll use this to build the final palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // We'll use this to build the final palindrome.\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // The longest palindrome is the longest substring that is a palindrome.\n    // The longest substring is the longest prefix that is a palindrome.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a subst\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that begins with myString\n    // and append it to the end of myString\n    for i := len(myString) - 1; i >= 0; i-- {\n        if is_palindrome(myString[0:i+1]) {\n            myString = myString[0:i+1] + myString[i+1:]\n            break\n        }\n    }\n\n    // Reverse the string before the palindrome\n    for i := 0; i < len(myString)/2; i++ {\n        myString = myString[i] + myString[len(myString) - i - 1]\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that begins with myString\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if myString[i] != longestPalindrome[i] {\n            myString += longestPalindrome[i]\n            break\n        }\n    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292887,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292902,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - len(myString) / 2])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cat\")\n// \"tac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292902,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292872,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // (i.e. the longest postfix that is a palindrome)\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    if len(longestPalindrome) > 0 {\n        return myString + reverse(myString[:len(longestPalindrome)])\n    } else {\n        return myString\n    }\n}\n\n// Check if a string is a palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292902,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>>\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292902,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    }
  ]
}