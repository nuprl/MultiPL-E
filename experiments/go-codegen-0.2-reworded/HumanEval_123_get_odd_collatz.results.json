{
  "name": "HumanEval_123_get_odd_collatz",
  "language": "go_test.go",
  "prompt": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n",
  "tests": "func TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i / 2)\n        } else {\n            odd_collatz = append(odd_collatz, 3 * i + 1)\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpa5lluikz_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpa5lluikz_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpa5lluikz_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpa5lluikz_test.go:55: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i*3)+1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i < n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzcaxrqux_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzcaxrqux_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzcaxrqux_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i < n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpb6oayk5h_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpb6oayk5h_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpb6oayk5h_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    \n    for n > 1 {\n        if n%2 == 0 {\n            odd_collatz = append(odd_collatz, n/2)\n            n = n/2\n        } else {\n            odd_collatz = append(odd_collatz, 3*n+1)\n            n = 3*n+1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpni1ml40w_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpni1ml40w_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpni1ml40w_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpni1ml40w_test.go:53: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (3 * i) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpttgxfkqs_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpttgxfkqs_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpttgxfkqs_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n < 1 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpq3ebu0h2_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpq3ebu0h2_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpq3ebu0h2_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpq3ebu0h2_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_numbers = append(odd_numbers, n / 2)\n            n = n / 2\n        } else {\n            odd_numbers = append(odd_numbers, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i)\n        } else {\n            odd_collatz = append(odd_collatz, i * 3 + 1)\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmprmqpb5a__test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmprmqpb5a__test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmprmqpb5a__test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmprmqpb5a__test.go:55: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    if n % 2 == 0 {\n        return []int{n}\n    }\n    odd_numbers := []int{}\n    for i := n; i > 1; i = n / i {\n        if i % 2 == 1 {\n            odd_numbers = append(odd_numbers, i)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmprred3weh_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmprred3weh_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=5)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmprred3weh_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (3*i+1)/2)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpr0kwq8pe_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=2) %!s(int=1) %!s(int=5) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=11) %!s(int=4) %!s(int=14) %!s(int=5) %!s(int=17) %!s(int=6) %!s(int=20) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpr0kwq8pe_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=2) %!s(int=1) %!s(int=5) %!s(int=2) %!s(int=8)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpr0kwq8pe_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=1) %!s(int=5) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=11) %!s(int=4) %!s(int=14) %!s(int=5) %!s(int=17) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    if n % 2 == 0 {\n        return []int{n}\n    }\n    odd_numbers := []int{}\n    for i := n; i > 1; i = get_odd_collatz_rec(i) {\n        odd_numbers = append(odd_numbers, i)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzjkg4aba_test.go:29:28: undefined: get_odd_collatz_rec\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    \n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := n; i > 1; i = get_odd_collatz_helper(i) {\n        odd_numbers = append(odd_numbers, i)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdty8hycj_test.go:29:28: undefined: get_odd_collatz_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (3 * i) + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzl89t9kc_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzl89t9kc_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzl89t9kc_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpn_vdxsdf_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpn_vdxsdf_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpn_vdxsdf_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpgp4gd0au_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpgp4gd0au_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpgp4gd0au_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i < n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpb6oayk5h_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpb6oayk5h_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpb6oayk5h_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpvchylq_t_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpvchylq_t_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpvchylq_t_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmphj2k92hs_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmphj2k92hs_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmphj2k92hs_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp5qqzy809_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp5qqzy809_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp5qqzy809_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp1wox2y_a_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp1wox2y_a_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp1wox2y_a_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp1wox2y_a_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_list := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_list = append(odd_list, i/2)\n        } else {\n            odd_list = append(odd_list, 3*i + 1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplehb0y0l_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplehb0y0l_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplehb0y0l_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp65s1w48x_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp65s1w48x_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp65s1w48x_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpo7vmfhsj_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for i := 1; i < n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i / 2)\n        } else {\n            odd_collatz = append(odd_collatz, i * 3 + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmps_m86e68_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmps_m86e68_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmps_m86e68_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpre7q57kd_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxjz7_fxo_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxjz7_fxo_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxjz7_fxo_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i/2)\n        } else {\n            odd_collatz = append(odd_collatz, 3*i + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_u4stdl6_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_u4stdl6_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_u4stdl6_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_list []int\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list, i)\n        } else {\n            odd_list = append(odd_list, get_odd_collatz_recur(i)...)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpznisc3g9_test.go:27:41: undefined: get_odd_collatz_recur\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_list := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_list = append(odd_list, i/2)\n        } else {\n            odd_list = append(odd_list, 3*i + 1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplehb0y0l_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplehb0y0l_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplehb0y0l_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{1}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpfv9f2qx6_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpfv9f2qx6_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=1) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpfv9f2qx6_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i/2)\n        } else {\n            odd_collatz = append(odd_collatz, 3*i + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_u4stdl6_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_u4stdl6_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_u4stdl6_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpex1e9lts_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpex1e9lts_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpex1e9lts_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_collatz = append(odd_collatz, i)\n        } else {\n            odd_collatz = append(odd_collatz, i*3 + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmproax10vy_test.go:49: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmproax10vy_test.go:49: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmproax10vy_test.go:49: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmproax10vy_test.go:49: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpoxx5pgjw_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpoxx5pgjw_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpoxx5pgjw_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    \n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := n; i > 1; i = get_odd_collatz_rec(i) {\n        odd_numbers = append(odd_numbers, i)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxlnsvroa_test.go:29:28: undefined: get_odd_collatz_rec\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_collatz = append(odd_collatz, n / 2)\n            n = n / 2\n        } else {\n            odd_collatz = append(odd_collatz, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    if n % 2 == 0 {\n        return []int{n}\n    }\n    odd_numbers := []int{}\n    for i := n; i > 1; i = get_odd_collatz_helper(i) {\n        odd_numbers = append(odd_numbers, i)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvua2v47a_test.go:29:28: undefined: get_odd_collatz_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        \n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpwn26wioa_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpwn26wioa_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpwn26wioa_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpogin6bsw_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpogin6bsw_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpogin6bsw_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpykz0t3ap_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i)\n        } else {\n            odd_numbers = append(odd_numbers, i*3 + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpgq3osepu_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpgq3osepu_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpgq3osepu_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpgq3osepu_test.go:52: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmppcz67oyd_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmppcz67oyd_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmppcz67oyd_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmppcz67oyd_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i*3)+1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n < 1 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        \n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmputdy1mkq_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmputdy1mkq_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmputdy1mkq_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmputdy1mkq_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i)\n        } else {\n            odd_collatz = append(odd_collatz, i * 3 + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_list := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_list = append(odd_list, i / 2)\n        } else {\n            odd_list = append(odd_list, i * 3 + 1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp6jm16f17_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp6jm16f17_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp6jm16f17_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp5qqzy809_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp5qqzy809_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp5qqzy809_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    \n}\n\n// Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_even_collatz(5) returns [2, 4] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 2, and 4.\n// >>> get_even_collatz(5)\n// []int{2, 4}\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppz7psiq5_test.go:23:1: missing return at end of function\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    if n % 2 == 0 {\n        return []int{n}\n    }\n    odd_numbers := []int{}\n    for i := n; i > 1; i = get_odd_collatz_rec(i) {\n        odd_numbers = append(odd_numbers, i)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzjkg4aba_test.go:29:28: undefined: get_odd_collatz_rec\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpcndava9__test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpcndava9__test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpcndava9__test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpcndava9__test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpvhnr9zzz_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpvhnr9zzz_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpvhnr9zzz_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    for n > 1 {\n        if n%2 == 0 {\n            odd_collatz = append(odd_collatz, n/2)\n            n = n/2\n        } else {\n            odd_collatz = append(odd_collatz, 3*n+1)\n            n = 3*n+1\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpljilx9um_test.go:51: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpljilx9um_test.go:51: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpljilx9um_test.go:51: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpljilx9um_test.go:51: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpoxx5pgjw_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpoxx5pgjw_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpoxx5pgjw_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var result []int\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            result = append(result, i)\n        } else {\n            result = append(result, i * 3 + 1)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp1cchuc0i_test.go:49: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp1cchuc0i_test.go:49: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp1cchuc0i_test.go:49: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp1cchuc0i_test.go:49: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_numbers = append(odd_numbers, n / 2)\n            n = n / 2\n        } else {\n            odd_numbers = append(odd_numbers, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_numbers = append(odd_numbers, n / 2)\n            n = n / 2\n        } else {\n            odd_numbers = append(odd_numbers, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpzy4gc__n_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_collatz = append(odd_collatz, n / 2)\n            n = n / 2\n        } else {\n            odd_collatz = append(odd_collatz, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i/2)\n        } else {\n            odd_collatz = append(odd_collatz, i*3 + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp0clnc668_test.go:49: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp0clnc668_test.go:49: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0clnc668_test.go:49: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp0clnc668_test.go:49: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    \n    if n <= 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplz7upwpl_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplz7upwpl_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplz7upwpl_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpn_vdxsdf_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpn_vdxsdf_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpn_vdxsdf_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_list []int\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list, i)\n        } else {\n            odd_list = append(odd_list, odd_list[len(odd_list)-1] * 3 + 1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536460, 0xc000154000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536460, 0xc000154000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_odd_collatz(...)\n\t/tmp/tmp76hl51qv_test.go:27\ncommand-line-arguments_test.TestGet_Odd_Collatz(0xc000102600)\n\t/tmp/tmp76hl51qv_test.go:40 +0xa18\ntesting.tRunner(0xc000102600, 0x54f328)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpurrvxxjp_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpurrvxxjp_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpurrvxxjp_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpiuwaknr__test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpiuwaknr__test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpiuwaknr__test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpg2u05co3_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpg2u05co3_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpg2u05co3_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        \n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpaplox033_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpaplox033_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpaplox033_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplqzge87i_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    \n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpbyke_4nd_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpbyke_4nd_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpbyke_4nd_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_list := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_list = append(odd_list, n)\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxl40knx3_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxl40knx3_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxl40knx3_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxjz7_fxo_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxjz7_fxo_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxjz7_fxo_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpvhnr9zzz_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpvhnr9zzz_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpvhnr9zzz_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpykwbsi_2_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpykwbsi_2_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpykwbsi_2_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    \n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_collatz := []int{}\n    \n    for i := n; i > 1; i = get_odd_collatz_next(i) {\n        odd_collatz = append(odd_collatz, i)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvh61mm95_test.go:29:28: undefined: get_odd_collatz_next\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_t7yqj9r_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpg05jf9dg_test.go:55: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    \n    odd_collatz := []int{1}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp7npbmopt_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1) %!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp7npbmopt_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=1) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp7npbmopt_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=1) %!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwpcxkqr_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_list := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_list = append(odd_list, i/2)\n        } else {\n            odd_list = append(odd_list, 3*i + 1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp6roc_29x_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp6roc_29x_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp6roc_29x_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i)\n        } else {\n            odd_collatz = append(odd_collatz, i * 3 + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n < 1 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp4shkie1n_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp4shkie1n_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp4shkie1n_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp9j_i7h4e_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_collatz = append(odd_collatz, n / 2)\n            n = n / 2\n        } else {\n            odd_collatz = append(odd_collatz, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_list := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_list = append(odd_list, i / 2)\n        } else {\n            odd_list = append(odd_list, 3 * i + 1)\n        }\n    }\n    return odd_list\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp8ropox2l_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp8ropox2l_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp8ropox2l_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_collatz = append(odd_collatz, n / 2)\n            n = n / 2\n        } else {\n            odd_collatz = append(odd_collatz, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_collatz = append(odd_collatz, n / 2)\n            n = n / 2\n        } else {\n            odd_collatz = append(odd_collatz, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpbk5mrnf4_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpbk5mrnf4_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpbk5mrnf4_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i / 2)\n        } else {\n            odd_collatz = append(odd_collatz, 3 * i + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpsazxlnhm_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpsazxlnhm_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpsazxlnhm_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (3*i + 1)/2)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp21a1ejsu_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=2) %!s(int=1) %!s(int=5) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=11) %!s(int=4) %!s(int=14) %!s(int=5) %!s(int=17) %!s(int=6) %!s(int=20) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp21a1ejsu_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=2) %!s(int=1) %!s(int=5) %!s(int=2) %!s(int=8)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp21a1ejsu_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=1) %!s(int=5) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=11) %!s(int=4) %!s(int=14) %!s(int=5) %!s(int=17) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpsspzk2gb_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpsspzk2gb_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpsspzk2gb_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    \n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i)\n        } else {\n            odd_numbers = append(odd_numbers, i * 3 + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpq4dpdwu7_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpq4dpdwu7_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpq4dpdwu7_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpq4dpdwu7_test.go:56: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    if n == 1 {\n        odd_collatz = []int{1}\n        return odd_collatz\n    }\n    if n % 2 == 0 {\n        odd_collatz = append(odd_collatz, n / 2)\n        return odd_collatz\n    }\n    odd_collatz = append(odd_collatz, 3 * n + 1)\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_nl5c1an_test.go:51: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_nl5c1an_test.go:51: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_nl5c1an_test.go:51: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i)\n        } else {\n            odd_collatz = append(odd_collatz, i * 3 + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12) %!s(int=40) %!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=2) %!s(int=10) %!s(int=4) %!s(int=16) %!s(int=6) %!s(int=22) %!s(int=8) %!s(int=28) %!s(int=10) %!s(int=34) %!s(int=12)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpwg1_rshj_test.go:49: expected '[%!s(int=1)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, 3 * i + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplgo9fjcq_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpnsonom4p_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpnsonom4p_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpnsonom4p_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzc4lsonl_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp6pzny526_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp6pzny526_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp6pzny526_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpjwc43jmv_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxwzlap9q_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpwuerf_ok_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpwuerf_ok_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpwuerf_ok_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i+1)\n        }\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp10kbpx28_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp10kbpx28_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp10kbpx28_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i*3)+1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp51up9ppz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    if n%2 == 0 {\n        return []int{n}\n    }\n    odd_numbers := []int{}\n    for i := n; i > 1; i = get_odd_collatz_rec(i) {\n        odd_numbers = append(odd_numbers, i)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjzrpduoe_test.go:29:28: undefined: get_odd_collatz_rec\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var result []int\n    if n <= 1 {\n        result = []int{1}\n    } else {\n        result = []int{n}\n        for n > 1 {\n            if n % 2 == 0 {\n                n = n / 2\n            } else {\n                n = 3 * n + 1\n            }\n            result = append(result, n)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpvdx1dni3_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14) %!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpvdx1dni3_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpvdx1dni3_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=12) %!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_collatz = append(odd_collatz, n / 2)\n            n = n / 2\n        } else {\n            odd_collatz = append(odd_collatz, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpdfknr57a_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpdfknr57a_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpdfknr57a_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpdfknr57a_test.go:53: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (3 * i) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpu7antcrb_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpu7antcrb_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpu7antcrb_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpfnk07haq_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpypzgac0x_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_collatz = append(odd_collatz, n / 2)\n            n = n / 2\n        } else {\n            odd_collatz = append(odd_collatz, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, i*3 + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp8npi56fm_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp8npi56fm_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp8npi56fm_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i*3)+1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpp_798fz6_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpp_798fz6_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpp_798fz6_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i%2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i*3)+1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpmpyywxvz_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpscb3d46f_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            odd_collatz = append(odd_collatz, n / 2)\n            n = n / 2\n        } else {\n            odd_collatz = append(odd_collatz, 3 * n + 1)\n            n = 3 * n + 1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp_jagp_cm_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        \n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpxbfmodps_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpxbfmodps_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpxbfmodps_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpxbfmodps_test.go:57: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        \n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpwn26wioa_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpwn26wioa_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpwn26wioa_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i / 2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpykwbsi_2_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpykwbsi_2_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpykwbsi_2_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    if n == 1 {\n        odd_collatz = []int{1}\n        return odd_collatz\n    }\n    odd_collatz = append(odd_collatz, n)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpgk4ra18m_test.go:55: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14) %!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpgk4ra18m_test.go:55: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpgk4ra18m_test.go:55: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=12) %!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp1wox2y_a_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp1wox2y_a_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp1wox2y_a_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmp1wox2y_a_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        \n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmplyngf28m_test.go:57: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmplyngf28m_test.go:57: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmplyngf28m_test.go:57: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    var odd_collatz []int\n    \n    for n > 1 {\n        if n%2 == 0 {\n            odd_collatz = append(odd_collatz, n/2)\n            n = n/2\n        } else {\n            odd_collatz = append(odd_collatz, 3*n+1)\n            n = 3*n+1\n        }\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpni1ml40w_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpni1ml40w_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpni1ml40w_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpni1ml40w_test.go:53: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp0ltc1an1_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp0ltc1an1_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp0ltc1an1_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_collatz := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_collatz = append(odd_collatz, i/2)\n        } else {\n            odd_collatz = append(odd_collatz, i*3 + 1)\n        }\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpwv566aah_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpwv566aah_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpwv566aah_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    if n % 2 == 0 {\n        return []int{n}\n    }\n    odd_collatz := []int{n}\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp461kkw_m_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=14)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp461kkw_m_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp461kkw_m_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    \n    odd_collatz := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n = n / 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_collatz = append(odd_collatz, n)\n    }\n    \n    return odd_collatz\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp6pzny526_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp6pzny526_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp6pzny526_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            n = 3*n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpzy47h488_test.go:53: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 0 {\n        return []int{}\n    }\n    \n    odd_numbers := []int{}\n    \n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        odd_numbers = append(odd_numbers, n)\n    }\n    \n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=7) %!s(int=22) %!s(int=11) %!s(int=34) %!s(int=17) %!s(int=52) %!s(int=26) %!s(int=13) %!s(int=40) %!s(int=20) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=10) %!s(int=5) %!s(int=16) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__3 (0.00s)\n        tmpv089g1q8_test.go:56: expected '[%!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n == 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, (i * 3) + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmp78rhdp18_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_odd_collatz_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the \n// previous term as follows: if the previous term is even, the next term is one half of \n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n// Note: \n// 1. Collatz(1) is [1].\n// 2. returned list sorted in increasing order.\n// For example:\n// get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n// >>> get_odd_collatz(5)\n// []int{1, 5}\nfunc get_odd_collatz(n int) []int {\n    if n <= 1 {\n        return []int{1}\n    }\n    odd_numbers := []int{}\n    for i := 1; i <= n; i++ {\n        if i % 2 == 0 {\n            odd_numbers = append(odd_numbers, i/2)\n        } else {\n            odd_numbers = append(odd_numbers, 3*i + 1)\n        }\n    }\n    return odd_numbers\n}\n\nfunc TestGet_Odd_Collatz(t *testing.T) {\n  candidate := get_odd_collatz\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(14), expected: []int{1, 5, 7, 11, 13, 17} },\n     { actual: candidate(5), expected: []int{1, 5} },\n     { actual: candidate(12), expected: []int{1, 3, 5} },\n     { actual: candidate(1), expected: []int{1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Odd_Collatz (0.00s)\n    --- FAIL: TestGet_Odd_Collatz/test_num__0 (0.00s)\n        tmpw0lz1r83_test.go:52: expected '[%!s(int=1) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6) %!s(int=40) %!s(int=7)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__1 (0.00s)\n        tmpw0lz1r83_test.go:52: expected '[%!s(int=1) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16)]'\n    --- FAIL: TestGet_Odd_Collatz/test_num__2 (0.00s)\n        tmpw0lz1r83_test.go:52: expected '[%!s(int=1) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=1) %!s(int=10) %!s(int=2) %!s(int=16) %!s(int=3) %!s(int=22) %!s(int=4) %!s(int=28) %!s(int=5) %!s(int=34) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}