{
  "name": "HumanEval_25_factorize",
  "language": "go_test.go",
  "prompt": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n",
  "tests": "func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n % 2 == 0 {\n            factors = append(factors, 2)\n            n /= 2\n        }\n        for n % 3 == 0 {\n            factors = append(factors, 3)\n            n /= 3\n        }\n        for n % 5 == 0 {\n            factors = append(factors, 5)\n            n /= 5\n        }\n        for n % 7 == 0 {\n            factors = append(factors, 7)\n            n /= 7\n        }\n        for n % 11 == 0 {\n            factors = append(factors, 11)\n            n /= 11\n        }\n        for n % 13 == 0 {\n            factors = append(factors, 13)\n            n /= 13\n        }\n        for n % 17 == 0 {\n            factors = append(factors, 17)\n            n /= 17\n        }\n        for n % 19 == 0 {\n            factors = append(factors, 19)\n            n /= 19\n        }\n        for n % 23 == 0 {\n            factors = append(factors, 23)\n            n /= 23\n        }\n        for n % 29 == 0 {\n            factors = append(factors, 29)\n            n /= 29\n        }\n        for n % 31 == 0 {\n            factors = append(factors, 31)\n            n /= 31\n        }\n        for n % 37 == 0 {\n            factors = append(factors, 37)\n            n /= 37\n        }\n        for n % 41 == 0 {\n            factors = append(factors, 41)\n            n /= 41\n        }\n        for n % 43 == 0 {\n            factors = append(factors, 43)\n            n /= 43\n        }\n        for n % 47 == 0 {\n            factors = append(factors, 47)\n            n /= 47\n        }\n        for n % 53 == 0 {\n            factors = append(factors, 53)\n            n /= 53\n        }\n        for n % 59 == 0 {\n            factors =\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else if n % 3 == 0 {\n            n /= 3\n        } else if n % 5 == 0 {\n            n /= 5\n        } else if n % 7 == 0 {\n            n /= 7\n        } else {\n            factors = append(factors, n)\n            n = n - 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            factors = append(factors, 2)\n            n /= 2\n        }\n        for n%3 == 0 {\n            factors = append(factors, 3)\n            n /= 3\n        }\n        for n%5 == 0 {\n            factors = append(factors, 5)\n            n /= 5\n        }\n        for n%7 == 0 {\n            factors = append(factors, 7)\n            n /= 7\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            factors = append(factors, 2)\n            n /= 2\n        }\n        for n%3 == 0 {\n            factors = append(factors, 3)\n            n /= 3\n        }\n        for n%5 == 0 {\n            factors = append(factors, 5)\n            n /= 5\n        }\n        for n%7 == 0 {\n            factors = append(factors, 7)\n            n /= 7\n        }\n        for n%11 == 0 {\n            factors = append(factors, 11)\n            n /= 11\n        }\n        for n%13 == 0 {\n            factors = append(factors, 13)\n            n /= 13\n        }\n        for n%17 == 0 {\n            factors = append(factors, 17)\n            n /= 17\n        }\n        for n%19 == 0 {\n            factors = append(factors, 19)\n            n /= 19\n        }\n        for n%23 == 0 {\n            factors = append(factors, 23)\n            n /= 23\n        }\n        for n%29 == 0 {\n            factors = append(factors, 29)\n            n /= 29\n        }\n        for n%31 == 0 {\n            factors = append(factors, 31)\n            n /= 31\n        }\n        for n%37 == 0 {\n            factors = append(factors, 37)\n            n /= 37\n        }\n        for n%41 == 0 {\n            factors = append(factors, 41)\n            n /= 41\n        }\n        for n%43 == 0 {\n            factors = append(factors, 43)\n            n /= 43\n        }\n        for n%47 == 0 {\n            factors = append(factors, 47)\n            n /= 47\n        }\n        for n%53 == 0 {\n            factors = append(factors, 53)\n            n /= 53\n        }\n        for n%59 == 0 {\n            factors =\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n        for n%11 == 0 {\n            n /= 11\n            factors = append(factors, 11)\n        }\n        for n%13 == 0 {\n            n /= 13\n            factors = append(factors, 13)\n        }\n        for n%17 == 0 {\n            n /= 17\n            factors = append(factors, 17)\n        }\n        for n%19 == 0 {\n            n /= 19\n            factors = append(factors, 19)\n        }\n        for n%23 == 0 {\n            n /= 23\n            factors = append(factors, 23)\n        }\n        for n%29 == 0 {\n            n /= 29\n            factors = append(factors, 29)\n        }\n        for n%31 == 0 {\n            n /= 31\n            factors = append(factors, 31)\n        }\n        for n%37 == 0 {\n            n /= 37\n            factors = append(factors, 37)\n        }\n        for n%41 == 0 {\n            n /= 41\n            factors = append(factors, 41)\n        }\n        for n%43 == 0 {\n            n /= 43\n            factors = append(factors, 43)\n        }\n        for n%47 == 0 {\n            n /= 47\n            factors = append(factors, 47)\n        }\n        for n%53 == 0 {\n            n /= 53\n            factors = append(factors, 53)\n        }\n        for n%59 == 0 {\n            n /=\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else if n % 3 == 0 {\n            n /= 3\n        } else if n % 5 == 0 {\n            n /= 5\n        } else if n % 7 == 0 {\n            n /= 7\n        } else {\n            factors = append(factors, n)\n            n = n - 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else if n % 3 == 0 {\n            n /= 3\n        } else if n % 5 == 0 {\n            n /= 5\n        } else {\n            factors = append(factors, n)\n            n = n / 5\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292946,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292946,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else {\n            factors = append(factors, n)\n            n = n / 5\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292946,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n = n / 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292946,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for i := 2; i <= n / i; i++ {\n            if n % i == 0 {\n                factors = append(factors, i)\n                n /= i\n            }\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292946,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292946,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        for n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292946,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            factors = append(factors, 2)\n            n = n*3 + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292946,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292931,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    }
  ]
}