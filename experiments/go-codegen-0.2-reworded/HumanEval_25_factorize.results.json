{
  "name": "HumanEval_25_factorize",
  "language": "go_test.go",
  "prompt": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n",
  "tests": "func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n % 2 == 0 {\n            factors = append(factors, 2)\n            n /= 2\n        }\n        for n % 3 == 0 {\n            factors = append(factors, 3)\n            n /= 3\n        }\n        for n % 5 == 0 {\n            factors = append(factors, 5)\n            n /= 5\n        }\n        for n % 7 == 0 {\n            factors = append(factors, 7)\n            n /= 7\n        }\n        for n % 11 == 0 {\n            factors = append(factors, 11)\n            n /= 11\n        }\n        for n % 13 == 0 {\n            factors = append(factors, 13)\n            n /= 13\n        }\n        for n % 17 == 0 {\n            factors = append(factors, 17)\n            n /= 17\n        }\n        for n % 19 == 0 {\n            factors = append(factors, 19)\n            n /= 19\n        }\n        for n % 23 == 0 {\n            factors = append(factors, 23)\n            n /= 23\n        }\n        for n % 29 == 0 {\n            factors = append(factors, 29)\n            n /= 29\n        }\n        for n % 31 == 0 {\n            factors = append(factors, 31)\n            n /= 31\n        }\n        for n % 37 == 0 {\n            factors = append(factors, 37)\n            n /= 37\n        }\n        for n % 41 == 0 {\n            factors = append(factors, 41)\n            n /= 41\n        }\n        for n % 43 == 0 {\n            factors = append(factors, 43)\n            n /= 43\n        }\n        for n % 47 == 0 {\n            factors = append(factors, 47)\n            n /= 47\n        }\n        for n % 53 == 0 {\n            factors = append(factors, 53)\n            n /= 53\n        }\n        for n % 59 == 0 {\n            factors =\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppse0dvmt_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpoj60gkk9_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpoj60gkk9_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpoj60gkk9_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpoj60gkk9_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpoj60gkk9_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpoj60gkk9_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpoj60gkk9_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmp0_yi289g_test.go:56: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp0_yi289g_test.go:56: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp0_yi289g_test.go:56: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp0_yi289g_test.go:56: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else if n % 3 == 0 {\n            n /= 3\n        } else if n % 5 == 0 {\n            n /= 5\n        } else if n % 7 == 0 {\n            n /= 7\n        } else {\n            factors = append(factors, n)\n            n = n - 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpuuvnqa1z_test.go:56: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpuuvnqa1z_test.go:56: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpuuvnqa1z_test.go:56: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpuuvnqa1z_test.go:56: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=19)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpuuvnqa1z_test.go:56: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpuuvnqa1z_test.go:56: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=6859) %!s(int=127)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpuuvnqa1z_test.go:56: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=6859) %!s(int=127)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpuuvnqa1z_test.go:56: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            factors = append(factors, 2)\n            n /= 2\n        }\n        for n%3 == 0 {\n            factors = append(factors, 3)\n            n /= 3\n        }\n        for n%5 == 0 {\n            factors = append(factors, 5)\n            n /= 5\n        }\n        for n%7 == 0 {\n            factors = append(factors, 7)\n            n /= 7\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            factors = append(factors, 2)\n            n /= 2\n        }\n        for n%3 == 0 {\n            factors = append(factors, 3)\n            n /= 3\n        }\n        for n%5 == 0 {\n            factors = append(factors, 5)\n            n /= 5\n        }\n        for n%7 == 0 {\n            factors = append(factors, 7)\n            n /= 7\n        }\n        for n%11 == 0 {\n            factors = append(factors, 11)\n            n /= 11\n        }\n        for n%13 == 0 {\n            factors = append(factors, 13)\n            n /= 13\n        }\n        for n%17 == 0 {\n            factors = append(factors, 17)\n            n /= 17\n        }\n        for n%19 == 0 {\n            factors = append(factors, 19)\n            n /= 19\n        }\n        for n%23 == 0 {\n            factors = append(factors, 23)\n            n /= 23\n        }\n        for n%29 == 0 {\n            factors = append(factors, 29)\n            n /= 29\n        }\n        for n%31 == 0 {\n            factors = append(factors, 31)\n            n /= 31\n        }\n        for n%37 == 0 {\n            factors = append(factors, 37)\n            n /= 37\n        }\n        for n%41 == 0 {\n            factors = append(factors, 41)\n            n /= 41\n        }\n        for n%43 == 0 {\n            factors = append(factors, 43)\n            n /= 43\n        }\n        for n%47 == 0 {\n            factors = append(factors, 47)\n            n /= 47\n        }\n        for n%53 == 0 {\n            factors = append(factors, 53)\n            n /= 53\n        }\n        for n%59 == 0 {\n            factors =\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpal0abq8c_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n        for n%11 == 0 {\n            n /= 11\n            factors = append(factors, 11)\n        }\n        for n%13 == 0 {\n            n /= 13\n            factors = append(factors, 13)\n        }\n        for n%17 == 0 {\n            n /= 17\n            factors = append(factors, 17)\n        }\n        for n%19 == 0 {\n            n /= 19\n            factors = append(factors, 19)\n        }\n        for n%23 == 0 {\n            n /= 23\n            factors = append(factors, 23)\n        }\n        for n%29 == 0 {\n            n /= 29\n            factors = append(factors, 29)\n        }\n        for n%31 == 0 {\n            n /= 31\n            factors = append(factors, 31)\n        }\n        for n%37 == 0 {\n            n /= 37\n            factors = append(factors, 37)\n        }\n        for n%41 == 0 {\n            n /= 41\n            factors = append(factors, 41)\n        }\n        for n%43 == 0 {\n            n /= 43\n            factors = append(factors, 43)\n        }\n        for n%47 == 0 {\n            n /= 47\n            factors = append(factors, 47)\n        }\n        for n%53 == 0 {\n            n /= 53\n            factors = append(factors, 53)\n        }\n        for n%59 == 0 {\n            n /=\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp60g1bosg_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmp0_yi289g_test.go:56: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp0_yi289g_test.go:56: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp0_yi289g_test.go:56: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp0_yi289g_test.go:56: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else if n % 3 == 0 {\n            n /= 3\n        } else if n % 5 == 0 {\n            n /= 5\n        } else if n % 7 == 0 {\n            n /= 7\n        } else {\n            factors = append(factors, n)\n            n = n - 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpfiyp1jsr_test.go:56: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpfiyp1jsr_test.go:56: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpfiyp1jsr_test.go:56: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpfiyp1jsr_test.go:56: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=19)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpfiyp1jsr_test.go:56: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpfiyp1jsr_test.go:56: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=6859) %!s(int=127)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpfiyp1jsr_test.go:56: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=6859) %!s(int=127)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpfiyp1jsr_test.go:56: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n % 2 == 0 {\n            n /= 2\n        } else if n % 3 == 0 {\n            n /= 3\n        } else if n % 5 == 0 {\n            n /= 5\n        } else {\n            factors = append(factors, n)\n            n = n / 5\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmp1938cpyo_test.go:54: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmp1938cpyo_test.go:54: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmp1938cpyo_test.go:54: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmp1938cpyo_test.go:54: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=19)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp1938cpyo_test.go:54: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp1938cpyo_test.go:54: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=6859) %!s(int=457) %!s(int=91)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp1938cpyo_test.go:54: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=6859) %!s(int=457) %!s(int=91)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmp1938cpyo_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmppec3b_aw_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmppec3b_aw_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmppec3b_aw_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp_tth9vci_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp_tth9vci_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp_tth9vci_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmphzdcs7ek_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmphzdcs7ek_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmphzdcs7ek_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpeegtjbgr_test.go:59: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else {\n            factors = append(factors, n)\n            n = n / 5\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpan7o89px_test.go:57: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpan7o89px_test.go:57: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpan7o89px_test.go:57: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859) %!s(int=3) %!s(int=457) %!s(int=91) %!s(int=2) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpan7o89px_test.go:57: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859) %!s(int=3) %!s(int=457) %!s(int=91) %!s(int=2) %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp2r1w7w9t_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n = n / 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmp28qw_6so_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmp28qw_6so_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmp28qw_6so_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmp28qw_6so_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp28qw_6so_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp28qw_6so_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp28qw_6so_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for i := 2; i <= n / i; i++ {\n            if n % i == 0 {\n                factors = append(factors, i)\n                n /= i\n            }\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374836,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmper09n_ae_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374836,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\n        n /= 59\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps10x823n_test.go:86:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        for n % 2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n % 3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n % 5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n % 7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374839,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpudxvl626_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n = n/2\n        } else {\n            factors = append(factors, 2)\n            n = n*3 + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374810,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpukjxktua_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpukjxktua_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpukjxktua_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpukjxktua_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpukjxktua_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpukjxktua_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpukjxktua_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        for n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        }\n        for n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        }\n        for n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        }\n        for n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            break\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpseps_c0j_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else if n%3 == 0 {\n            n /= 3\n        } else if n%5 == 0 {\n            n /= 5\n        } else if n%7 == 0 {\n            n /= 7\n        } else if n%11 == 0 {\n            n /= 11\n        } else if n%13 == 0 {\n            n /= 13\n        } else if n%17 == 0 {\n            n /= 17\n        } else if n%19 == 0 {\n            n /= 19\n        } else if n%23 == 0 {\n            n /= 23\n        } else if n%29 == 0 {\n            n /= 29\n        } else if n%31 == 0 {\n            n /= 31\n        } else if n%37 == 0 {\n            n /= 37\n        } else if n%41 == 0 {\n            n /= 41\n        } else if n%43 == 0 {\n            n /= 43\n        } else if n%47 == 0 {\n            n /= 47\n        } else if n%53 == 0 {\n            n /= 53\n        } else if n%59 == 0 {\n            n /= 59\n        } else if n%61 == 0 {\n            n /= 61\n        } else if n%67 == 0 {\n            n /= 67\n        } else if n%71 == 0 {\n            n /= 71\n        } else if n%73 == 0 {\n            n /= 73\n        } else if n%79 == 0 {\n            n /= 79\n        } else if n%83 == 0 {\n            n /= 83\n        } else if n%89 == 0 {\n            n /= 89\n        } else if n%97 == 0 {\n            n /= 97\n        } else if n%101 == 0 {\n            n /= 101\n        } else if n%103 == 0 {\n            n /= 103\n        } else if n%107 == 0 {\n            n /= 107\n        } else if n%109 == 0 {\n            n /= 109\n        }\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjao3dzn__test.go:79:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for n%3 == 0 {\n        factors = append(factors, 3)\n        n /= 3\n    }\n    for n%5 == 0 {\n        factors = append(factors, 5)\n        n /= 5\n    }\n    for n%7 == 0 {\n        factors = append(factors, 7)\n        n /= 7\n    }\n    for n%11 == 0 {\n        factors = append(factors, 11)\n        n /= 11\n    }\n    for n%13 == 0 {\n        factors = append(factors, 13)\n        n /= 13\n    }\n    for n%17 == 0 {\n        factors = append(factors, 17)\n        n /= 17\n    }\n    for n%19 == 0 {\n        factors = append(factors, 19)\n        n /= 19\n    }\n    for n%23 == 0 {\n        factors = append(factors, 23)\n        n /= 23\n    }\n    for n%29 == 0 {\n        factors = append(factors, 29)\n        n /= 29\n    }\n    for n%31 == 0 {\n        factors = append(factors, 31)\n        n /= 31\n    }\n    for n%37 == 0 {\n        factors = append(factors, 37)\n        n /= 37\n    }\n    for n%41 == 0 {\n        factors = append(factors, 41)\n        n /= 41\n    }\n    for n%43 == 0 {\n        factors = append(factors, 43)\n        n /= 43\n    }\n    for n%47 == 0 {\n        factors = append(factors, 47)\n        n /= 47\n    }\n    for n%53 == 0 {\n        factors = append(factors, 53)\n        n /= 53\n    }\n    for n%59 == 0 {\n        factors = append(factors, 59)\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6jew269c_test.go:85:6: expected '(', found TestFactorize\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpgvn1fcef_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n > 1 {\n        if n%2 == 0 {\n            n /= 2\n        } else {\n            factors = append(factors, 2)\n            n = 3*n + 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__0 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[]'\n    --- FAIL: TestFactorize/test_num__3 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpnuq1p3wf_test.go:50: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__1 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2)]', got '[%!s(int=2)]'\n    --- FAIL: TestFactorize/test_num__2 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=2)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=57)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=9) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=19) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__7 (0.00s)\n        tmpu0_0wien_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=3)]', got '[%!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return list of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n// []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int {\n    factors := make([]int, 0)\n    for n != 1 {\n        if n%2 == 0 {\n            n /= 2\n            factors = append(factors, 2)\n        } else if n%3 == 0 {\n            n /= 3\n            factors = append(factors, 3)\n        } else if n%5 == 0 {\n            n /= 5\n            factors = append(factors, 5)\n        } else if n%7 == 0 {\n            n /= 7\n            factors = append(factors, 7)\n        } else {\n            factors = append(factors, n)\n            n = 1\n        }\n    }\n    return factors\n}\n\nfunc TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4), expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2} },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249), expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected: []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3, 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestFactorize (0.00s)\n    --- FAIL: TestFactorize/test_num__4 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=361)]'\n    --- FAIL: TestFactorize/test_num__5 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=6859)]'\n    --- FAIL: TestFactorize/test_num__6 (0.00s)\n        tmp8nuqrpyd_test.go:60: expected '[%!s(int=3) %!s(int=19) %!s(int=19) %!s(int=19)]', got '[%!s(int=3) %!s(int=6859)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}