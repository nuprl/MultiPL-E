{
  "name": "HumanEval_87_get_row",
  "language": "go_test.go",
  "prompt": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n",
  "tests": "func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        if len(lst[i]) >= x {\n            result = append(result, []interface{}{i, lst[i][x]})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8np7kf2_test.go:40:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd8np7kf2_test.go:41:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd8np7kf2_test.go:42:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd8np7kf2_test.go:45:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpd8np7kf2_test.go:45:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {1, 0}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}, {8, 0}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmrzwqv9o_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        if len(lst[i]) >= x {\n            result = append(result, []interface{}{i, lst[i][x]})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8np7kf2_test.go:40:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd8np7kf2_test.go:41:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd8np7kf2_test.go:42:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd8np7kf2_test.go:45:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpd8np7kf2_test.go:45:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {1, 0}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}, {8, 0}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmrzwqv9o_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{\n            []interface{}{x, lst[0][0]},\n        }\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{\n            []interface{}{x, lst[0][0]},\n            []interface{}{x, lst[0][1]},\n        }\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{\n            []interface{}{x, lst[0][0]},\n            []interface{}{x, lst[0][1]},\n            []interface{}{x, lst[0][2]},\n        }\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{\n            []interface{}{x, lst[0][0]},\n            []interface{}{x, lst[0][1]},\n            []interface{}{x, lst[0][2]},\n            []interface{}{x, lst[0][3]},\n        }\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{\n            []interface{}{x, lst[0][0]},\n            []interface{}{x, lst[0][1]},\n            []interface{}{x, lst[0][2]},\n            []interface{}{x, lst[0][3]},\n            []interface{}{x, lst[0][4]},\n        }\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{\n            []interface{}{x, lst[0][0]},\n            []interface{}{x, lst[0][1]},\n            []interface{}{x, lst[0][2]},\n            []interface{}{x, lst[0][\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6egw4n98_test.go:71:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) > 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcg3kywxw_test.go:50:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcg3kywxw_test.go:51:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcg3kywxw_test.go:52:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcg3kywxw_test.go:55:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpcg3kywxw_test.go:55:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    coord_list := make([][]interface{}, 0)\n    for i := 0; i < len(lst[x]); i++ {\n        coord_list = append(coord_list, []interface{}{i, lst[x][i]})\n    }\n    \n    sort_coord_list := make([][]interface{}, 0)\n    for i := 0; i < len(coord_list); i++ {\n        sort_coord_list = append(sort_coord_list, []interface{}{coord_list[i][0], coord_list[i][1]})\n    }\n    \n    sort.Slice(sort_coord_list, func(i, j int) bool {\n        return sort_coord_list[i][0] < sort_coord_list[j][0]\n    })\n    \n    for i := 0; i < len(sort_coord_list); i++ {\n        coord_list = append(coord_list, []interface{}{sort_coord_list[i][0], sort_coord_list[i][1]})\n    }\n    \n    return coord_list\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0rgi6eqj_test.go:48:5: undefined: sort\n/tmp/tmp0rgi6eqj_test.go:49:38: invalid operation: sort_coord_list[i][0] < sort_coord_list[j][0] (operator < not defined on interface)\n/tmp/tmp0rgi6eqj_test.go:66:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0rgi6eqj_test.go:67:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0rgi6eqj_test.go:68:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0rgi6eqj_test.go:71:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp0rgi6eqj_test.go:71:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    row_len := len(lst[0])\n    \n    if row_len == 0 {\n        return [][]interface{}{}\n    }\n    \n    if row_len == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    \n    row_list := make([][]interface{}, 0)\n    \n    for i := 0; i < len(lst); i++ {\n        if len(lst[i]) == 0 {\n            continue\n        }\n        \n        if len(lst[i]) == 1 {\n            row_list = append(row_list, lst[i][0])\n            continue\n        }\n        \n        if lst[i][0] == x {\n            row_list = append(row_list, lst[i][0])\n        }\n        \n        for j := 1; j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                row_list = append(row_list, lst[i][j])\n            }\n        }\n    }\n    \n    sort_row_list := make([][]interface{}, 0)\n    \n    for i := 0; i < len(row_list); i++ {\n        sort_row_list = append(sort_row_list, row_list[i])\n    }\n    \n    sort.Slice(sort_row_list, func(i, j int) bool {\n        return sort_row_list[i][0] > sort_row_list[j][0]\n    })\n    \n    for i := 0; i < len(sort_row_list); i++ {\n        sort_row_list[i][0] -= 1\n    }\n    \n    return sort_row_list\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpour58dvh_test.go:36:38: cannot use lst[0][0] (type int) as type []interface {} in slice literal\n/tmp/tmpour58dvh_test.go:47:30: cannot use lst[i][0] (type int) as type []interface {} in append\n/tmp/tmpour58dvh_test.go:52:30: cannot use lst[i][0] (type int) as type []interface {} in append\n/tmp/tmpour58dvh_test.go:57:34: cannot use lst[i][j] (type int) as type []interface {} in append\n/tmp/tmpour58dvh_test.go:68:5: undefined: sort\n/tmp/tmpour58dvh_test.go:69:36: invalid operation: sort_row_list[i][0] > sort_row_list[j][0] (operator > not defined on interface)\n/tmp/tmpour58dvh_test.go:73:29: invalid operation: sort_row_list[i][0] -= 1 (mismatched types interface {} and int)\n/tmp/tmpour58dvh_test.go:86:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpour58dvh_test.go:87:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpour58dvh_test.go:88:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpour58dvh_test.go:88:245: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}, []interface{}{7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcdsbbqc_test.go:52:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{{lst[x][0], lst[x][0]}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][1], lst[x][0]}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][1], lst[x][2]}, {lst[x][2], lst[x][0]}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][1], lst[x][2]}, {lst[x][2], lst[x][3]}, {lst[x][3], lst[x][0]}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][1], lst[x][2]}, {lst[x][2], lst[x][3]}, {lst[x][3], lst[x][4]}, {lst[x][4], lst[x][0]}}\n    }\n    if\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0nzn77hv_test.go:55:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if x == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) - 1 {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if x == len(lst) - 2 {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if x == len(lst) - 3 {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if x == len(lst) - 4 {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if x == len(lst) - 5 {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if x == len(lst) - 6 {\n        return [][]interface{}{[]interface{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4n9g0v1z_test.go:62:32: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x < lst[0][0] {\n        return [][]interface{}{}\n    }\n    if x > lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{}\n    }\n    if x == lst[0][0] {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x == lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{[]interface{}{x, lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1]}}\n    }\n    if x > lst[0][0] && x < lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1]}}\n    }\n    if x < lst[0][0] {\n        return [][]interface{}{}\n    }\n    if x > lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{}\n    }\n    if x == lst[0][0] {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x == lst[len(lst) - 1][len(lst\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplao6iw_w_test.go:57:38: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][4]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][4]}, {lst[0][0], lst[0\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3kb8rw6g_test.go:46:145: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // sort coordinates by rows\n    coord_list := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++ {\n        coord_list[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            coord_list[i][j] = i\n        }\n        sort.Sort(sort.Reverse(sort.IntSlice(coord_list[i])))\n    }\n    \n    // sort coordinates of the row by columns\n    for i := 0; i < len(lst[x]); i++ {\n        sort.Sort(sort.Reverse(sort.IntSlice(lst[x][i])))\n    }\n    \n    // return coordinates\n    coord_list_result := make([][]interface{}, len(lst[x]))\n    for i := 0; i < len(lst[x]); i++ {\n        coord_list_result[i] = make([]interface{}, len(lst))\n        for j := 0; j < len(lst); j++ {\n            coord_list_result[i][j] = lst[coord_list[j][i]]\n        }\n    }\n    \n    return coord_list_result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoeh877yk_test.go:44:9: undefined: sort\n/tmp/tmpoeh877yk_test.go:49:9: undefined: sort\n/tmp/tmpoeh877yk_test.go:57:42: non-integer slice index coord_list[j][i]\n/tmp/tmpoeh877yk_test.go:71:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoeh877yk_test.go:72:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoeh877yk_test.go:73:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoeh877yk_test.go:76:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoeh877yk_test.go:76:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) > 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1ufk5jc3_test.go:59:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ufk5jc3_test.go:60:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ufk5jc3_test.go:61:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ufk5jc3_test.go:64:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp1ufk5jc3_test.go:64:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x < lst[0][0] {\n        return [][]interface{}{}\n    }\n    if x > lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{}\n    }\n    if x == lst[0][0] {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x == lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{[]interface{}{x, lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1]}}\n    }\n    for i := 0; i < len(lst); i++ {\n        if x == lst[i][0] {\n            return [][]interface{}{[]interface{}{x, lst[i][0]}}\n        }\n        if x == lst[i][len(lst[i]) - 1] {\n            return [][]interface{}{[]interface{}{x, lst[i][len(lst[i]) - 1]}}\n        }\n        if x < lst[i][0] {\n            return [][]interface{}{}\n        }\n        if x > lst[i][len(lst[i]) - 1] {\n            return [][]interface{}{}\n        }\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_w8rxni0_test.go:69:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_w8rxni0_test.go:70:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_w8rxni0_test.go:71:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_w8rxni0_test.go:74:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp_w8rxni0_test.go:74:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4zrsyr52_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4zrsyr52_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4zrsyr52_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4zrsyr52_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp4zrsyr52_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // Sort coordinates by rows in ascending order.\n    sort_by_rows(lst)\n    \n    // Sort coordinates of the row by columns in descending order.\n    sort_by_columns(lst)\n    \n    // Initialize result.\n    result := make([][]interface{}, len(lst))\n    \n    // Initialize index.\n    index := 0\n    \n    // Iterate over rows.\n    for i := 0; i < len(lst); i++ {\n        // Iterate over columns.\n        for j := 0; j < len(lst[i]); j++ {\n            // If current coordinate is equal to x, then add it to result.\n            if lst[i][j] == x {\n                result[index] = []interface{}{i, j}\n                index++\n            }\n        }\n    }\n    \n    return result\n}\n\n// Sort coordinates by rows in ascending order.\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplqdhc4yv_test.go:29:5: undefined: sort_by_rows\n/tmp/tmplqdhc4yv_test.go:32:5: undefined: sort_by_columns\n/tmp/tmplqdhc4yv_test.go:63:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplqdhc4yv_test.go:64:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplqdhc4yv_test.go:65:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplqdhc4yv_test.go:68:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmplqdhc4yv_test.go:68:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10hm0ewz_test.go:61:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:62:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:63:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:66:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp10hm0ewz_test.go:66:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_yyuw1ca_test.go:53:116: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if x < 0 || x > len(lst) {\n        return lst\n    }\n    if len(lst[x]) == 0 {\n        return lst\n    }\n    if len(lst[x][0]) == 0 {\n        return lst\n    }\n    if len(lst[x][0]) == 1 {\n        return lst\n    }\n    if len(lst[x][0]) == 2 {\n        return lst\n    }\n    if len(lst[x][0]) == 3 {\n        return lst\n    }\n    if len(lst[x][0]) == 4 {\n        return lst\n    }\n    if len(lst[x][0]) == 5 {\n        return lst\n    }\n    if len(lst[x][0]) == 6 {\n        return lst\n    }\n    if len(lst[x][0]) == 7 {\n        return lst\n    }\n    if len(lst[x][0]) == 8 {\n        return lst\n    }\n    if len(lst[x][0]) == 9 {\n        return lst\n    }\n    if len(lst[x][0]) == 10 {\n        return lst\n    }\n    if len(lst[x][0]) == 11 {\n        return lst\n    }\n    if len(lst[x][0]) == 12 {\n        return lst\n    }\n    if len(lst[x][0]) == 13 {\n        return lst\n    }\n    if len(lst[x][0]) == 14 {\n        return lst\n    }\n    if len(lst[x][0]) == 15 {\n        return lst\n    }\n    if len(lst[x][0]) == 16 {\n        return lst\n    }\n    if len(lst[x][0]) == 17 {\n        return lst\n    }\n    if len(lst[\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6rvuak0u_test.go:92:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10hm0ewz_test.go:61:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:62:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:63:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:66:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp10hm0ewz_test.go:66:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][1], lst[0][0]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][1], lst[0][2]}, {lst[0][2], lst[0][0]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][1], lst[0][2]}, {lst[0][2], lst[0][3]}, {lst[0][3], lst[0][0]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][1], lst[0][2]}, {lst[0][2], lst[0][3]}, {lst[0][3], lst[0][4]}, {lst[0][4], lst[0][0]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][1], lst[0][2]}, {lst[0][2], lst[0][3]}, {lst[0][3], lst[0][4]}, {lst[0][4], lst[0\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt9al3req_test.go:46:145: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 9 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 10 {\n        return [][]interface{}{[]interface{}{lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpg_s6amva_test.go:63:17: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{{lst[x][0], lst[x][0]}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][0], lst[x][0]}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][0], lst[x][2]}, {lst[x][0], lst[x][0]}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][0], lst[x][2]}, {lst[x][0], lst[x][3]}, {lst[x][0], lst[x][0]}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][0], lst[x][2]}, {lst[x][0], lst[x][3]}, {lst[x][0], lst[x][4]}, {lst[x][0], lst[x][0]}}\n    }\n    if\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphz2iw3c6_test.go:55:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return lst\n    }\n    if lst[0][0] == x {\n        return [][]interface{}{lst[0]}\n    }\n    if lst[0][1] == x {\n        return [][]interface{}{lst[0]}\n    }\n    if lst[0][2] == x {\n        return [][]interface{}{lst[0]}\n    }\n    if lst[0][3] == x {\n        return [][]interface{}{lst[0]}\n    }\n    if lst[0][4] == x {\n        return [][]interface{}{lst[0]}\n    }\n    if lst[0][5] == x {\n        return [][]interface{}{lst[0]}\n    }\n    if lst[0][6] == x {\n        return [][]interface{}{lst[0]}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpizd0so6h_test.go:28:9: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpizd0so6h_test.go:34:9: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpizd0so6h_test.go:37:35: cannot use lst[0] (type []int) as type []interface {} in slice literal\n/tmp/tmpizd0so6h_test.go:40:35: cannot use lst[0] (type []int) as type []interface {} in slice literal\n/tmp/tmpizd0so6h_test.go:43:35: cannot use lst[0] (type []int) as type []interface {} in slice literal\n/tmp/tmpizd0so6h_test.go:46:35: cannot use lst[0] (type []int) as type []interface {} in slice literal\n/tmp/tmpizd0so6h_test.go:49:35: cannot use lst[0] (type []int) as type []interface {} in slice literal\n/tmp/tmpizd0so6h_test.go:52:35: cannot use lst[0] (type []int) as type []interface {} in slice literal\n/tmp/tmpizd0so6h_test.go:55:35: cannot use lst[0] (type []int) as type []interface {} in slice literal\n/tmp/tmpizd0so6h_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpizd0so6h_test.go:67:145: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    if len(lst[x]) == 7 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmparl5x0p9_test.go:59:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // Sort coordinates by rows in ascending order.\n    sort_by_rows(lst)\n    \n    // Sort coordinates of the row by columns in descending order.\n    sort_by_columns(lst)\n    \n    // Create a list of coordinates.\n    coordinates := make([][]interface{}, len(lst))\n    \n    // Iterate through the list of coordinates.\n    for i, row := range lst {\n        // Iterate through the row.\n        for j, v := range row {\n            // Create a coordinate.\n            coordinates[i] = append(coordinates[i], fmt.Sprintf(\"%d,%d\", i, j))\n            \n            // If the coordinate is equal to the given x, return the coordinate.\n            if v == x {\n                return coordinates\n            }\n        }\n    }\n    \n    // Return an empty list.\n    return coordinates\n}\n\n// Sort coordinates by rows in ascending order.\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2arg8vi6_test.go:29:5: undefined: sort_by_rows\n/tmp/tmp2arg8vi6_test.go:32:5: undefined: sort_by_columns\n/tmp/tmp2arg8vi6_test.go:63:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2arg8vi6_test.go:64:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2arg8vi6_test.go:65:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2arg8vi6_test.go:68:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp2arg8vi6_test.go:68:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 9 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 10 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 11 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 12 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 13 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 14 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 15 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 16 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 17\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpovqdnrg3_test.go:83:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}, []interface{}{7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcdsbbqc_test.go:52:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}, []interface{}{7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcdsbbqc_test.go:52:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[x][0]}}\n    }\n    if len(lst[0]) > 1 {\n        return [][]interface{}{[]interface{}{x, lst[x][0]}, []interface{}{x, lst[x][1]}}\n    }\n    return [][]interface{}{[]interface{}{x, lst[x][0]}}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph95f51el_test.go:49:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph95f51el_test.go:50:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph95f51el_test.go:51:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph95f51el_test.go:54:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmph95f51el_test.go:54:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10hm0ewz_test.go:61:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:62:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:63:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp10hm0ewz_test.go:66:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp10hm0ewz_test.go:66:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    \n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    \n    if len(lst[0]) > 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    \n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc11wboza_test.go:55:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc11wboza_test.go:56:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc11wboza_test.go:57:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc11wboza_test.go:60:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpc11wboza_test.go:60:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) > 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpig0z86h4_test.go:49:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:50:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:51:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:54:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpig0z86h4_test.go:54:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    if len(lst[x]) == 7 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmparl5x0p9_test.go:59:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}, {5, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}, {5, lst\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1z2qtqc1_test.go:49:119: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}, []interface{}{7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcdsbbqc_test.go:52:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{0, 0}, {0, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}}\n    }\n    if len(lst[0]) == 9 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0,\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3kpz08vx_test.go:59:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // sort coordinates by rows\n    sort_by_rows(lst)\n    \n    // sort coordinates of the row by columns\n    sort_by_columns(lst)\n    \n    // return coordinates\n    return lst[x]\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpek6kpoce_test.go:30:5: undefined: sort_by_rows\n/tmp/tmpek6kpoce_test.go:33:5: undefined: sort_by_columns\n/tmp/tmpek6kpoce_test.go:36:15: cannot use lst[x] (type []int) as type [][]interface {} in return argument\n/tmp/tmpek6kpoce_test.go:46:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpek6kpoce_test.go:47:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpek6kpoce_test.go:48:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpek6kpoce_test.go:51:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpek6kpoce_test.go:51:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return lst\n    }\n    if x < 0 || x >= len(lst) {\n        return lst\n    }\n    if len(lst[x]) == 0 {\n        return lst\n    }\n    if len(lst[x]) == 1 {\n        return lst\n    }\n    if len(lst[x]) == 2 {\n        return lst\n    }\n    if len(lst[x]) == 3 {\n        return lst\n    }\n    if len(lst[x]) == 4 {\n        return lst\n    }\n    if len(lst[x]) == 5 {\n        return lst\n    }\n    if len(lst[x]) == 6 {\n        return lst\n    }\n    if len(lst[x]) == 7 {\n        return lst\n    }\n    if len(lst[x]) == 8 {\n        return lst\n    }\n    if len(lst[x]) == 9 {\n        return lst\n    }\n    if len(lst[x]) == 10 {\n        return lst\n    }\n    if len(lst[x]) == 11 {\n        return lst\n    }\n    if len(lst[x]) == 12 {\n        return lst\n    }\n    if len(lst[x]) == 13 {\n        return lst\n    }\n    if len(lst[x]) == 14 {\n        return lst\n    }\n    if len(lst[x]) == 15 {\n        return lst\n    }\n    if len(lst[x]) == 16 {\n        return lst\n    }\n    if len(lst[x]) == 17 {\n        return lst\n    }\n    if len(lst[x]) == 18 {\n        return lst\n    }\n    if len(l\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpce7svn3c_test.go:96:13: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprg7lmvtg_test.go:61:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    \n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    \n    if len(lst[0]) > 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    \n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc11wboza_test.go:55:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc11wboza_test.go:56:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc11wboza_test.go:57:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc11wboza_test.go:60:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpc11wboza_test.go:60:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][2]}, []interface{}{3, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][2]}, []interface{}{3, lst[0][3]}, []interface{}{4, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][2]}, []interface{}{3, lst[0][3]}, []interface{}{4, lst[0][4]}, []interface{}{5, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7a6632uj_test.go:50:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // sort coordinates by rows\n    sort_by_row(lst)\n    \n    // sort coordinates of the row by columns\n    sort_by_column(lst[0])\n    \n    // find x in the list\n    for i := 0; i < len(lst); i++ {\n        if lst[i][0] == x {\n            return lst\n        }\n    }\n    \n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvqeifoxk_test.go:29:5: undefined: sort_by_row\n/tmp/tmpvqeifoxk_test.go:32:5: undefined: sort_by_column\n/tmp/tmpvqeifoxk_test.go:37:13: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpvqeifoxk_test.go:51:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvqeifoxk_test.go:52:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvqeifoxk_test.go:53:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvqeifoxk_test.go:56:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpvqeifoxk_test.go:56:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjqjxijgp_test.go:50:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    row_list := make([][]interface{}, len(lst))\n    for i, row := range lst {\n        row_list[i] = make([]interface{}, len(row))\n        for j, elem := range row {\n            row_list[i][j] = elem\n        }\n    }\n    \n    sort_row(row_list)\n    \n    for i := 0; i < len(row_list); i++ {\n        for j := 0; j < len(row_list[i]); j++ {\n            if row_list[i][j] == x {\n                return row_list\n            }\n        }\n    }\n    \n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwdzemj04_test.go:37:5: undefined: sort_row\n/tmp/tmpwdzemj04_test.go:57:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwdzemj04_test.go:58:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwdzemj04_test.go:59:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwdzemj04_test.go:62:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpwdzemj04_test.go:62:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppmwbg6oz_test.go:52:137: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        result = append(result, []interface{}{i, get_column(lst[i], x)})\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8pnj70dk_test.go:26:50: undefined: get_column\n/tmp/tmp8pnj70dk_test.go:38:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8pnj70dk_test.go:39:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8pnj70dk_test.go:40:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8pnj70dk_test.go:43:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp8pnj70dk_test.go:43:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppmwbg6oz_test.go:52:137: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    row_lst := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++ {\n        row_lst[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            row_lst[i][j] = lst[i][j]\n        }\n        sort.Slice(row_lst[i], func(i, j int) bool {\n            return row_lst[i][j] < row_lst[i][j+1]\n        })\n    }\n    \n    for i := 0; i < len(row_lst); i++ {\n        for j := 0; j < len(row_lst[i]); j++ {\n            if row_lst[i][j] == x {\n                return row_lst\n            }\n        }\n    }\n    \n    return row_lst\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3s1igymm_test.go:35:9: undefined: sort\n/tmp/tmp3s1igymm_test.go:36:34: invalid operation: row_lst[i][j] < row_lst[i][j + 1] (operator < not defined on interface)\n/tmp/tmp3s1igymm_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3s1igymm_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3s1igymm_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3s1igymm_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp3s1igymm_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][1], lst[0][0]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{lst[0][0], lst[0][1], lst[0][2]}, {lst[0][1], lst[0][0], lst[0][2]}, {lst[0][2], lst[0][1], lst[0][0]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}, {lst[0][1], lst[0][0], lst[0][2], lst[0][3]}, {lst[0][2], lst[0][1], lst[0][0], lst[0][3]}, {lst[0][3], lst[0][2], lst[0][1], lst[0][0]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}, {lst[0][1], lst[0][0], lst[0][2], lst[0][3], lst[0][4]}, {lst[0][2], lst[0][1], lst[0][0], lst[0][3], l\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmx3bsdmu_test.go:43:192: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if x == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) - 1 {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if x > 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x > len(lst) - 2 {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, len(lst[0]) - 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, len(lst[0]) - 1}, []interface{}{2, len(lst[0]) - 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, len(lst[0])\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpph176r2g_test.go:62:81: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == len(lst) {\n        return [][]interface{}{{lst[x-1][0], lst[x-1][len(lst[x-1])-1]}}\n    }\n    if x == 0 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if x == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}, {lst[1][0], lst[1][len(lst[1])-1]}}\n    }\n    if x == 2 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}, {lst[1][0], lst[1][len(lst[1])-1]}, {lst[2][0], lst[2][len(lst[2])-1]}}\n    }\n    if x == 3 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}, {lst[1][0], lst[1][len(lst[1])-1]}, {lst[2][0], lst[2][len(lst[2])-1]}, {lst[3][0], lst[3][len(lst[3])-1]}}\n    }\n    if x == 4 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}, {lst[1][0], lst[1][len(lst[1])-1]}, {\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpm4ydxy6j_test.go:53:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp39nro9_r_test.go:68:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp39nro9_r_test.go:69:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp39nro9_r_test.go:70:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp39nro9_r_test.go:73:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp39nro9_r_test.go:73:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j] = i\n        }\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j] = lst[i][j]\n        }\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            if result[i][j] == x {\n                result[i][j] = i\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbpqkv7e3_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbpqkv7e3_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbpqkv7e3_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbpqkv7e3_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpbpqkv7e3_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe4mzti0y_test.go:60:16: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if x < 0 || x > len(lst) {\n        return lst\n    }\n    if len(lst[x]) == 0 {\n        return lst\n    }\n    if len(lst[x][0]) == 0 {\n        return lst\n    }\n    var result [][]interface{}\n    for i := 0; i < len(lst[x]); i++ {\n        result = append(result, []interface{}{i, lst[x][i]})\n    }\n    result = append(result, []interface{}{len(lst[x]), lst[x][0][0]})\n    result = append(result, []interface{}{len(lst[x]), lst[x][0][1]})\n    for i := 0; i < len(lst[x]); i++ {\n        result = append(result, []interface{}{len(lst[x]) - i - 1, lst[x][i][0]})\n    }\n    result = append(result, []interface{}{len(lst[x]) - 1, lst[x][0][1]})\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbvshi401_test.go:26:9: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpbvshi401_test.go:29:9: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpbvshi401_test.go:32:9: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpbvshi401_test.go:35:9: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpbvshi401_test.go:37:11: invalid argument lst[x][0] (type int) for len\n/tmp/tmpbvshi401_test.go:38:9: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpbvshi401_test.go:44:65: invalid operation: lst[x][0][0] (type int does not support indexing)\n/tmp/tmpbvshi401_test.go:45:65: invalid operation: lst[x][0][1] (type int does not support indexing)\n/tmp/tmpbvshi401_test.go:47:77: invalid operation: lst[x][i][0] (type int does not support indexing)\n/tmp/tmpbvshi401_test.go:49:69: invalid operation: lst[x][0][1] (type int does not support indexing)\n/tmp/tmpbvshi401_test.go:49:69: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) > 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpig0z86h4_test.go:49:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:50:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:51:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:54:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpig0z86h4_test.go:54:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwz7of6c5_test.go:68:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwz7of6c5_test.go:69:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwz7of6c5_test.go:70:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwz7of6c5_test.go:73:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpwz7of6c5_test.go:73:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    row_index := 0\n    row_list := []interface{}{}\n    for i := 0; i < len(lst); i++ {\n        if len(lst[i]) == 0 {\n            continue\n        }\n        \n        if lst[i][0] == x {\n            row_index = i\n            break\n        }\n    }\n    \n    for i := 0; i < len(lst[row_index]); i++ {\n        row_list = append(row_list, []interface{}{row_index, i})\n    }\n    \n    for i := 0; i < len(lst); i++ {\n        if i == row_index {\n            continue\n        }\n        \n        for j := 0; j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                row_list = append(row_list, []interface{}{i, j})\n                break\n            }\n        }\n    }\n    \n    return row_list\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps1y3r55o_test.go:59:5: cannot use row_list (type []interface {}) as type [][]interface {} in return argument\n/tmp/tmps1y3r55o_test.go:69:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps1y3r55o_test.go:70:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps1y3r55o_test.go:71:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmps1y3r55o_test.go:74:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmps1y3r55o_test.go:74:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {0, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}, {0, 8}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbmx7yaqb_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp39nro9_r_test.go:68:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp39nro9_r_test.go:69:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp39nro9_r_test.go:70:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp39nro9_r_test.go:73:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp39nro9_r_test.go:73:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // Sort coordinates by rows in ascending order.\n    sort_by_rows(lst)\n    \n    // Sort coordinates of the row by columns in descending order.\n    sort_by_columns(lst)\n    \n    // Initialize result.\n    result := [][]interface{}{}\n    \n    // Iterate through all rows.\n    for i := 0; i < len(lst); i++ {\n        // Iterate through all columns.\n        for j := 0; j < len(lst[i]); j++ {\n            // If current coordinate is equal to given x, then add it to result.\n            if lst[i][j] == x {\n                result = append(result, []interface{}{i, j})\n            }\n        }\n    }\n    \n    return result\n}\n\n// Sort coordinates by rows in ascending order.\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1elal3zp_test.go:30:5: undefined: sort_by_rows\n/tmp/tmp1elal3zp_test.go:33:5: undefined: sort_by_columns\n/tmp/tmp1elal3zp_test.go:60:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1elal3zp_test.go:61:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1elal3zp_test.go:62:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1elal3zp_test.go:65:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp1elal3zp_test.go:65:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_yyuw1ca_test.go:53:116: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) > 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpig0z86h4_test.go:49:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:50:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:51:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpig0z86h4_test.go:54:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpig0z86h4_test.go:54:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(lst[x]); i++ {\n        result = append(result, []interface{}{i, lst[x][i]})\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            if i != x && j != lst[i][0] {\n                result = append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy6vnarto_test.go:36:11: invalid argument lst[x][0] (type int) for len\n/tmp/tmpy6vnarto_test.go:60:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy6vnarto_test.go:61:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy6vnarto_test.go:62:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy6vnarto_test.go:65:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpy6vnarto_test.go:65:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    row_list := make([][]interface{}, len(lst))\n    for i, row := range lst {\n        row_list[i] = make([]interface{}, len(row))\n        for j, v := range row {\n            row_list[i][j] = v\n        }\n    }\n    \n    sort_row(row_list)\n    \n    for i, row := range row_list {\n        for j, v := range row {\n            if v == x {\n                return [][]interface{}{row_list[i], row_list[i][j+1]}\n            }\n        }\n    }\n    \n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1ge2ndgv_test.go:36:5: undefined: sort_row\n/tmp/tmp1ge2ndgv_test.go:41:64: cannot use row_list[i][j + 1] (type interface {}) as type []interface {} in slice literal: need type assertion\n/tmp/tmp1ge2ndgv_test.go:56:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ge2ndgv_test.go:57:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ge2ndgv_test.go:58:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ge2ndgv_test.go:61:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp1ge2ndgv_test.go:61:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}, []interface{}{7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcdsbbqc_test.go:52:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{{0, 0}, {0, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}}\n    }\n    if len(lst[x]) == 7 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}}\n    }\n    if len(lst[x]) == 8 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6},\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4su0xnbi_test.go:63:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuwreiv5o_test.go:62:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuwreiv5o_test.go:63:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuwreiv5o_test.go:64:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuwreiv5o_test.go:67:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpuwreiv5o_test.go:67:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 1 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][0]}\n    }\n    if len(lst[x][0]) == 2 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1]}\n    }\n    if len(lst[x][0]) == 3 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2]}\n    }\n    if len(lst[x][0]) == 4 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3]}\n    }\n    if len(lst[x][0]) == 5 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4]}\n    }\n    if len(lst[x][0]) == 6 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4], lst[x][0][5]}\n    }\n    if len(lst[x][0]) == 7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprkw9xwnw_test.go:59:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    return [][]interface{}{{x - 1, 0}}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiqmd2z2z_test.go:52:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqmd2z2z_test.go:53:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqmd2z2z_test.go:54:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqmd2z2z_test.go:57:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpiqmd2z2z_test.go:57:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_yyuw1ca_test.go:53:116: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}, []interface{}{7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcdsbbqc_test.go:52:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return lst\n    }\n    if x < 0 || x > len(lst) {\n        return lst\n    }\n    if len(lst[x]) == 0 {\n        return lst\n    }\n    if len(lst[x]) == 1 {\n        return lst\n    }\n    if len(lst[x]) == 2 {\n        return lst\n    }\n    if len(lst[x]) == 3 {\n        return lst\n    }\n    if len(lst[x]) == 4 {\n        return lst\n    }\n    if len(lst[x]) == 5 {\n        return lst\n    }\n    if len(lst[x]) == 6 {\n        return lst\n    }\n    if len(lst[x]) == 7 {\n        return lst\n    }\n    if len(lst[x]) == 8 {\n        return lst\n    }\n    if len(lst[x]) == 9 {\n        return lst\n    }\n    if len(lst[x]) == 10 {\n        return lst\n    }\n    if len(lst[x]) == 11 {\n        return lst\n    }\n    if len(lst[x]) == 12 {\n        return lst\n    }\n    if len(lst[x]) == 13 {\n        return lst\n    }\n    if len(lst[x]) == 14 {\n        return lst\n    }\n    if len(lst[x]) == 15 {\n        return lst\n    }\n    if len(lst[x]) == 16 {\n        return lst\n    }\n    if len(lst[x]) == 17 {\n        return lst\n    }\n    if len(lst[x]) == 18 {\n        return lst\n    }\n    if len(l\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppuvhaffx_test.go:96:13: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpp9civuuc_test.go:53:116: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppmwbg6oz_test.go:52:137: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}, {8, 8}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp40qokrh8_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {1, 0}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}, {8, 0}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmrzwqv9o_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j] = lst[i][j]\n        }\n    }\n    \n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            if result[i][j] == x {\n                result[i][j] = i\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            if result[i][j] == x {\n                result[i][j] = j\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]); j++ {\n            if result[i][j] == x {\n                result[i][j] = i\n                break\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplmd3c5_i_test.go:83:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmd3c5_i_test.go:84:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmd3c5_i_test.go:85:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmd3c5_i_test.go:88:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmplmd3c5_i_test.go:88:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return lst\n    }\n    if x < 0 || x > len(lst) {\n        return lst\n    }\n    if len(lst[x]) == 0 {\n        return lst\n    }\n    if len(lst[x]) == 1 {\n        return lst\n    }\n    if len(lst[x]) == 2 {\n        return lst\n    }\n    if len(lst[x]) == 3 {\n        return lst\n    }\n    if len(lst[x]) == 4 {\n        return lst\n    }\n    if len(lst[x]) == 5 {\n        return lst\n    }\n    if len(lst[x]) == 6 {\n        return lst\n    }\n    if len(lst[x]) == 7 {\n        return lst\n    }\n    if len(lst[x]) == 8 {\n        return lst\n    }\n    if len(lst[x]) == 9 {\n        return lst\n    }\n    if len(lst[x]) == 10 {\n        return lst\n    }\n    if len(lst[x]) == 11 {\n        return lst\n    }\n    if len(lst[x]) == 12 {\n        return lst\n    }\n    if len(lst[x]) == 13 {\n        return lst\n    }\n    if len(lst[x]) == 14 {\n        return lst\n    }\n    if len(lst[x]) == 15 {\n        return lst\n    }\n    if len(lst[x]) == 16 {\n        return lst\n    }\n    if len(lst[x]) == 17 {\n        return lst\n    }\n    if len(lst[x]) == 18 {\n        return lst\n    }\n    if len(l\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppuvhaffx_test.go:96:13: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x < lst[0][0] {\n        return [][]interface{}{}\n    }\n    if x > lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{}\n    }\n    if x == lst[0][0] {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x == lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{[]interface{}{x, lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1]}}\n    }\n    for i := 0; i < len(lst); i++ {\n        if x == lst[i][0] {\n            return [][]interface{}{[]interface{}{x, lst[i][0]}}\n        }\n        if x == lst[i][len(lst[i]) - 1] {\n            return [][]interface{}{[]interface{}{x, lst[i][len(lst[i]) - 1]}}\n        }\n        if x < lst[i][0] {\n            return [][]interface{}{}\n        }\n        if x > lst[i][len(lst[i]) - 1] {\n            return [][]interface{}{}\n        }\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptbq3u2ta_test.go:70:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptbq3u2ta_test.go:71:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptbq3u2ta_test.go:72:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptbq3u2ta_test.go:75:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmptbq3u2ta_test.go:75:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {0, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}, {0, 8}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbmx7yaqb_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 1 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][0]}\n    }\n    if len(lst[x][0]) == 2 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1]}\n    }\n    if len(lst[x][0]) == 3 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2]}\n    }\n    if len(lst[x][0]) == 4 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3]}\n    }\n    if len(lst[x][0]) == 5 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4]}\n    }\n    if len(lst[x][0]) == 6 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4], lst[x][0][5]}\n    }\n    if len(lst[x][0]) == 7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3tojr8dp_test.go:59:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return lst\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return lst\n    }\n    if x == len(lst) {\n        return lst\n    }\n    if len(lst[x]) == 0 {\n        return lst\n    }\n    if len(lst[x]) == 1 {\n        return lst\n    }\n    if len(lst[x]) == 2 {\n        return lst\n    }\n    if len(lst[x]) == 3 {\n        return lst\n    }\n    if len(lst[x]) == 4 {\n        return lst\n    }\n    if len(lst[x]) == 5 {\n        return lst\n    }\n    if len(lst[x]) == 6 {\n        return lst\n    }\n    if len(lst[x]) == 7 {\n        return lst\n    }\n    if len(lst[x]) == 8 {\n        return lst\n    }\n    if len(lst[x]) == 9 {\n        return lst\n    }\n    if len(lst[x]) == 10 {\n        return lst\n    }\n    if len(lst[x]) == 11 {\n        return lst\n    }\n    if len(lst[x]) == 12 {\n        return lst\n    }\n    if len(lst[x]) == 13 {\n        return lst\n    }\n    if len(lst[x]) == 14 {\n        return lst\n    }\n    if len(lst[x]) == 15 {\n        return lst\n    }\n    if len(lst[x]) == 16 {\n        return lst\n    }\n    if len(lst[x\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwcg5vq7b_test.go:96:17: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}, {8, 8}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp40qokrh8_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) > 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp092tjzit_test.go:50:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp092tjzit_test.go:51:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp092tjzit_test.go:52:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp092tjzit_test.go:55:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp092tjzit_test.go:55:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n        }\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{1, 1},\n        }\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{1, 1},\n            []interface{}{2, 2},\n        }\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{1, 1},\n            []interface{}{2, 2},\n            []interface{}{3, 3},\n        }\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{1, 1},\n            []interface{}{2, 2},\n            []interface{}{3, 3},\n            []interface{}{4, 4},\n        }\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{1, 1},\n            []interface{}{2, 2},\n            []interface{}{3, 3},\n            []interface{}{4, 4},\n            []interface{}{5, 5},\n        }\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{1, 1},\n            []interface{}{2, 2},\n            []interface{}{3, 3},\n            []interface{}{4, 4},\n            []interface{}{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb69s67b8_test.go:84:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    result := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j] = lst[i][j]\n        }\n    }\n    \n    sort_by_row(result)\n    \n    for i := 0; i < len(result); i++ {\n        sort_by_column(result[i])\n    }\n    \n    for i := 0; i < len(result); i++ {\n        for j := 0; j < len(result[i]); j++ {\n            if result[i][j] == x {\n                return result\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbkgdt2qq_test.go:37:5: undefined: sort_by_row\n/tmp/tmpbkgdt2qq_test.go:40:9: undefined: sort_by_column\n/tmp/tmpbkgdt2qq_test.go:61:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbkgdt2qq_test.go:62:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbkgdt2qq_test.go:63:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbkgdt2qq_test.go:66:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpbkgdt2qq_test.go:66:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{0, 0}, {1, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{0, 0}, {1, lst[0][1]}, {2, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{0, 0}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{0, 0}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{0, 0}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}, {5, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{{0, 0}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}, {5, lst[0][5]}, {6, lst[0][6]}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjvfgh_m2_test.go:53:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6], lst[0][7]}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv3hmsf7y_test.go:55:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}, {8, 8}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp40qokrh8_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    \n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    \n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    \n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    \n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    \n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    \n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    \n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr7x_plin_test.go:79:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr7x_plin_test.go:80:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr7x_plin_test.go:81:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr7x_plin_test.go:84:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpr7x_plin_test.go:84:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    row := make([][]interface{}, len(lst))\n    for i, v := range lst {\n        row[i] = make([]interface{}, len(v))\n        for j, w := range v {\n            row[i][j] = w\n        }\n    }\n    \n    sort_row(row)\n    \n    for i, v := range row {\n        sort_col(v)\n        \n        for j, w := range v {\n            if w == x {\n                return row\n            }\n        }\n    }\n    \n    return row\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4wt2fgkn_test.go:37:5: undefined: sort_row\n/tmp/tmp4wt2fgkn_test.go:40:9: undefined: sort_col\n/tmp/tmp4wt2fgkn_test.go:59:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4wt2fgkn_test.go:60:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4wt2fgkn_test.go:61:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4wt2fgkn_test.go:64:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp4wt2fgkn_test.go:64:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 1 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][0]}\n    }\n    if len(lst[x][0]) == 2 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1]}\n    }\n    if len(lst[x][0]) == 3 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2]}\n    }\n    if len(lst[x][0]) == 4 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3]}\n    }\n    if len(lst[x][0]) == 5 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4]}\n    }\n    if len(lst[x][0]) == 6 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4], lst[x][0][5]}\n    }\n    if len(lst[x][0]) == 7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq6vsa5ic_test.go:59:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // sort coordinates by rows in ascending order\n    sort_by_rows(lst)\n    \n    // sort coordinates of the row by columns in descending order\n    sort_by_columns(lst)\n    \n    // find x in the list\n    for i := 0; i < len(lst); i++ {\n        if lst[i][0] == x {\n            return lst[i]\n        }\n    }\n    \n    return [][]interface{}{}\n}\n\n// sort coordinates by rows in ascending order\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpggtnppyc_test.go:29:5: undefined: sort_by_rows\n/tmp/tmpggtnppyc_test.go:32:5: undefined: sort_by_columns\n/tmp/tmpggtnppyc_test.go:37:23: cannot use lst[i] (type []int) as type [][]interface {} in return argument\n/tmp/tmpggtnppyc_test.go:52:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpggtnppyc_test.go:53:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpggtnppyc_test.go:54:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpggtnppyc_test.go:57:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpggtnppyc_test.go:57:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}, []interface{}{7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcdsbbqc_test.go:52:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpp9civuuc_test.go:53:116: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) > 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgkkj9xcj_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgkkj9xcj_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgkkj9xcj_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgkkj9xcj_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpgkkj9xcj_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{{0, 0}, {0, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}}\n    }\n    if len(lst[x]) == 7 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}}\n    }\n    if len(lst[x]) == 8 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}}\n    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphnpy9d1u_test.go:63:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxnvwu16_test.go:68:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxxnvwu16_test.go:69:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxxnvwu16_test.go:70:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxxnvwu16_test.go:73:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpxxnvwu16_test.go:73:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}, {5, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}, {5, lst\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1z2qtqc1_test.go:49:119: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // sort coordinates by rows\n    sort_by_rows(lst)\n    \n    // sort coordinates of the row by columns\n    sort_by_columns(lst)\n    \n    // return coordinates\n    return lst[x]\n}\n\n// sort coordinates by rows\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1wjj7k_i_test.go:30:5: undefined: sort_by_rows\n/tmp/tmp1wjj7k_i_test.go:33:5: undefined: sort_by_columns\n/tmp/tmp1wjj7k_i_test.go:36:15: cannot use lst[x] (type []int) as type [][]interface {} in return argument\n/tmp/tmp1wjj7k_i_test.go:47:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1wjj7k_i_test.go:48:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1wjj7k_i_test.go:49:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1wjj7k_i_test.go:52:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp1wjj7k_i_test.go:52:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 11 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 12 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 13 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 14 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 15 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 16 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 17 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 18 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 19 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 20 {\n        return [][]interface{}{}\n    }\n    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfh2xzsm4_test.go:89:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 1 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][0]}\n    }\n    if len(lst[x][0]) == 2 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1]}\n    }\n    if len(lst[x][0]) == 3 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2]}\n    }\n    if len(lst[x][0]) == 4 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3]}\n    }\n    if len(lst[x][0]) == 5 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4]}\n    }\n    if len(lst[x][0]) == 6 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4], lst[x][0][5]}\n    }\n    if len(lst[x][0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbsgrzwl0_test.go:58:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    \n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    \n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    \n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    \n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    \n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    \n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    \n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpytst85i8_test.go:62:76: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    // sort coordinates by rows\n    sort_by_rows(lst)\n    \n    // sort coordinates of the row by columns\n    sort_by_columns(lst)\n    \n    // find x in the list\n    for i := 0; i < len(lst); i++ {\n        if lst[i][0] == x {\n            return lst[i]\n        }\n    }\n    \n    return [][]interface{}{}\n}\n\n// sort coordinates by rows\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpghetqetm_test.go:29:5: undefined: sort_by_rows\n/tmp/tmpghetqetm_test.go:32:5: undefined: sort_by_columns\n/tmp/tmpghetqetm_test.go:37:23: cannot use lst[i] (type []int) as type [][]interface {} in return argument\n/tmp/tmpghetqetm_test.go:52:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpghetqetm_test.go:53:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpghetqetm_test.go:54:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpghetqetm_test.go:57:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpghetqetm_test.go:57:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return lst\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return lst\n    }\n    if len(lst[x][0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 1 {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] < x {\n        return [][]interface{}{}\n    }\n    if lst[x][0][0] > x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n        return lst\n    }\n    if lst[x][0][0] == x {\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdj878jde_test.go:89:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_yyuw1ca_test.go:53:116: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{0, 0}, {1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}}\n    }\n    if len(lst[0]) == 9 {\n        return [][]interface{}{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}, {8, 8}}\n    }\n    if len(l\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2ct8y44z_test.go:58:13: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqryoe7ve_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpqryoe7ve_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    row_list := make([][]interface{}, len(lst))\n    for i, _ := range lst {\n        row_list[i] = make([]interface{}, len(lst[i]))\n    }\n    \n    for i, _ := range lst {\n        for j, _ := range lst[i] {\n            row_list[i][j] = lst[i][j]\n        }\n    }\n    \n    sort_by_row(row_list)\n    \n    for i, _ := range row_list {\n        sort_by_column(row_list[i])\n    }\n    \n    for i, _ := range row_list {\n        for j, _ := range row_list[i] {\n            if row_list[i][j] == x {\n                return row_list\n            }\n        }\n    }\n    \n    return row_list\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg9v8pgdr_test.go:40:5: undefined: sort_by_row\n/tmp/tmpg9v8pgdr_test.go:43:9: undefined: sort_by_column\n/tmp/tmpg9v8pgdr_test.go:64:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg9v8pgdr_test.go:65:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg9v8pgdr_test.go:66:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpg9v8pgdr_test.go:69:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpg9v8pgdr_test.go:69:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        var row []interface{}\n        for j := 0; j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                row = append(row, j)\n            }\n        }\n        if len(row) > 0 {\n            result = append(result, row)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp96yt05j1_test.go:46:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp96yt05j1_test.go:47:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp96yt05j1_test.go:48:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp96yt05j1_test.go:51:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp96yt05j1_test.go:51:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_98qezeb_test.go:68:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_98qezeb_test.go:69:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_98qezeb_test.go:70:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_98qezeb_test.go:73:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp_98qezeb_test.go:73:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][2]}, []interface{}{3, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][2]}, []interface{}{3, lst[0][3]}, []interface{}{4, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][2]}, []interface{}{3, lst[0][3]}, []interface{}{4, lst[0][4]}, []interface{}{5, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, lst[0][1]}, []interface{}{2, lst[0][\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7a6632uj_test.go:50:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 11 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 12 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 13 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 14 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 15 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 16 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 17 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 18 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 19 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 20 {\n        return [][]interface{}{}\n    }\n    if len(lst) ==\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpamuyb1cr_test.go:88:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{{0, 0}, {0, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}}\n    }\n    if len(lst[x]) == 7 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}}\n    }\n    if len(lst[x]) == 8 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}}\n    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphnpy9d1u_test.go:63:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x < 0 {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if lst[x][0] == 0 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if lst[x][0] == len(lst[x]) - 1 {\n        return [][]interface{}{[]interface{}{x, len(lst[x]) - 1}}\n    }\n    if lst[x][0] == 0 {\n        return [][]interface{}{[]interface{}{x, lst[x][0] - 1}}\n    }\n    if lst[x][len(lst[x]) - 1] == 0 {\n        return [][]interface{}{[]interface{}{x, lst[x][len(lst[x]) - 1] + 1}}\n    }\n    if lst[x][len(lst[x]) - 1] == len(lst[x]) - 1 {\n        return [][]interface{}{[]interface{}{x, lst[x][len(lst[x]) - 1]}}\n    }\n    return [][]interface{}{[]interface{}{x, lst[x][0] - 1}}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpks0m2q32_test.go:71:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpks0m2q32_test.go:72:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpks0m2q32_test.go:73:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpks0m2q32_test.go:76:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpks0m2q32_test.go:76:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 9 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 10 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 11 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 12 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 13 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 14 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 15 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 16 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 17 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpid2ff2u1_test.go:82:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n        }\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{\n            []interface{}{x, 0},\n        }\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{\n            []interface{}{x, 0},\n            []interface{}{x, 1},\n        }\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{\n            []interface{}{x, 0},\n            []interface{}{x, 1},\n            []interface{}{x, 2},\n        }\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{\n            []interface{}{x, 0},\n            []interface{}{x, 1},\n            []interface{}{x, 2},\n            []interface{}{x, 3},\n        }\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{\n            []interface{}{x, 0},\n            []interface{}{x, 1},\n            []interface{}{x, 2},\n            []interface{}{x, 3},\n            []interface{}{x, 4},\n        }\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{\n            []interface{}{x, 0},\n            []interface{}{x, 1},\n            []interface{}{x, 2},\n            []interface{}{x, 3},\n            []interface{}{x, 4},\n            \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpc_stvoln_test.go:85:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{{0, 0}, {0, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}}\n    }\n    if len(lst[x]) == 7 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}}\n    }\n    if len(lst[x]) == 8 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}}\n    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphnpy9d1u_test.go:63:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return lst\n    }\n    if lst[0][0] == x {\n        return lst\n    }\n    if lst[0][1] == x {\n        return lst\n    }\n    if lst[0][2] == x {\n        return lst\n    }\n    if lst[0][3] == x {\n        return lst\n    }\n    if lst[0][4] == x {\n        return lst\n    }\n    if lst[0][5] == x {\n        return lst\n    }\n    if lst[0][6] == x {\n        return lst\n    }\n    if lst[0][7] == x {\n        return lst\n    }\n    if lst[0][8] == x {\n        return lst\n    }\n    if lst[0][9] == x {\n        return lst\n    }\n    if lst[0][10] == x {\n        return lst\n    }\n    if lst[0][11] == x {\n        return lst\n    }\n    if lst[0][12] == x {\n        return lst\n    }\n    if lst[0][13] == x {\n        return lst\n    }\n    if lst[0][14] == x {\n        return lst\n    }\n    if lst[0][15] == x {\n        return lst\n    }\n    if lst[0][16] == x {\n        return lst\n    }\n    if lst[0][17] == x {\n        return lst\n    }\n    if lst[0][18] == x {\n        return lst\n    }\n    if lst[0][19] == x {\n        return lst\n    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpskoa888z_test.go:98:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        if len(lst[i]) > x {\n            result = append(result, []interface{}{i, lst[i][x]})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprlr4u0so_test.go:40:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprlr4u0so_test.go:41:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprlr4u0so_test.go:42:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprlr4u0so_test.go:45:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmprlr4u0so_test.go:45:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        if len(lst[i]) > x {\n            result = append(result, []interface{}{i, lst[i][x]})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprlr4u0so_test.go:40:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprlr4u0so_test.go:41:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprlr4u0so_test.go:42:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprlr4u0so_test.go:45:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmprlr4u0so_test.go:45:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{{lst[x][0], lst[x][0]}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][1], lst[x][0]}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][1], lst[x][2]}, {lst[x][2], lst[x][0]}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][1], lst[x][2]}, {lst[x][2], lst[x][3]}, {lst[x][3], lst[x][0]}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{{lst[x][0], lst[x][1]}, {lst[x][1], lst[x][2]}, {lst[x][2], lst[x][3]}, {lst[x][3], lst[x][4]}, {lst[x][4], lst[x][0]}}\n    }\n    if\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0nzn77hv_test.go:55:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n        }\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{0, 1},\n        }\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{0, 1},\n            []interface{}{0, 2},\n        }\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{0, 1},\n            []interface{}{0, 2},\n            []interface{}{0, 3},\n        }\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{0, 1},\n            []interface{}{0, 2},\n            []interface{}{0, 3},\n            []interface{}{0, 4},\n        }\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{0, 1},\n            []interface{}{0, 2},\n            []interface{}{0, 3},\n            []interface{}{0, 4},\n            []interface{}{0, 5},\n        }\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{\n            []interface{}{0, 0},\n            []interface{}{0, 1},\n            []interface{}{0, 2},\n            []interface{}{0, 3},\n            []interface{}{0, 4},\n            []interface{}{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpha8nvu3b_test.go:84:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[x][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[x][0]}, []interface{}{x, lst[x][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[x][0]}, []interface{}{x, lst[x][1]}, []interface{}{x, lst[x][2]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy7k3etxf_test.go:53:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy7k3etxf_test.go:54:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy7k3etxf_test.go:55:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy7k3etxf_test.go:58:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpy7k3etxf_test.go:58:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    var row_list [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        row_list = append(row_list, []interface{}{i, lst[i][x]})\n    }\n    row_list = sort_row(row_list)\n    return row_list\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3o9_u7qk_test.go:41:16: undefined: sort_row\n/tmp/tmp3o9_u7qk_test.go:52:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3o9_u7qk_test.go:53:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3o9_u7qk_test.go:54:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3o9_u7qk_test.go:57:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp3o9_u7qk_test.go:57:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x < lst[0][0] {\n        return [][]interface{}{}\n    }\n    if x > lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{}\n    }\n    if x == lst[0][0] {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x == lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{[]interface{}{x, lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1]}}\n    }\n    for i := 0; i < len(lst); i++ {\n        if x == lst[i][0] {\n            return [][]interface{}{[]interface{}{x, lst[i][0]}}\n        }\n        if x == lst[i][len(lst[i]) - 1] {\n            return [][]interface{}{[]interface{}{x, lst[i][len(lst[i]) - 1]}}\n        }\n        if x < lst[i][0] {\n            return [][]interface{}{}\n        }\n        if x > lst[i][len(lst[i]) - 1] {\n            return [][]interface{}{}\n        }\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_w8rxni0_test.go:69:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_w8rxni0_test.go:70:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_w8rxni0_test.go:71:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_w8rxni0_test.go:74:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp_w8rxni0_test.go:74:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][4]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][4]}, {lst[0][0], lst[0\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3kb8rw6g_test.go:46:145: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_q140rla_test.go:54:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 1 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][0]}\n    }\n    if len(lst[x][0]) == 2 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1]}\n    }\n    if len(lst[x][0]) == 3 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2]}\n    }\n    if len(lst[x][0]) == 4 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3]}\n    }\n    if len(lst[x][0]) == 5 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4]}\n    }\n    if len(lst[x][0]) == 6 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4], lst[x][0][5]}\n    }\n    if len(lst[x][0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbsgrzwl0_test.go:58:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {0, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0, 7}, {0, 8}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {0, 5}, {0, 6}, {0\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbmx7yaqb_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    \n    if x > len(lst) {\n        return [][]interface{}{}\n    }\n    \n    if x < 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    \n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    \n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    \n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    \n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    \n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    \n    if len(lst[0]) ==\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi7l_x47b_test.go:74:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x < lst[0][0] {\n        return [][]interface{}{}\n    }\n    if x > lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{}\n    }\n    if x == lst[0][0] {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if x == lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{[]interface{}{x, lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1]}}\n    }\n    if x > lst[0][0] && x < lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1]}}\n    }\n    if x < lst[0][0] {\n        return [][]interface{}{get_row(lst, x)}, []interface{}{}\n    }\n    if x > lst[len(lst) - 1][len(lst[len(lst) - 1]) - 1] {\n        return [][]interface{}{}, get_row(lst, x)\n    }\n    return [][]interface{}{get_row(lst, x)}, get_row(lst, x)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeyehp9g9_test.go:49:9: too many arguments to return\n\thave ([][]interface {}, []interface {})\n\twant ([][]interface {})\n/tmp/tmpeyehp9g9_test.go:49:39: cannot use get_row(lst, x) (type [][]interface {}) as type []interface {} in slice literal\n/tmp/tmpeyehp9g9_test.go:52:9: too many arguments to return\n\thave ([][]interface {}, [][]interface {})\n\twant ([][]interface {})\n/tmp/tmpeyehp9g9_test.go:54:5: too many arguments to return\n\thave ([][]interface {}, [][]interface {})\n\twant ([][]interface {})\n/tmp/tmpeyehp9g9_test.go:54:35: cannot use get_row(lst, x) (type [][]interface {}) as type []interface {} in slice literal\n/tmp/tmpeyehp9g9_test.go:64:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyehp9g9_test.go:65:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyehp9g9_test.go:66:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyehp9g9_test.go:69:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpeyehp9g9_test.go:69:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyehp9g9_test.go:69:119: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqryoe7ve_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpqryoe7ve_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4zrsyr52_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4zrsyr52_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4zrsyr52_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4zrsyr52_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp4zrsyr52_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppmwbg6oz_test.go:52:137: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    \n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    \n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    \n    if len(lst[0]) > 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    \n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9xij_qgs_test.go:55:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9xij_qgs_test.go:56:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9xij_qgs_test.go:57:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9xij_qgs_test.go:60:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmp9xij_qgs_test.go:60:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoay61emb_test.go:67:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:68:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:69:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoay61emb_test.go:72:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpoay61emb_test.go:72:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqryoe7ve_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqryoe7ve_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpqryoe7ve_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppmwbg6oz_test.go:52:137: expected expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    coordinates := make([][]interface{}, 0)\n    for i := 0; i < len(lst[x]); i++ {\n        coordinates = append(coordinates, []interface{}{i, lst[x][i]})\n    }\n    coordinates = sort_coordinates(coordinates)\n    for i := 0; i < len(coordinates); i++ {\n        coordinates[i][0] = i\n    }\n    return coordinates\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpip06ovmm_test.go:41:19: undefined: sort_coordinates\n/tmp/tmpip06ovmm_test.go:55:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpip06ovmm_test.go:56:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpip06ovmm_test.go:57:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpip06ovmm_test.go:60:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpip06ovmm_test.go:60:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe4mzti0y_test.go:60:16: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if lst[x][0] == lst[x - 1][0] {\n        return [][]interface{}{[]interface{}{x - 1, lst[x - 1][1]}}\n    }\n    if lst[x][0] < lst[x - 1][0] {\n        return [][]interface{}{[]interface{}{x - 1, lst[x - 1][1]}}\n    }\n    if lst[x][0] > lst[x - 1][0] {\n        return [][]interface{}{[]interface{}{x, lst[x][1]}}\n    }\n    if lst[x][0] == lst[x - 1][0] {\n        return [][]interface{}{[]interface{}{x, lst[x][1]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppo_x0pc6_test.go:64:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppo_x0pc6_test.go:65:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppo_x0pc6_test.go:66:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppo_x0pc6_test.go:69:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmppo_x0pc6_test.go:69:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if x < 0 || x >= len(lst) {\n        return [][]interface{}{}\n    }\n    if len(lst[x]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[x][0]) == 1 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][0]}\n    }\n    if len(lst[x][0]) == 2 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1]}\n    }\n    if len(lst[x][0]) == 3 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2]}\n    }\n    if len(lst[x][0]) == 4 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3]}\n    }\n    if len(lst[x][0]) == 5 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4]}\n    }\n    if len(lst[x][0]) == 6 {\n        return [][]interface{}{lst[x][0][0], lst[x][0][1], lst[x][0][2], lst[x][0][3], lst[x][0][4], lst[x][0][5]}\n    }\n    if len(lst[x][0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbsgrzwl0_test.go:58:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4e8951v_test.go:58:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:59:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:60:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl4e8951v_test.go:63:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpl4e8951v_test.go:63:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{{0, 0}, {1, 0}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}}\n    }\n    if len(lst) == 9 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}, {8, 0}}\n    }\n    if len(lst) == 10 {\n        return [][]interface{}{{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmrzwqv9o_test.go:55:90: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{lst[0][0], lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][4]}, {lst[0][0], lst[0][1]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{lst[0][0], lst[0][1]}, {lst[0][0], lst[0][2]}, {lst[0][0], lst[0][3]}, {lst[0][0], lst[0][4]}, {lst[0][0], lst[0\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3kb8rw6g_test.go:46:145: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{lst[0][0], lst[0][0]}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{lst[0][0], lst[0][1]}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2]}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3]}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4]}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5]}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6]}\n    }\n    if len(lst[0]) == 8 {\n        return [][]interface{}{lst[0][0], lst[0][1], lst[0][2], lst[0][3], lst[0][4], lst[0][5], lst[0][6],\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9y4i_539_test.go:56:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return lst\n    }\n    if len(lst[0]) == 0 {\n        return lst\n    }\n    if len(lst[0]) == 1 {\n        return lst\n    }\n    if lst[0][0] == x {\n        return lst\n    }\n    if lst[0][0] < x {\n        return lst\n    }\n    if lst[0][0] > x {\n        return lst\n    }\n    if lst[0][1] == x {\n        return lst\n    }\n    if lst[0][1] < x {\n        return lst\n    }\n    if lst[0][1] > x {\n        return lst\n    }\n    if lst[0][2] == x {\n        return lst\n    }\n    if lst[0][2] < x {\n        return lst\n    }\n    if lst[0][2] > x {\n        return lst\n    }\n    if lst[0][3] == x {\n        return lst\n    }\n    if lst[0][3] < x {\n        return lst\n    }\n    if lst[0][3] > x {\n        return lst\n    }\n    if lst[0][4] == x {\n        return lst\n    }\n    if lst[0][4] < x {\n        return lst\n    }\n    if lst[0][4] > x {\n        return lst\n    }\n    if lst[0][5] == x {\n        return lst\n    }\n    if lst[0][5] < x {\n        return lst\n    }\n    if lst[0][5] > x {\n        return lst\n    }\n    if lst[0][6] == x {\n        return lst\n    }\n    if lst[0][6] < x {\n        return lst\n    }\n    if lst[0][\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprauapm54_test.go:97:6: expected '(', found TestGet_Row\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    // Write your code here\n    if len(lst) == 0 {\n        return lst\n    }\n    \n    row_list := make([][]interface{}, len(lst))\n    for i := 0; i < len(lst); i++ {\n        row_list[i] = make([]interface{}, len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            row_list[i][j] = lst[i][j]\n        }\n    }\n    \n    sort_row(row_list)\n    \n    for i := 0; i < len(row_list); i++ {\n        for j := 0; j < len(row_list[i]); j++ {\n            if row_list[i][j] == x {\n                return row_list\n            }\n        }\n    }\n    \n    return row_list\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmx4m0icm_test.go:26:9: cannot use lst (type [][]int) as type [][]interface {} in return argument\n/tmp/tmpmx4m0icm_test.go:37:5: undefined: sort_row\n/tmp/tmpmx4m0icm_test.go:57:145: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmx4m0icm_test.go:58:220: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmx4m0icm_test.go:59:245: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmx4m0icm_test.go:62:39: cannot use []interface {}{...} (type []interface {}) as type [][]int in argument to candidate\n/tmp/tmpmx4m0icm_test.go:62:119: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{{0, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}, {5, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]interface{}{{0, lst[0][0]}, {1, lst[0][1]}, {2, lst[0][2]}, {3, lst[0][3]}, {4, lst[0][4]}, {5, lst\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1z2qtqc1_test.go:49:119: missing ',' before newline in composite literal\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}}\n    }\n    if len(lst[0]) == 2 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}}\n    }\n    if len(lst[0]) == 3 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}}\n    }\n    if len(lst[0]) == 4 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}}\n    }\n    if len(lst[0]) == 5 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}}\n    }\n    if len(lst[0]) == 6 {\n        return [][]interface{}{[]interface{}{x, lst[0][0]}, []interface{}{x, lst[0][1]}, []interface{}{x, lst[0][2]}, []interface{}{x, lst[0][3]}, []interface{}{x, lst[0][4]}, []interface{}{x, lst[0][5]}}\n    }\n    if len(lst[0]) == 7 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjqw9zh1_test.go:49:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x < 0 || x > len(lst) {\n        return [][]interface{}{}\n    }\n    if x == 0 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if x == len(lst) {\n        return [][]interface{}{[]interface{}{len(lst) - 1, len(lst[len(lst) - 1]) - 1}}\n    }\n    if len(lst[x]) == 1 {\n        return [][]interface{}{[]interface{}{x, 0}}\n    }\n    if len(lst[x]) == 2 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}}\n    }\n    if len(lst[x]) == 3 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}}\n    }\n    if len(lst[x]) == 4 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}}\n    }\n    if len(lst[x]) == 5 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}}\n    }\n    if len(lst[x]) == 6 {\n        return [][]interface{}{[]interface{}{x, 0}, []interface{}{x, 1}, []interface{}{x, 2}, []interface{}{x, 3}, []interface{}{x, 4}, []interface{}{x, 5}}\n    }\n    if len(l\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374876,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzys3u0kg_test.go:60:13: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int, x int) [][]interface{} {\n    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{[]interface{}{0, 0}}\n    }\n    if len(lst) == 2 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}}\n    }\n    if len(lst) == 3 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}}\n    }\n    if len(lst) == 4 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}}\n    }\n    if len(lst) == 5 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}}\n    }\n    if len(lst) == 6 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}}\n    }\n    if len(lst) == 7 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}}\n    }\n    if len(lst) == 8 {\n        return [][]interface{}{[]interface{}{0, 0}, []interface{}{1, 1}, []interface{}{2, 2}, []interface{}{3, 3}, []interface{}{4, 4}, []interface{}{5, 5}, []interface{}{6, 6}, []interface{}{7, 7}}\n    }\n    if len(lst) == 9 {\n        return [][]\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcdsbbqc_test.go:52:20: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}