{
  "name": "HumanEval_6_parse_nested_parens",
  "language": "go_test.go",
  "prompt": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n",
  "tests": "func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else {\n            paren_list = append(paren_list, len(paren_list) - len(paren_list))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmptg4k5fi0_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=14) %!s(int=0) %!s(int=0) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=0) %!s(int=0) %!s(int=22) %!s(int=0) %!s(int=24) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmptg4k5fi0_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmptg4k5fi0_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            for j := i - 1; j >= 0; j-- {\n                if paren_string[paren_list[j]] == '(' {\n                    paren_list = append(paren_list, j)\n                    break\n                }\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm14cv9y_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm14cv9y_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm14cv9y_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9hjbmrg8_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9hjbmrg8_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9hjbmrg8_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            if len(paren_stack) == len(paren_stack) - 1 {\n                paren_list = append(paren_list, len(paren_stack))\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "Error: Unbalanced parentheses\nError: Unbalanced parentheses\n--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp57wggp20_test.go:53: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp57wggp20_test.go:53: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp57wggp20_test.go:53: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_groups = append(paren_groups, 0)\n        } else {\n            paren_groups = append(paren_groups, len(paren_stack))\n        }\n    }\n    return paren_groups\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpbpdqkkna_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpbpdqkkna_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpbpdqkkna_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string)-i-1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpmgrfk3fi_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpmgrfk3fi_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpmgrfk3fi_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_groups = append(paren_groups, len(paren_stack)-1)\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                paren_groups = append(paren_groups, 0)\n            }\n        }\n    }\n    return paren_groups\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp_m7jplnh_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp_m7jplnh_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp_m7jplnh_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            parens = append(parens, len(parens))\n        } else {\n            parens = append(parens, len(parens)-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpwvftof9d_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=14) %!s(int=14) %!s(int=15) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=19) %!s(int=20) %!s(int=22) %!s(int=22) %!s(int=24) %!s(int=24) %!s(int=25)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpwvftof9d_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpwvftof9d_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else if paren_string[i] == ')' {\n            paren_list = append(paren_list, len(paren_list) - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=12) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=16) %!s(int=17) %!s(int=19) %!s(int=19) %!s(int=21) %!s(int=21) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string = \"(\" + paren_string + \")\"\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string)-i-1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfqhejo0j_test.go:39: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=28) %!s(int=27) %!s(int=26) %!s(int=24) %!s(int=20) %!s(int=19) %!s(int=18) %!s(int=13) %!s(int=10) %!s(int=9) %!s(int=8) %!s(int=5) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfqhejo0j_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=24) %!s(int=23) %!s(int=20) %!s(int=19) %!s(int=15) %!s(int=14) %!s(int=13) %!s(int=8) %!s(int=7) %!s(int=6) %!s(int=5)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfqhejo0j_test.go:39: expected '[%!s(int=4)]', got '[%!s(int=15) %!s(int=14) %!s(int=13) %!s(int=11) %!s(int=10) %!s(int=7) %!s(int=6) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for _, paren_group := range strings.Split(paren_string, \" \") {\n        paren_list = append(paren_list, len(paren_group))\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3h3moled_test.go:15:33: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for _, paren_group := range paren_string {\n        if paren_group == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else {\n            paren_list = append(paren_list, len(paren_list) - len(paren_list))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=14) %!s(int=0) %!s(int=0) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=0) %!s(int=0) %!s(int=22) %!s(int=0) %!s(int=24) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            for j := i; j >= 0; j-- {\n                if paren_string[j] == '(' {\n                    paren_list = append(paren_list, j)\n                    break\n                }\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpdrd0iny5_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpdrd0iny5_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpdrd0iny5_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    for len(paren_groups) > 0 {\n        paren_group := paren_groups[0]\n        paren_groups = paren_groups[1:]\n        paren_groups = append(paren_groups, paren_group)\n        for len(paren_groups) > 0 {\n            paren_group = paren_groups[0]\n            paren_groups = paren_groups[1:]\n            if len(paren_group) > 0 {\n                if paren_group[0] == '(' {\n                    paren_groups = append(paren_groups, paren_group)\n                } else {\n                    break\n                }\n            }\n        }\n    }\n    result := make([]int, 0)\n    for i := 0; i < len(paren_groups); i++ {\n        paren_group := paren_groups[i]\n        if len(paren_group) > 0 {\n            if paren_group[0] == '(' {\n                result = append(result, len(paren_group) - 1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374891,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]int, 0)\n    paren_groups = append(paren_groups, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_groups = append(paren_groups, len(paren_groups))\n        } else if paren_string[i] == ')' {\n            paren_groups = paren_groups[:len(paren_groups)-1]\n        }\n    }\n    return paren_groups\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_list = append(paren_list, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else if paren_string[i] == ')' {\n            paren_list = paren_list[:len(paren_list)-1]\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string = \"(\" + paren_string + \")\"\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string) - i - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4r8kuc9v_test.go:39: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=28) %!s(int=27) %!s(int=26) %!s(int=24) %!s(int=20) %!s(int=19) %!s(int=18) %!s(int=13) %!s(int=10) %!s(int=9) %!s(int=8) %!s(int=5) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4r8kuc9v_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=24) %!s(int=23) %!s(int=20) %!s(int=19) %!s(int=15) %!s(int=14) %!s(int=13) %!s(int=8) %!s(int=7) %!s(int=6) %!s(int=5)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4r8kuc9v_test.go:39: expected '[%!s(int=4)]', got '[%!s(int=15) %!s(int=14) %!s(int=13) %!s(int=11) %!s(int=10) %!s(int=7) %!s(int=6) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string = \"(\" + paren_string + \")\"\n    paren_stack := []int{0}\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    return paren_stack\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpos91jckd_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpos91jckd_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpos91jckd_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string = paren_string + \" \"\n    paren_counts := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_counts = append(paren_counts, 1)\n        } else if paren_string[i] == ')' {\n            paren_counts = append(paren_counts, -1)\n        }\n    }\n    for i := 0; i < len(paren_counts); i++ {\n        if paren_counts[i] > 0 {\n            for j := i; j < len(paren_counts); j++ {\n                if paren_counts[j] < 0 {\n                    paren_counts[j] += paren_counts[i]\n                    paren_counts[i] = 0\n                    break\n                }\n            }\n        }\n    }\n    for i := 0; i < len(paren_counts); i++ {\n        if paren_counts[i] != 0 {\n            return []int{i}\n        }\n    }\n    return paren_counts\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpe30extuo_test.go:57: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpe30extuo_test.go:57: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpe30extuo_test.go:57: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    for _, group := range strings.Split(paren_string, \" \") {\n        result = append(result, parse_nested_parens_inner(group)...)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5d__2_2j_test.go:15:27: undefined: strings\n/tmp/tmp5d__2_2j_test.go:16:33: undefined: parse_nested_parens_inner\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var depth int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, depth)\n            depth++\n        } else if paren_string[i] == ')' {\n            depth = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n            if len(paren_stack) == 0 {\n                result = append(result, paren_count)\n            }\n            paren_count--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp1m2moubj_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp1m2moubj_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp1m2moubj_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var paren_count int\n    var paren_depth int\n    var paren_stack []int\n    var paren_stack_top int\n    var paren_stack_top_prev int\n    var paren_stack_top_prev_prev int\n    var paren_stack_top_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev int\n    var paren_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpr4pfnoy2_test.go:35:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var stack []int\n    for _, paren := range paren_string {\n        if paren == '(' {\n            stack = append(stack, 1)\n        } else if paren == ')' {\n            stack = stack[:len(stack)-1]\n        } else {\n            if len(stack) == 0 {\n                result = append(result, 0)\n            } else {\n                result = append(result, len(stack))\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpo9s31qxa_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpo9s31qxa_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpo9s31qxa_test.go:47: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    for _, paren_group := range paren_string {\n        if paren_group == \"(\" {\n            paren_groups = append(paren_groups, \"\")\n        } else {\n            paren_groups[len(paren_groups)-1] += paren_group\n        }\n    }\n    result := make([]int, 0)\n    for i := len(paren_groups) - 1; i >= 0; i-- {\n        if len(paren_groups[i]) > 0 {\n            result = append(result, len(paren_groups[i]) - 1)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj3veu7xv_test.go:16:24: cannot use \"(\" (type untyped string) as type rune\n/tmp/tmpj3veu7xv_test.go:19:47: invalid operation: paren_groups[len(paren_groups) - 1] += paren_group (mismatched types string and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else {\n            paren_list = append(paren_list, len(paren_list) - len(paren_list))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpft0agl3__test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=14) %!s(int=0) %!s(int=0) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=0) %!s(int=0) %!s(int=22) %!s(int=0) %!s(int=24) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpft0agl3__test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpft0agl3__test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]int, 0)\n    paren_groups = append(paren_groups, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_groups = append(paren_groups, len(paren_groups))\n        } else if paren_string[i] == ')' {\n            paren_groups = paren_groups[:len(paren_groups)-1]\n        }\n    }\n    return paren_groups\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpk7eezx9q_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpk7eezx9q_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpk7eezx9q_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []int{}\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses.\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpb4ambalk_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpb4ambalk_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpb4ambalk_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            stack = append(stack, i)\n        } else if paren_string[i] == ')' {\n            if len(stack) == 0 {\n                result = append(result, 0)\n            } else {\n                result = append(result, len(stack) - 1)\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpgbzb0zr1_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpgbzb0zr1_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpgbzb0zr1_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Paren stack is empty\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if paren_string[i] == ' ' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Paren stack is empty\")\n                return nil\n            }\n            if len(paren_stack) == 1 {\n                paren_list = append(paren_list, len(paren_stack))\n            } else {\n                paren_list = append(paren_list, len(paren_stack)-1)\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "Error: Paren stack is empty\nError: Paren stack is empty\n--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpvs9p8r1o_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpvs9p8r1o_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpvs9p8r1o_test.go:55: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string) - i - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_stack = append(paren_stack, paren)\n        } else if paren == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n            if len(paren_stack) == 0 {\n                paren_list = append(paren_list, len(paren_stack))\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374874,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0g9_t58_test.go:18:33: cannot use paren (type rune) as type int in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var current_group int\n    var current_paren_count int\n    var current_paren_string string\n    var current_paren_string_count int\n    var current_paren_string_index int\n    var current_paren_string_count_index int\n    var current_paren_string_index_count int\n    var current_paren_string_index_count_index int\n    var current_paren_string_index_count_index_count int\n    var current_paren_string_index_count_index_count_index int\n    var current_paren_string_index_count_index_count_index_count_index int\n    var current_paren_string_index_count_index_count_index_count_index_count_index int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count_index int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count_index_count int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count_index_count_index int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count_index_count_index int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count_index_count_index_count int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count_index_count_index_count int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count_index_count_index_count int\n    var current_paren_string_index_count_index_count_index_count_index_count_index_count_index_count_index_count int\n    var current_paren_string_index_count_index_\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa4gwmmr5_test.go:37:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]int, 0)\n    paren_groups = append(paren_groups, 0)\n    for i := 1; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_groups = append(paren_groups, i)\n        } else if paren_string[i] == ')' {\n            paren_groups = append(paren_groups, i)\n            if len(paren_groups) == 0 {\n                return []int{0}\n            }\n            for j := len(paren_groups) - 1; j >= 0; j-- {\n                if paren_groups[j] == i {\n                    paren_groups = paren_groups[:j]\n                    break\n                }\n            }\n        }\n    }\n    return paren_groups\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpg9920xhh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpg9920xhh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpg9920xhh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_count = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if paren_count == 0 {\n            result = append(result, level)\n            level = 0\n        }\n        level++\n    }\n    if len(paren_stack) > 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2d3yfohe_test.go:58: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2d3yfohe_test.go:58: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2d3yfohe_test.go:58: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else if paren_string[i] == ')' {\n            paren_list = paren_list[:len(paren_list)-1]\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2fw9xmyt_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2fw9xmyt_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2fw9xmyt_test.go:40: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var current_count int\n    var max_level int\n    var max_count int\n    var current_char string\n    var current_char_count int\n    var current_char_count_max int\n    var current_char_count_min int\n    var current_char_count_diff int\n    var current_char_count_diff_max int\n    var current_char_count_diff_min int\n    var current_char_count_diff_diff int\n    var current_char_count_diff_diff_max int\n    var current_char_count_diff_diff_min int\n    var current_char_count_diff_diff_diff int\n    var current_char_count_diff_diff_diff_max int\n    var current_char_count_diff_diff_diff_min int\n    var current_char_count_diff_diff_diff_diff int\n    var current_char_count_diff_diff_diff_diff_max int\n    var current_char_count_diff_diff_diff_diff_min int\n    var current_char_count_diff_diff_diff_diff_diff int\n    var current_char_count_diff_diff_diff_diff_diff_max int\n    var current_char_count_diff_diff_diff_diff_diff_min int\n    var current_char_count_diff_diff_diff_diff_diff_diff int\n    var current_char_count_diff_diff_diff_diff_diff_diff_max int\n    var current_char_count_diff_diff_diff_diff_diff_diff_min int\n    var current_char_count_diff_diff_diff_diff_diff_diff_diff int\n    var current_char_count_diff_diff_diff_diff_diff_diff_diff_max int\n    var current_char_count_diff_diff_diff_diff_diff_diff_diff_min int\n    var current_char_count_diff_diff_diff_diff_diff_diff_diff_diff int\n    var current_char_count_diff_diff_diff_diff_diff_diff_diff_diff_max int\n    var current\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpf6bwdelm_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var current_group string\n    var current_group_count int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            current_level++\n            current_group_count = 0\n            current_group = \"\"\n        } else if paren_string[i] == ')' {\n            current_level--\n            if current_level == 0 {\n                result = append(result, current_group_count)\n            }\n        } else {\n            current_group_count++\n            current_group += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpdh0_3ga7_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpdh0_3ga7_test.go:51: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpdh0_3ga7_test.go:51: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            paren_level--\n        } else if paren_string[i] == ' ' {\n            if paren_count == 0 {\n                paren_list = append(paren_list, paren_level)\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmptha35szf_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmptha35szf_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmptha35szf_test.go:48: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var stack []int\n    var depth int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            stack = append(stack, depth)\n            depth++\n        } else if paren_string[i] == ')' {\n            depth = stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n        }\n        result = append(result, depth)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmptyeq948n_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmptyeq948n_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmptyeq948n_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []string{}\n    paren_list = append(paren_list, paren_string)\n    result := []int{}\n    for i := 0; i < len(paren_list); i++ {\n        if len(paren_list[i]) > 0 {\n            if paren_list[i][0] == '(' {\n                result = append(result, parse_nested_parens(paren_list[i])...)\n            } else {\n                result = append(result, len(paren_list[i]) - 1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398 stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x5472ac, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\nruntime.heapBitsSetType(0xc003fab4a0, 0x10, 0x10, 0x51ca60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/mbitmap.go:815 +0xc05 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x416245\nruntime.mallocgc(0x10, 0x51ca60, 0xc003fab401, 0x10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/malloc.go:1096 +0x5c5 fp=0xc0201e0430 sp=0xc0201e03a8 pc=0x40db65\nruntime.growslice(0x51ca60, 0xc0201e04d8, 0x0, 0x0, 0x1, 0x44d805, 0xc003fab490, 0xc0201e0570)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/slice.go:230 +0x1e9 fp=0xc0201e0498 sp=0xc0201e0430 pc=0x44d849\ncommand-line-arguments_test.parse_nested_parens(0x549fc0, 0x1b, 0x0, 0x0, 0x1)\n\t/tmp/tmpzsjb00uq_test.go:15 +0x5a fp=0xc0201e0530 sp=0xc0201e0498 pc=0x50a65a\ncommand-line-arguments_test.parse_nested_parens(0x549fc0, 0x1b, 0x0, 0x0, 0x1)\n\t/tmp/tmpzsjb00uq_test.go:20 +0x15f fp=0xc0201e05c8 sp=0xc0201e0530 pc=0x50a75f\ncommand-line-arguments_test.parse_nested_parens(0x549fc0, 0x1b, 0x0, 0x0, 0x1)\n\t/tmp/tmpzsjb00uq_test.go:20 +0x15f fp=0xc0201e0660 sp=0xc0201e05c8 pc=0x50a75f\ncommand-line-arguments_test.parse_nested_parens(0x549fc0, 0x1b, 0x0, 0x0, 0x1)\n\t/tmp/tmpzsjb00uq_test.go:20 +0x15f fp=0xc0201e06f8 sp=0xc0201e0660 pc=0x50a75f\ncommand-line-arguments_test.parse_nested_parens(0x549fc0, 0x1b, 0x0, 0x0, 0x1)\n\t/tmp/tmpzsjb00uq_test.go:20 +0x15f fp=0xc0201e0790 sp=0xc0201e06f8 pc=0x50a75f\ncommand-line-arguments_test.parse_nested_parens(0x549fc0, 0x1b, 0x0, 0x0, 0x1)\n\t/tmp/tmpzsjb00uq_test.go:20 +0x15f fp=0xc0201e0828 sp=0xc0201e0790 pc=0x50a75f\ncommand-line-arguments_test.parse_nested_parens(0x549fc0, 0x1b, 0x0, 0x0, 0x",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    result := make([]int, 0)\n    for i := 0; i < len(paren_groups); i++ {\n        paren_group := paren_groups[i]\n        paren_level := 0\n        for j := 0; j < len(paren_group); j++ {\n            if paren_group[j] == '(' {\n                paren_level++\n            } else if paren_group[j] == ')' {\n                paren_level--\n            }\n        }\n        if paren_level == 0 {\n            result = append(result, len(paren_group))\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpozsqq5yo_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=27)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpozsqq5yo_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=23)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpozsqq5yo_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=14)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    var paren_stack_index int\n    var paren_stack_top int\n    var paren_stack_top_index int\n    var paren_stack_top_value int\n    var paren_stack_top_value_index int\n    var paren_stack_top_value_value int\n    var paren_stack_top_value_value_index int\n    var paren_stack_top_value_value_value int\n    var paren_stack_top_value_value_value_index int\n    var paren_stack_top_value_value_value_value int\n    var paren_stack_top_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq2m1o0ho_test.go:41:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, len(result))\n        } else if paren_string[i] == ')' {\n            result = result[:len(result)-1]\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpa4liez74_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpa4liez74_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpa4liez74_test.go:40: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var depth int\n    var paren_count int\n    var paren_stack []int\n    var paren_stack_index int\n    var paren_stack_top int\n    var paren_stack_top_index int\n    var paren_stack_top_top int\n    var paren_stack_top_top_index int\n    var paren_stack_top_top_top int\n    var paren_stack_top_top_top_index int\n    var paren_stack_top_top_top_top int\n    var paren_stack_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptbhobgpp_test.go:41:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_list = append(paren_list, 0)\n    for i := 1; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_list) > 0 {\n                paren_list = paren_list[:len(paren_list)-1]\n            } else {\n                paren_list = append(paren_list, i)\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpbg8818vd_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpbg8818vd_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpbg8818vd_test.go:45: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_count = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if paren_count == 0 {\n            result = append(result, level)\n            level = 0\n        }\n        level++\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpzxhh12f4_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpzxhh12f4_test.go:54: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpzxhh12f4_test.go:54: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var paren_count int\n    var paren_stack []int\n    var paren_stack_index int\n    var paren_stack_top int\n    var paren_stack_top_index int\n    var paren_stack_top_top int\n    var paren_stack_top_top_index int\n    var paren_stack_top_top_top int\n    var paren_stack_top_top_top_index int\n    var paren_stack_top_top_top_top int\n    var paren_stack_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpuoa57xy8_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var current_paren_count int\n    var current_paren_string string\n    var current_paren_string_count int\n    var current_paren_string_index int\n    var current_paren_string_index_end int\n    var current_paren_string_index_start int\n    var current_paren_string_index_start_end int\n    var current_paren_string_index_start_end_end int\n    var current_paren_string_index_start_end_end_end int\n    var current_paren_string_index_start_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_end_end_end_end_end_end_end_end int\n    var current_paren_string_index_start_end_end_end_\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpuidgf691_test.go:37:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parentheses\")\n            }\n            paren_count = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if paren_count == 0 {\n            result = append(result, level)\n            level = 0\n        }\n        level++\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpf7ivq0fv_test.go:53: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpf7ivq0fv_test.go:53: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpf7ivq0fv_test.go:53: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []int{}\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpehxa_2my_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpehxa_2my_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpehxa_2my_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for _, paren_group := range paren_string {\n        if paren_group == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else {\n            paren_list = append(paren_list, len(paren_list) - len(paren_list))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=14) %!s(int=0) %!s(int=0) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=0) %!s(int=0) %!s(int=22) %!s(int=0) %!s(int=24) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []int{}\n    paren_stack := []int{}\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                paren_list = append(paren_list, len(paren_stack))\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpnakweaho_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpnakweaho_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpnakweaho_test.go:45: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpj8j71_ho_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpj8j71_ho_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpj8j71_ho_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var current_paren_count int\n    var current_paren_string string\n    var current_paren_string_index int\n    var current_paren_string_length int\n    var current_paren_string_length_index int\n    var current_paren_string_length_length int\n    var current_paren_string_length_length_index int\n    var current_paren_string_length_length_length int\n    var current_paren_string_length_length_length_index int\n    var current_paren_string_length_length_length_length int\n    var current_paren_string_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq8g09u5o_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_count = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if paren_count == 0 {\n            level = 0\n        } else {\n            level = len(paren_stack) - 1\n        }\n        result = append(result, level)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpw6ltpx6y_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=-1) %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=-1) %!s(int=-1) %!s(int=0) %!s(int=-1) %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=-1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpw6ltpx6y_test.go:55: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=-1) %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=-1) %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=-1) %!s(int=-1) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=-1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpw6ltpx6y_test.go:55: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=-1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string = \"(\" + paren_string + \")\"\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string)-i-1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfqhejo0j_test.go:39: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=28) %!s(int=27) %!s(int=26) %!s(int=24) %!s(int=20) %!s(int=19) %!s(int=18) %!s(int=13) %!s(int=10) %!s(int=9) %!s(int=8) %!s(int=5) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfqhejo0j_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=24) %!s(int=23) %!s(int=20) %!s(int=19) %!s(int=15) %!s(int=14) %!s(int=13) %!s(int=8) %!s(int=7) %!s(int=6) %!s(int=5)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfqhejo0j_test.go:39: expected '[%!s(int=4)]', got '[%!s(int=15) %!s(int=14) %!s(int=13) %!s(int=11) %!s(int=10) %!s(int=7) %!s(int=6) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var paren_count int\n    var paren_level int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_level = 0\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            paren_level++\n            if paren_level == 1 {\n                result = append(result, paren_stack[len(paren_stack) - 1])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9ymz_d8o_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=7) %!s(int=10) %!s(int=11) %!s(int=12)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9ymz_d8o_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=3) %!s(int=6) %!s(int=10)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9ymz_d8o_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=4) %!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else if paren_string[i] == ')' {\n            paren_list = append(paren_list, len(paren_list) - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=12) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=16) %!s(int=17) %!s(int=19) %!s(int=19) %!s(int=21) %!s(int=21) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else {\n            paren_list = append(paren_list, len(paren_list) - len(paren_list))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpft0agl3__test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=14) %!s(int=0) %!s(int=0) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=0) %!s(int=0) %!s(int=22) %!s(int=0) %!s(int=24) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpft0agl3__test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpft0agl3__test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            parens = append(parens, len(parens))\n        } else {\n            parens = append(parens, len(parens)-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpwvftof9d_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=14) %!s(int=14) %!s(int=15) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=19) %!s(int=20) %!s(int=22) %!s(int=22) %!s(int=24) %!s(int=24) %!s(int=25)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpwvftof9d_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpwvftof9d_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for _, paren_group := range paren_string {\n        if paren_group == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else {\n            paren_list = append(paren_list, len(paren_list) - len(paren_list))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=14) %!s(int=0) %!s(int=0) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=0) %!s(int=0) %!s(int=22) %!s(int=0) %!s(int=24) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string = \"(\" + paren_string + \")\"\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpq4_dhyu3_test.go:39: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=23) %!s(int=25)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpq4_dhyu3_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=4) %!s(int=5) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=19)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpq4_dhyu3_test.go:39: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8) %!s(int=9) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_list = append(paren_list, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else if paren_string[i] == ')' {\n            paren_list = paren_list[:len(paren_list)-1]\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return []int{}\n            }\n            paren_count = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return []int{}\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return []int{}\n            }\n            paren_count = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return []int{}\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return []int{}\n            }\n            paren\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppfwdcj4b_test.go:61:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfm51iwfq_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            paren_list = paren_list[:i]\n            break\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmptsu31yv6_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmptsu31yv6_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmptsu31yv6_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        switch paren_string[i] {\n            case '(':\n                paren_count++\n                paren_stack = append(paren_stack, paren_count)\n            case ')':\n                if len(paren_stack) == 0 {\n                    panic(fmt.Sprintf(\"Paren stack is empty at index %d\", i))\n                }\n                paren_count = paren_stack[len(paren_stack) - 1]\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n            case ' ':\n                if len(paren_stack) == 0 {\n                    panic(fmt.Sprintf(\"Paren stack is empty at index %d\", i))\n                }\n                if paren_count == paren_stack[len(paren_stack) - 1] {\n                    level = len(paren_stack)\n                    result = append(result, level)\n                }\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(fmt.Sprintf(\"Paren stack is not empty at index %d\", len(paren_stack)))\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: Paren stack is empty at index 6 [recovered]\n\tpanic: Paren stack is empty at index 6\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0xc00009a4b0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001680)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0xc00009a4b0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.parse_nested_parens(0x549fc0, 0x1b, 0x5fa2e0, 0x609a20, 0x0)\n\t/tmp/tmp1wuykmot_test.go:31 +0x357\ncommand-line-arguments_test.TestParse_Nested_Parens(0xc000001680)\n\t/tmp/tmp1wuykmot_test.go:52 +0x56\ntesting.tRunner(0xc000001680, 0x54f2f0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    var paren_stack_index int\n    var paren_stack_top int\n    var paren_stack_top_index int\n    var paren_stack_top_top int\n    var paren_stack_top_top_index int\n    var paren_stack_top_top_top int\n    var paren_stack_top_top_top_index int\n    var paren_stack_top_top_top_top int\n    var paren_stack_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_top int\n    var paren_stack_top_top_top_top_top_top_top_top_top_top_top_index int\n    var paren_stack_top_top_top\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7axkfel6_test.go:41:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var stack []int\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, 1)\n        } else if char == ')' {\n            if len(stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            stack = stack[:len(stack)-1]\n        }\n        if len(stack) == 0 {\n            result = append(result, len(stack))\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp_ojjwmv2_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp_ojjwmv2_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp_ojjwmv2_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    var paren_stack_index int\n    var paren_stack_top int\n    var paren_stack_top_index int\n    var paren_stack_top_index_found bool\n    var paren_stack_top_index_found_at_top bool\n    var paren_stack_top_index_found_at_bottom bool\n    var paren_stack_top_index_found_at_top_index int\n    var paren_stack_top_index_found_at_bottom_index int\n    var paren_stack_top_index_found_at_top_index_found bool\n    var paren_stack_top_index_found_at_bottom_index_found bool\n    var paren_stack_top_index_found_at_top_index_found_at_top bool\n    var paren_stack_top_index_found_at_bottom_index_found_at_bottom bool\n    var paren_stack_top_index_found_at_top_index_found_at_bottom_index int\n    var paren_stack_top_index_found_at_bottom_index_found_at_top_index int\n    var paren_stack_top_index_found_at_top_index_found_at_bottom_index_found bool\n    var paren_stack_top_index_found_at_bottom_index_found_at_top_index_found bool\n    var paren_stack_top_index_found_at_top_index_found_at_bottom_index_found_at_top bool\n    var paren_stack_top_index_found_at_bottom_index_found_at_top_index_found_at_bottom bool\n    var paren_stack_top_index_found_at_top_index_found_at_bottom_index_found_at_top_index int\n    var paren_stack_top_index_found_at_bottom_index_found_at_top_index_found_at_bottom_index int\n    var paren_stack_top_index\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp78a9i5zo_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    var paren_stack_index int\n    var paren_stack_top int\n    var paren_stack_top_index int\n    var paren_stack_top_value int\n    var paren_stack_top_value_index int\n    var paren_stack_top_value_value int\n    var paren_stack_top_value_value_index int\n    var paren_stack_top_value_value_value int\n    var paren_stack_top_value_value_value_index int\n    var paren_stack_top_value_value_value_value int\n    var paren_stack_top_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq2m1o0ho_test.go:41:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]int, 0)\n    paren_groups = append(paren_groups, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_groups = append(paren_groups, len(paren_groups))\n        } else if paren_string[i] == ')' {\n            paren_groups = paren_groups[:len(paren_groups)-1]\n        }\n    }\n    return paren_groups\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var current_paren_count int\n    var current_paren_string string\n    var current_paren_string_index int\n    var current_paren_string_length int\n    var current_paren_string_length_index int\n    var current_paren_string_length_length int\n    var current_paren_string_length_length_index int\n    var current_paren_string_length_length_length int\n    var current_paren_string_length_length_length_index int\n    var current_paren_string_length_length_length_length int\n    var current_paren_string_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length_length_length_length_length_index int\n    var current_paren_string_length_length_length_length_length_length_length_length_length_length_length int\n    var current_paren_string_length_length_length_length_length_length\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374877,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq8g09u5o_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string_array := make([]string, 0)\n    paren_string_array = append(paren_string_array, paren_string)\n    result := make([]int, 0)\n    for i := 0; i < len(paren_string_array); i++ {\n        current_string := paren_string_array[i]\n        if len(current_string) > 0 {\n            current_string_array := make([]string, 0)\n            current_string_array = append(current_string_array, current_string)\n            for j := 0; j < len(current_string_array); j++ {\n                current_string_array_element := current_string_array[j]\n                if len(current_string_array_element) > 0 {\n                    current_string_array_element_array := make([]string, 0)\n                    current_string_array_element_array = append(current_string_array_element_array, current_string_array_element)\n                    for k := 0; k < len(current_string_array_element_array); k++ {\n                        current_string_array_element_array_element := current_string_array_element_array[k]\n                        if len(current_string_array_element_array_element) > 0 {\n                            current_string_array_element_array_element_array := make([]string, 0)\n                            current_string_array_element_array_element_array = append(current_string_array_element_array_element_array, current_string_array_element_array_element)\n                            for l := 0; l < len(current_string_array_element_array_element_array); l++ {\n                                current_string_array_element_array_element_array_element := current_string_array_element_array_element_array[l]\n                                if len(current_string_array_element_array_element_array_element) > 0 {\n                                    current_string_array_element_array_element_array_element_array := make([]string, 0)\n                                    current_string_array_element_array_element_array_element_array = append(current_string\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp21lcdkxt_test.go:36:123: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string_array := []string{}\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpen_l6kmm_test.go:38:58: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var max_level int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            current_level++\n            if current_level > max_level {\n                max_level = current_level\n            }\n        } else if paren_string[i] == ')' {\n            current_level--\n        }\n        if current_level == 0 {\n            result = append(result, max_level)\n            max_level = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpra7ru6rh_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpra7ru6rh_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []int{}\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            if paren_stack[len(paren_stack)-1] == 0 {\n                paren_stack[len(paren_stack)-1] = -1\n            } else {\n                paren_stack[len(paren_stack)-1] = paren_stack[len(paren_stack)-1] + 1\n            }\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, paren_stack[len(paren_stack)-1])\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "Error: Unbalanced parentheses\nError: Unbalanced parentheses\n--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpg8xtrp0j_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpg8xtrp0j_test.go:60: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpg8xtrp0j_test.go:60: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []string{}\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_list = append(paren_list, \"\")\n        } else {\n            paren_list[len(paren_list)-1] += string(paren)\n        }\n    }\n    result := []int{}\n    for i, paren_str := range paren_list {\n        if len(paren_str) > 0 {\n            result = append(result, len(paren_str))\n        }\n        if i < len(paren_list)-1 {\n            result = append(result, len(paren_list[i+1]))\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp5qydwgn7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp5qydwgn7_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=2) %!s(int=0) %!s(int=3) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp5qydwgn7_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []int{}\n    paren_level := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_level++\n        } else if paren_string[i] == ')' {\n            paren_level--\n        }\n        if paren_level == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpy2ac8kjm_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string_array := []string{}\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, paren\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpen_l6kmm_test.go:38:58: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_list = append(paren_list, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else if paren_string[i] == ')' {\n            paren_list = paren_list[:len(paren_list)-1]\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpd68ak10t_test.go:41: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            for j := i; j >= 0; j-- {\n                if paren_string[paren_list[j]] == '(' {\n                    paren_list = append(paren_list, j)\n                    break\n                }\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpllo7j_9w_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpllo7j_9w_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpllo7j_9w_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []int{}\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpehxa_2my_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpehxa_2my_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpehxa_2my_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var current_paren_count int\n    var current_paren_string string\n    var current_paren_string_length int\n    var current_paren_string_index int\n    var current_paren_string_end_index int\n    var current_paren_string_end_index_found bool\n    var current_paren_string_end_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found bool\n    var current_paren_string_end_index_found_at_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found_at_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found_at_index_found_at_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index int\n    var current_paren_string_end_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index_found_at_index int\n    var current_paren_string_end_\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptlws7jz4_test.go:33:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_list = append(paren_list, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_list) == 0 {\n                panic(fmt.Sprintf(\"No matching left paren for right paren at index %d\", i))\n            }\n            paren_list = paren_list[:len(paren_list)-1]\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpiibx_r00_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpiibx_r00_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpiibx_r00_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var count int\n    var level int\n    var paren_count int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            count++\n            level++\n        } else if paren_string[i] == ')' {\n            count--\n            if count == 0 {\n                result = append(result, level)\n                level = 0\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjuj4l_k_test.go:17:9: paren_count declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            parens = append(parens, len(parens))\n        } else if paren == ')' {\n            parens = parens[:len(parens)-1]\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpz4onm5y__test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpz4onm5y__test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpz4onm5y__test.go:40: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string) - i - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var current_level int\n    var current_paren_count int\n    var current_paren_string string\n    var current_paren_index int\n    var current_paren_index_end int\n    var current_paren_index_start int\n    var current_paren_index_start_end int\n    var current_paren_index_start_end_end int\n    var current_paren_index_start_end_end_end int\n    var current_paren_index_start_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_end_end_end int\n    var current_paren_index_start_end_end_end_end_end_\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpirjb49d1_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var start int\n    var end int\n    var paren_count int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            start = i\n            paren_count++\n            level++\n        } else if paren_string[i] == ')' {\n            end = i\n            level--\n            if level == 0 {\n                result = append(result, paren_count)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgssy6qyt_test.go:16:9: start declared but not used\n/tmp/tmpgssy6qyt_test.go:17:9: end declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                level = len(paren_stack)\n                result = append(result, level)\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return []int{}\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpd7jd8pmh_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpd7jd8pmh_test.go:51: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpd7jd8pmh_test.go:51: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3) %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string)-i-1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpmgrfk3fi_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpmgrfk3fi_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpmgrfk3fi_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parentheses\")\n            }\n            paren_count = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if paren_count == 0 {\n            result = append(result, level)\n            level = 0\n        }\n        level++\n    }\n    if len(paren_stack) > 0 {\n        panic(\"unbalanced parentheses\")\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpy7c0ht3j_test.go:56: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpy7c0ht3j_test.go:56: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpy7c0ht3j_test.go:56: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, 0)\n        } else {\n            paren_list = append(paren_list, len(paren_stack))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp4tmk8dgh_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var depth int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, depth)\n            depth++\n        } else if paren_string[i] == ')' {\n            depth = paren_stack[len(paren_stack) - 1]\n            paren_count--\n            if paren_count == 0 {\n                result = append(result, depth)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpw0y3vkh7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=3) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpw0y3vkh7_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else if paren_string[i] == ')' {\n            paren_list = append(paren_list, len(paren_list) - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=12) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=16) %!s(int=17) %!s(int=19) %!s(int=19) %!s(int=21) %!s(int=21) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            for j := i; j >= 0; j-- {\n                if paren_string[j] == '(' {\n                    paren_list[i] = j\n                    break\n                }\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp0gisb9tz_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp0gisb9tz_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp0gisb9tz_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []string{}\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list =\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmkrp2ao5_test.go:47:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy08wjwow_test.go:51:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]int, 0)\n    paren_groups = append(paren_groups, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_groups = append(paren_groups, len(paren_groups))\n        } else if paren_string[i] == ')' {\n            paren_groups = paren_groups[:len(paren_groups)-1]\n        }\n    }\n    return paren_groups\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmplv709491_test.go:41: expected '[%!s(int=4)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var level int\n    var max_level int\n    var max_level_index int\n    var current_level int\n    var current_level_index int\n    var current_paren_index int\n    var current_paren_string string\n    var current_paren_string_index int\n    var current_paren_string_length int\n    var current_paren_string_length_index int\n    var current_paren_string_length_end int\n    var current_paren_string_length_end_index int\n    var current_paren_string_length_end_end int\n    var current_paren_string_length_end_end_index int\n    var current_paren_string_length_end_end_end int\n    var current_paren_string_length_end_end_end_index int\n    var current_paren_string_length_end_end_end_end int\n    var current_paren_string_length_end_end_end_end_index int\n    var current_paren_string_length_end_end_end_end_end int\n    var current_paren_string_length_end_end_end_end_end_index int\n    var current_paren_string_length_end_end_end_end_end_end int\n    var current_paren_string_length_end_end_end_end_end_end_index int\n    var current_paren_string_length_end_end_end_end_end_end_end int\n    var current_paren_string_length_end_end_end_end_end_end_end_index int\n    var current_paren_string_length_end_end_end_end_end_end_end_end int\n    var current_paren_string_length_end_end_end_end_end_end_end_end_index int\n    var current_paren_string_length_end_end_end_end_end_end_end_end_end int\n    var current_paren_string_length_end_end_end_end_end_end_end_end_end_index int\n    var current_paren_string_length_end_end_end_end_end_\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgltvnrg2_test.go:43:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string_array := make([]string, 0)\n    paren_string_array = append(paren_string_array, paren_string)\n    result := make([]int, 0)\n    for i := 0; i < len(paren_string_array); i++ {\n        if paren_string_array[i] == \"(\" {\n            result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpxm3k7xkb_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpxm3k7xkb_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpxm3k7xkb_test.go:40: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses.\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses.\")\n                return nil\n            }\n            if len(paren_stack) == 1 {\n                paren_list = append(paren_list, len(paren_stack))\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "Error: Unbalanced parentheses.\nError: Unbalanced parentheses.\n--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpfw8jtnpk_test.go:53: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfw8jtnpk_test.go:53: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpfw8jtnpk_test.go:53: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for _, paren_group := range paren_string {\n        if paren_group == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else {\n            paren_list = append(paren_list, len(paren_list) - len(paren_list))\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=14) %!s(int=0) %!s(int=0) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=0) %!s(int=0) %!s(int=22) %!s(int=0) %!s(int=24) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp98a5rtnr_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \")\n    paren_groups = append(paren_groups, paren_string)\n    paren\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpneirejju_test.go:47:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_list = append(paren_list, 0)\n    for i := 1; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_list) > 0 {\n                paren_list = paren_list[:len(paren_list)-1]\n            } else {\n                paren_list = append(paren_list, i)\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374878,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpbg8818vd_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpbg8818vd_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpbg8818vd_test.go:45: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren_groups = append(paren_groups, \" \" + paren_string)\n    paren\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5n9yg_jl_test.go:41:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string) - i - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var depth int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, depth)\n            depth++\n        } else if paren_string[i] == ')' {\n            depth = paren_stack[len(paren_stack) - 1]\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n            if len(paren_stack) == 0 {\n                result = append(result, paren_count)\n            }\n            paren_count--\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp1m2moubj_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp1m2moubj_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp1m2moubj_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := []string{}\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list = append(paren_list, \" \")\n    paren_list = append(paren_list, paren_string)\n    paren_list =\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmkrp2ao5_test.go:47:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]int, 0)\n    paren_groups = append(paren_groups, 0)\n    for i := 1; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_groups = append(paren_groups, i)\n        } else if paren_string[i] == ')' {\n            paren_groups = append(paren_groups, i)\n        }\n    }\n    return paren_groups\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp75p07_nu_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=14) %!s(int=15) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22) %!s(int=23) %!s(int=24) %!s(int=25) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp75p07_nu_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=20) %!s(int=21) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp75p07_nu_test.go:41: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_list = append(paren_list, 0)\n    for i := 1; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_list) == 0 {\n                fmt.Println(\"Error: paren_list is empty\")\n                return nil\n            }\n            if len(paren_list) == 1 {\n                paren_list = append(paren_list, 0)\n            }\n            if len(paren_list) == 2 {\n                paren_list = append(paren_list, 0)\n            }\n            if len(paren_list) == 3 {\n                paren_list = append(paren_list, 0)\n            }\n            if len(paren_list) > 3 {\n                fmt.Println(\"Error: paren_list is too long\")\n                return nil\n            }\n            if len(paren_list) == 3 {\n                paren_list[2] = i\n            }\n            if len(paren_list) == 2 {\n                paren_list[1] = i\n            }\n            if len(paren_list) == 1 {\n                paren_list[0] = i\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "Error: paren_list is too long\nError: paren_list is too long\nError: paren_list is too long\n--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpnzceyaqc_test.go:66: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpnzceyaqc_test.go:66: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpnzceyaqc_test.go:66: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if paren_string[i] == ' ' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            if len(paren_stack) == len(paren_stack) - 1 {\n                paren_list = append(paren_list, len(paren_stack))\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "Error: Unbalanced parentheses\nError: Unbalanced parentheses\n--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpxpc8yso0_test.go:53: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpxpc8yso0_test.go:53: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpxpc8yso0_test.go:53: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_list) == 0 {\n                fmt.Println(\"Error: No matching opening parenthesis found.\")\n                return nil\n            }\n            paren_list = paren_list[:len(paren_list)-1]\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp99stxjev_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp99stxjev_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp99stxjev_test.go:44: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_string) - i - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpcgwkt21f_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    for len(paren_groups) > 0 {\n        current_group := paren_groups[0]\n        paren_groups = paren_groups[1:]\n        paren_groups = append(paren_groups, current_group)\n        for len(paren_groups) > 0 {\n            current_group = paren_groups[0]\n            paren_groups = paren_groups[1:]\n            if len(current_group) > 0 {\n                if current_group[0] == '(' {\n                    paren_groups = append(paren_groups, current_group)\n                } else {\n                    paren_groups = append(paren_groups, current_group[1:])\n                }\n            }\n        }\n    }\n    result := make([]int, 0)\n    for i := 0; i < len(paren_groups); i++ {\n        if len(paren_groups[i]) > 0 {\n            if paren_groups[i][0] == '(' {\n                result = append(result, len(paren_groups[i]) - 1)\n            } else {\n                result = append(result, len(paren_groups[i]))\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374910,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=5) %!s(int=6) %!s(int=12) %!s(int=13) %!s(int=15) %!s(int=16) %!s(int=26)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=6) %!s(int=7) %!s(int=13) %!s(int=14) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp9vwtr0_t_test.go:44: expected '[%!s(int=4)]', got '[%!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var depth int\n    var paren_count int\n    var paren_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, depth)\n            depth++\n        } else if paren_string[i] == ')' {\n            depth = paren_stack[len(paren_stack) - 1]\n            paren_count--\n            if paren_count == 0 {\n                result = append(result, depth)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpw0y3vkh7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=1) %!s(int=3) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpw0y3vkh7_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpcqskh3jq_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var depth int\n    var paren_count int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            depth++\n            paren_count++\n        } else if paren_string[i] == ')' {\n            depth--\n            if depth == 0 {\n                result = append(result, paren_count)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpvzo0yzj4_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=3) %!s(int=6) %!s(int=7) %!s(int=12)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpvzo0yzj4_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=3) %!s(int=6) %!s(int=10)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpvzo0yzj4_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_string_array := []string{}\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\n    paren_string_array = append(paren_string_array, \" \")\n    paren_string_array = append(paren_string_array, paren_string)\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpghqwkzhx_test.go:40:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    var result []int\n    var depth int\n    var paren_count int\n    var paren_stack []int\n    var paren_stack_top int\n    var paren_stack_top_index int\n    var paren_stack_top_value int\n    var paren_stack_top_value_index int\n    var paren_stack_top_value_value int\n    var paren_stack_top_value_value_index int\n    var paren_stack_top_value_value_value int\n    var paren_stack_top_value_value_value_index int\n    var paren_stack_top_value_value_value_value int\n    var paren_stack_top_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_value int\n    var paren_stack_top_value_value_value_value_value_value_value_value_value_value_index int\n    var paren_stack_top_value_value_value_value_value_value_value\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi69e5jj2_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string) - i - 1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2jsm8qp4_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, i)\n        }\n    }\n    for i := len(paren_list) - 1; i >= 0; i-- {\n        if paren_string[paren_list[i]] == ')' {\n            if i == len(paren_list) - 1 {\n                paren_list = append(paren_list, len(paren_string))\n            } else {\n                paren_list[i] = len(paren_string)\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374881,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmp2z4pmemk_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=14) %!s(int=17) %!s(int=18) %!s(int=19) %!s(int=22) %!s(int=24)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2z4pmemk_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp2z4pmemk_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=7) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    parens := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            parens = append(parens, len(paren_string)-i-1)\n        }\n    }\n    return parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=26) %!s(int=25) %!s(int=23) %!s(int=19) %!s(int=18) %!s(int=17) %!s(int=12) %!s(int=9) %!s(int=8) %!s(int=7) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=22) %!s(int=19) %!s(int=18) %!s(int=14) %!s(int=13) %!s(int=12) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpagr7di7z_test.go:38: expected '[%!s(int=4)]', got '[%!s(int=13) %!s(int=12) %!s(int=10) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_list := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_list = append(paren_list, len(paren_list))\n        } else if paren_string[i] == ')' {\n            paren_list = append(paren_list, len(paren_list) - 1)\n        }\n    }\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=12) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=16) %!s(int=17) %!s(int=19) %!s(int=19) %!s(int=21) %!s(int=21) %!s(int=22)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=13) %!s(int=14) %!s(int=15) %!s(int=15) %!s(int=16) %!s(int=17) %!s(int=18)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpv0mx_c_3_test.go:40: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=5) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=9) %!s(int=10) %!s(int=11) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append(paren_groups, \"\")\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy08wjwow_test.go:51:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n    paren_groups := make([]string, 0)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append(paren_groups, paren_string)\n    paren_groups = append\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5u6pqhep_test.go:45:6: expected '(', found TestParse_Nested_Parens\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}