{
  "name": "HumanEval_79_decimal_to_binary",
  "language": "go_test.go",
  "prompt": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n",
  "tests": "func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal%2, binary)\n        decimal = decimal/2\n    }\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpmxt55xnq_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\", decimal%2, result)\n        decimal = decimal / 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp1y9rz0y3_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1y9rz0y3_test.go:48: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp1y9rz0y3_test.go:48: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp1y9rz0y3_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%s%d\", result, decimal%2)\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpakjwzr2d_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpakjwzr2d_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpakjwzr2d_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpakjwzr2d_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    if decimal == 0 {\n        return \"0\"\n    }\n    if decimal == 1 {\n        return \"1\"\n    }\n    if decimal == 2 {\n        return \"10\"\n    }\n    if decimal == 3 {\n        return \"11\"\n    }\n    if decimal == 4 {\n        return \"100\"\n    }\n    if decimal == 5 {\n        return \"101\"\n    }\n    if decimal == 6 {\n        return \"110\"\n    }\n    if decimal == 7 {\n        return \"111\"\n    }\n    if decimal == 8 {\n        return \"1000\"\n    }\n    if decimal == 9 {\n        return \"1001\"\n    }\n    if decimal == 10 {\n        return \"1010\"\n    }\n    if decimal == 11 {\n        return \"1011\"\n    }\n    if decimal == 12 {\n        return \"1100\"\n    }\n    if decimal == 13 {\n        return \"1101\"\n    }\n    if decimal == 14 {\n        return \"1110\"\n    }\n    if decimal == 15 {\n        return \"1111\"\n    }\n    if decimal == 16 {\n        return \"10000\"\n    }\n    if decimal == 17 {\n        return \"10001\"\n    }\n    if decimal == 18 {\n        return \"10010\"\n    }\n    if decimal == 19 {\n        return \"10011\"\n    }\n    if decimal == 20 {\n        return \"10100\"\n    }\n    if decimal == 21 {\n        return \"10101\"\n    }\n    if decimal == 22 {\n        return \"10110\"\n    }\n    if decimal == 23 {\n        return \"10111\"\n    }\n    if decimal == 24 {\n        return \"11000\"\n    }\n    if decimal == 25 {\n        return \"11001\"\n    }\n    if decimal == 26 {\n        return \"11010\"\n    }\n    if decimal == 27 {\n        return \"11011\"\n    }\n    if decimal == 28 {\n        return \"11100\"\n    }\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp95ulr97x_test.go:110:6: expected '(', found TestDecimal_To_Binary\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    if decimal == 0 {\n        return \"0\"\n    }\n    if decimal == 1 {\n        return \"1\"\n    }\n    if decimal == 2 {\n        return \"10\"\n    }\n    if decimal == 3 {\n        return \"11\"\n    }\n    if decimal == 4 {\n        return \"100\"\n    }\n    if decimal == 5 {\n        return \"101\"\n    }\n    if decimal == 6 {\n        return \"110\"\n    }\n    if decimal == 7 {\n        return \"111\"\n    }\n    if decimal == 8 {\n        return \"1000\"\n    }\n    if decimal == 9 {\n        return \"1001\"\n    }\n    if decimal == 10 {\n        return \"1010\"\n    }\n    if decimal == 11 {\n        return \"1011\"\n    }\n    if decimal == 12 {\n        return \"1100\"\n    }\n    if decimal == 13 {\n        return \"1101\"\n    }\n    if decimal == 14 {\n        return \"1110\"\n    }\n    if decimal == 15 {\n        return \"1111\"\n    }\n    if decimal == 16 {\n        return \"10000\"\n    }\n    if decimal == 17 {\n        return \"10001\"\n    }\n    if decimal == 18 {\n        return \"10010\"\n    }\n    if decimal == 19 {\n        return \"10011\"\n    }\n    if decimal == 20 {\n        return \"10100\"\n    }\n    if decimal == 21 {\n        return \"10101\"\n    }\n    if decimal == 22 {\n        return \"10110\"\n    }\n    if decimal == 23 {\n        return \"10111\"\n    }\n    if decimal == 24 {\n        return \"11000\"\n    }\n    if decimal == 25 {\n        return \"11001\"\n    }\n    if decimal == 26 {\n        return \"11010\"\n    }\n    if decimal == 27 {\n        return \"11011\"\n    }\n    if decimal == 28 {\n        return \"11100\"\n    }\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp95ulr97x_test.go:110:6: expected '(', found TestDecimal_To_Binary\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    if decimal < 0 {\n        binary = \"db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp7mgj2377_test.go:48: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7mgj2377_test.go:48: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp7mgj2377_test.go:48: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp7mgj2377_test.go:48: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzltry6cm_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzltry6cm_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzltry6cm_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzltry6cm_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"%db%d\", decimal, decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp9dhrb7f5_test.go:39: expected 'db0db', got '0b0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9dhrb7f5_test.go:39: expected 'db100000db', got '32b32'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp9dhrb7f5_test.go:39: expected 'db1100111db', got '103b103'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9dhrb7f5_test.go:39: expected 'db1111db', got '15b15'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal == 0 {\n        binary = \"0\"\n    } else {\n        for decimal > 0 {\n            binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n            decimal = decimal/2\n        }\n    }\n    binary = \"db\" + binary\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp2hksc7f1_test.go:49: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp2hksc7f1_test.go:49: expected 'db100000db', got 'db000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp2hksc7f1_test.go:49: expected 'db1100111db', got 'db1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp2hksc7f1_test.go:49: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var decimal_string string\n    var binary_string string\n    var decimal_string_length int\n    var binary_string_length int\n    var decimal_string_index int\n    var binary_string_index int\n    var decimal_string_index_increment int\n    var binary_string_index_increment int\n    var decimal_string_index_decrement int\n    var binary_string_index_decrement int\n    var decimal_string_index_decrement_increment int\n    var binary_string_index_decrement_increment int\n    var decimal_string_index_decrement_decrement int\n    var binary_string_index_decrement_decrement int\n    var decimal_string_index_decrement_decrement_increment int\n    var binary_string_index_decrement_decrement_increment int\n    var decimal_string_index_decrement_decrement_decrement int\n    var binary_string_index_decrement_decrement_decrement int\n    var decimal_string_index_decrement_decrement_decrement_increment int\n    var binary_string_index_decrement_decrement_decrement_increment int\n    var decimal_string_index_decrement_decrement_decrement_decrement int\n    var binary_string_index_decrement_decrement_decrement_decrement int\n    var binary_string_index_decrement_decrement_decrement_decrement_increment int\n    var binary_string_index_decrement_decrement_decrement_decrement_decrement int\n    var binary_string_index_decrement_decrement_decrement_decrement_decrement int\n    var binary_string_index_decrement_decrement_decrement_decrement_decrement int\n    var binary_string_index_decrement_decrement_decrement_decrement_decrement int\n    var binary_string_index_decrement_decrement_dec\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq69w80ar_test.go:47:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    if decimal < 0 {\n        binary = \"db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\", decimal%2, result)\n        decimal = decimal/2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp6t621bsj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6t621bsj_test.go:49: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp6t621bsj_test.go:49: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6t621bsj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary += fmt.Sprintf(\"%d\", decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpjfl_8xxd_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpjfl_8xxd_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpjfl_8xxd_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjfl_8xxd_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    if decimal < 0 {\n        binary = \"db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"db%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp116fc5nu_test.go:45: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp116fc5nu_test.go:45: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp116fc5nu_test.go:45: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp116fc5nu_test.go:45: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\", decimal%2, result)\n        decimal = decimal / 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpgvqu6au5_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpgvqu6au5_test.go:49: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpgvqu6au5_test.go:49: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpgvqu6au5_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpf1rsxrtk_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf1rsxrtk_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpf1rsxrtk_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf1rsxrtk_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"db%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp237c542z_test.go:44: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp237c542z_test.go:44: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp237c542z_test.go:44: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp237c542z_test.go:44: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal == 0 {\n        binary = \"0\"\n    } else {\n        binary = \"\"\n        for decimal > 0 {\n            binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n            decimal = decimal / 2\n        }\n        binary = fmt.Sprintf(\"db%s\", binary)\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpmp_7bc6b_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpmp_7bc6b_test.go:49: expected 'db100000db', got 'db000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpmp_7bc6b_test.go:49: expected 'db1100111db', got 'db1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpmp_7bc6b_test.go:49: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    if decimal < 0 {\n        binary = \"db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpa9ghrolu_test.go:47: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpa9ghrolu_test.go:47: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpa9ghrolu_test.go:47: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpa9ghrolu_test.go:47: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"0\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%s%d\", result, decimal%2)\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnfjc75xr_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnfjc75xr_test.go:49: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnfjc75xr_test.go:49: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnfjc75xr_test.go:49: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var digit int\n    var carry bool\n    for decimal > 0 {\n        digit = decimal % 2\n        binary = fmt.Sprintf(\"%s%d\", binary, digit)\n        decimal = decimal / 2\n    }\n    if carry {\n        binary = fmt.Sprintf(\"%s1\", binary)\n    }\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpm_dbzgin_test.go:49: expected 'db0db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpm_dbzgin_test.go:49: expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpm_dbzgin_test.go:49: expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpk5_fwrsz_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk5_fwrsz_test.go:49: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpk5_fwrsz_test.go:49: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk5_fwrsz_test.go:49: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // your code goes here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp1ph4aqj6_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1ph4aqj6_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp1ph4aqj6_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp1ph4aqj6_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmph6h_r1rq_test.go:48: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmph6h_r1rq_test.go:48: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmph6h_r1rq_test.go:48: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmph6h_r1rq_test.go:48: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%s%d\", result, decimal % 2)\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp35pym__6_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp35pym__6_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp35pym__6_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp35pym__6_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"db%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp237c542z_test.go:44: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp237c542z_test.go:44: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp237c542z_test.go:44: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp237c542z_test.go:44: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // your code goes here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpagqcx65x_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpagqcx65x_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpagqcx65x_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpagqcx65x_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmph6h_r1rq_test.go:48: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmph6h_r1rq_test.go:48: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmph6h_r1rq_test.go:48: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmph6h_r1rq_test.go:48: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal == 0 {\n        binary = \"0\"\n    } else {\n        binary = \"1\"\n        for decimal > 0 {\n            binary = binary + \"0\"\n            decimal = decimal / 2\n        }\n        binary = \"db\" + binary\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp42dpwfle_test.go:50: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp42dpwfle_test.go:50: expected 'db100000db', got 'db1000000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp42dpwfle_test.go:50: expected 'db1100111db', got 'db10000000'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp42dpwfle_test.go:50: expected 'db1111db', got 'db10000'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmps3uhc7fj_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmps3uhc7fj_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmps3uhc7fj_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmps3uhc7fj_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // your code goes here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpld7840dc_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpld7840dc_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpld7840dc_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpld7840dc_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\", decimal%2, result)\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpexrsnv60_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpexrsnv60_test.go:49: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpexrsnv60_test.go:49: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpexrsnv60_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var digit string\n    var count int\n    var remainder int\n    var remainder_digit string\n    var remainder_count int\n    var remainder_remainder int\n    var remainder_remainder_digit string\n    var remainder_remainder_count int\n    var remainder_remainder_remainder int\n    var remainder_remainder_remainder_digit string\n    var remainder_remainder_remainder_count int\n    var remainder_remainder_remainder_remainder int\n    var remainder_remainder_remainder_remainder_digit string\n    var remainder_remainder_remainder_remainder_count int\n    var remainder_remainder_remainder_remainder_remainder int\n    var remainder_remainder_remainder_remainder_remainder_digit string\n    var remainder_remainder_remainder_remainder_remainder_count int\n    var remainder_remainder_remainder_remainder_remainder_remainder int\n    var remainder_remainder_remainder_remainder_remainder_remainder_digit string\n    var remainder_remainder_remainder_remainder_remainder_remainder_count int\n    var remainder_remainder_remainder_remainder_remainder_remainder_remainder int\n    var remainder_remainder_remainder_remainder_remainder_remainder_remainder_digit string\n    var remainder_remainder_remainder_remainder_remainder_remainder_remainder_count int\n    var remainder_remainder_remainder_remainder_remainder_remainder_remainder_remainder int\n    var remainder_remainder_remainder_remainder_remainder_remainder_remainder_remainder_digit string\n    var remainder_remainder_remainder_remainder_remainder_remainder_remainder_remainder_count int\n    var remainder_remainder_rem\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpykyslnsv_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\", decimal%2, result)\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzf2cg8kp_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzf2cg8kp_test.go:48: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzf2cg8kp_test.go:48: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzf2cg8kp_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var temp string\n    var count int\n    for decimal > 0 {\n        temp = fmt.Sprintf(\"%d\", decimal%2)\n        binary = temp + binary\n        decimal = decimal / 2\n    }\n    binary = \"db\" + binary\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvdqtyov6_test.go:21:9: count declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    if decimal < 0 {\n        binary = \"db\"\n        decimal = decimal * -1\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpqyo79b24_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpqyo79b24_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpqyo79b24_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpqyo79b24_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var decimal_string string\n    if decimal < 0 {\n        decimal_string = \"-\"\n        decimal = -decimal\n    } else {\n        decimal_string = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    binary = fmt.Sprintf(\"%s%s\", decimal_string, binary)\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpf203rskf_test.go:51: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpf203rskf_test.go:51: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpf203rskf_test.go:51: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpf203rskf_test.go:51: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpor97tpdz_test.go:48: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpor97tpdz_test.go:48: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpor97tpdz_test.go:48: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpor97tpdz_test.go:48: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%s%d\", result, decimal % 2)\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp35pym__6_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp35pym__6_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp35pym__6_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp35pym__6_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    if decimal < 0 {\n        binary = \"db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        binary = fmt.Sprintf(\"%b\", decimal)\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpk3dszsq7_test.go:45: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk3dszsq7_test.go:45: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpk3dszsq7_test.go:45: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk3dszsq7_test.go:45: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%s%d\", result, decimal%2)\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp8l6ljde3_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8l6ljde3_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp8l6ljde3_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8l6ljde3_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var remainder int\n    for decimal > 0 {\n        remainder = decimal % 2\n        binary = fmt.Sprintf(\"%s%d\", binary, remainder)\n        decimal = decimal / 2\n    }\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpwj_8tqb9_test.go:45: expected 'db0db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpwj_8tqb9_test.go:45: expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpwj_8tqb9_test.go:45: expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp1055rlwg_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var digit int\n    var carry int\n    for decimal > 0 {\n        digit = decimal % 2\n        binary = fmt.Sprintf(\"%d%s\", digit, binary)\n        decimal = decimal / 2\n    }\n    if carry > 0 {\n        binary = fmt.Sprintf(\"%d%s\", carry, binary)\n    }\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmphqcqe1j2_test.go:49: expected 'db0db', got 'dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // your code goes here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpld7840dc_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpld7840dc_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpld7840dc_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpld7840dc_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp_b037npp_test.go:47: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_b037npp_test.go:47: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp_b037npp_test.go:47: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_b037npp_test.go:47: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var binary_length int\n    var decimal_length int\n    var decimal_string string\n    var decimal_string_length int\n    var decimal_string_length_int int\n    var decimal_string_length_int_int int\n    var decimal_string_length_int_int_int int\n    var decimal_string_length_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var decimal_string_length_int_int_int_int_int_\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjxeckfoe_test.go:41:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmplur_gg24_test.go:41: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // your code goes here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp1ph4aqj6_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp1ph4aqj6_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp1ph4aqj6_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp1ph4aqj6_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var digit int\n    var carry bool\n    for decimal > 0 {\n        digit = decimal % 2\n        binary = fmt.Sprintf(\"%s%d\", binary, digit)\n        decimal = decimal / 2\n    }\n    if decimal == 0 {\n        binary = fmt.Sprintf(\"%s0\", binary)\n    }\n    return fmt.Sprintf(\"%s%s\", \"db\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkd0buism_test.go:21:9: carry declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // your code goes here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpi2sfga50_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpi2sfga50_test.go:49: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpi2sfga50_test.go:49: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpi2sfga50_test.go:49: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpjq7h25a0_test.go:49: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    if decimal < 0 {\n        binary = \"db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpctn5xudx_test.go:47: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpctn5xudx_test.go:47: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpctn5xudx_test.go:47: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpctn5xudx_test.go:47: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvlb7dz8m_test.go:44: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    if decimal == 0 {\n        return \"0\"\n    }\n    if decimal == 1 {\n        return \"1\"\n    }\n    if decimal == 2 {\n        return \"10\"\n    }\n    if decimal == 3 {\n        return \"11\"\n    }\n    if decimal == 4 {\n        return \"100\"\n    }\n    if decimal == 5 {\n        return \"101\"\n    }\n    if decimal == 6 {\n        return \"110\"\n    }\n    if decimal == 7 {\n        return \"111\"\n    }\n    if decimal == 8 {\n        return \"1000\"\n    }\n    if decimal == 9 {\n        return \"1001\"\n    }\n    if decimal == 10 {\n        return \"1010\"\n    }\n    if decimal == 11 {\n        return \"1011\"\n    }\n    if decimal == 12 {\n        return \"1100\"\n    }\n    if decimal == 13 {\n        return \"1101\"\n    }\n    if decimal == 14 {\n        return \"1110\"\n    }\n    if decimal == 15 {\n        return \"1111\"\n    }\n    if decimal == 16 {\n        return \"10000\"\n    }\n    if decimal == 17 {\n        return \"10001\"\n    }\n    if decimal == 18 {\n        return \"10010\"\n    }\n    if decimal == 19 {\n        return \"10011\"\n    }\n    if decimal == 20 {\n        return \"10100\"\n    }\n    if decimal == 21 {\n        return \"10101\"\n    }\n    if decimal == 22 {\n        return \"10110\"\n    }\n    if decimal == 23 {\n        return \"10111\"\n    }\n    if decimal == 24 {\n        return \"11000\"\n    }\n    if decimal == 25 {\n        return \"11001\"\n    }\n    if decimal == 26 {\n        return \"11010\"\n    }\n    if decimal == 27 {\n        return \"11011\"\n    }\n    if decimal == 28 {\n        return \"11100\"\n    }\n    if decimal == 29\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpruh70j8m_test.go:110:6: expected '(', found TestDecimal_To_Binary\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp7mgj2377_test.go:48: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7mgj2377_test.go:48: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp7mgj2377_test.go:48: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp7mgj2377_test.go:48: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzltry6cm_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzltry6cm_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzltry6cm_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzltry6cm_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpyjtha4ha_test.go:45: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyjtha4ha_test.go:45: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpyjtha4ha_test.go:45: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyjtha4ha_test.go:45: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        binary = fmt.Sprintf(\"%b\", decimal)\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpk3dszsq7_test.go:45: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk3dszsq7_test.go:45: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpk3dszsq7_test.go:45: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk3dszsq7_test.go:45: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\", decimal%2, result)\n        decimal /= 2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpexrsnv60_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpexrsnv60_test.go:49: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpexrsnv60_test.go:49: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpexrsnv60_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    binary := \"\"\n    if decimal < 0 {\n        binary = \"db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoqxgkk_z_test.go:47: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%011d\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpiai4dj7i_test.go:39: expected 'db0db', got 'db00000000000'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiai4dj7i_test.go:39: expected 'db100000db', got 'db00000000032'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpiai4dj7i_test.go:39: expected 'db1100111db', got 'db00000000103'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiai4dj7i_test.go:39: expected 'db1111db', got 'db00000000015'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    if decimal < 0 {\n        return \"db\" + fmt.Sprintf(\"%b\", decimal)\n    }\n    return fmt.Sprintf(\"db%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmptb0yki0e_test.go:42: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // your code goes here\n    var binary string\n    var decimal_string string\n    \n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    \n    for decimal > 0 {\n        decimal_string = fmt.Sprintf(\"%d\", decimal % 2)\n        binary = binary + decimal_string\n        decimal = decimal / 2\n    }\n    \n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp_6uguew0_test.go:54: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_6uguew0_test.go:54: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp_6uguew0_test.go:54: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_6uguew0_test.go:54: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpoq7wun5z_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var count int\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n        count++\n    }\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpl0k2ajqo_test.go:50:6: expected '(', found TestDecimal_To_Binary\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db1100111db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpxd0928p7_test.go:39: expected 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d\", decimal%2) + binary\n        decimal = decimal/2\n    }\n    return \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpib3tys74_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%0\" + fmt.Sprintf(\"%d\", decimal) + \"db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db0db', got 'db0b'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db100000db', got 'db00000000000000000000000000000032b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1100111db', got 'db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103b'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpzy53f8lr_test.go:39: expected 'db1111db', got 'db000000000000015b'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // your code goes here\n    var binary string\n    if decimal == 0 {\n        binary = \"0\"\n    } else {\n        binary = \"\"\n        for decimal > 0 {\n            binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n            decimal /= 2\n        }\n        binary = fmt.Sprintf(\"db%s\", binary)\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpde74oill_test.go:50: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpde74oill_test.go:50: expected 'db100000db', got 'db000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpde74oill_test.go:50: expected 'db1100111db', got 'db1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpde74oill_test.go:50: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var decimal_string string\n    var decimal_string_length int\n    var binary_string_length int\n    var decimal_string_length_minus_one int\n    var binary_string_length_minus_one int\n    var binary_string_length_minus_two int\n    var binary_string_length_minus_three int\n    var binary_string_length_minus_four int\n    var binary_string_length_minus_five int\n    var binary_string_length_minus_six int\n    var binary_string_length_minus_seven int\n    var binary_string_length_minus_eight int\n    var binary_string_length_minus_nine int\n    var binary_string_length_minus_ten int\n    var binary_string_length_minus_eleven int\n    var binary_string_length_minus_twelve int\n    var binary_string_length_minus_thirteen int\n    var binary_string_length_minus_fourteen int\n    var binary_string_length_minus_fifteen int\n    var binary_string_length_minus_sixteen int\n    var binary_string_length_minus_seventeen int\n    var binary_string_length_minus_eighteen int\n    var binary_string_length_minus_nineteen int\n    var binary_string_length_minus_twenty int\n    var binary_string_length_minus_twenty_one int\n    var binary_string_length_minus_twenty_two int\n    var binary_string_length_minus_twenty_three int\n    var binary_string_length_minus_twenty_four int\n    var binary_string_length_minus_twenty_five int\n    var binary_string_length_minus_twenty_six int\n    var binary_string_length_minus_twenty_seven int\n    var binary_string_length_minus_twenty_eight int\n    var binary_string_length_minus_twenty_nine int\n    var binary_string_length_minus_thirty int\n    var binary_string_length_minus_thirty_one int\n    var binary_string_length_minus_thirty_two int\n    var binary_string_length_\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgl5icq29_test.go:56:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    var count int\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /= 2\n        count++\n    }\n    binary = fmt.Sprintf(\"db%s\", binary)\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp3_i0zts3_test.go:46: expected 'db0db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3_i0zts3_test.go:46: expected 'db100000db', got 'db000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp3_i0zts3_test.go:46: expected 'db1100111db', got 'db1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3_i0zts3_test.go:46: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"0\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db0db', got '0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db100000db', got '0000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db1100111db', got '01110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpmxf5s_kc_test.go:48: expected 'db1111db', got '01111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    return fmt.Sprintf(\"db%011d\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374873,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpiai4dj7i_test.go:39: expected 'db0db', got 'db00000000000'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiai4dj7i_test.go:39: expected 'db100000db', got 'db00000000032'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpiai4dj7i_test.go:39: expected 'db1100111db', got 'db00000000103'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiai4dj7i_test.go:39: expected 'db1111db', got 'db00000000015'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpnlnisfxz_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal = decimal / 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp33vox_8u_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var result string\n    if decimal < 0 {\n        result = \"db\"\n    } else {\n        result = \"\"\n    }\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\", decimal%2, result)\n        decimal = decimal/2\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp6t621bsj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6t621bsj_test.go:49: expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp6t621bsj_test.go:49: expected 'db1100111db', got '1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6t621bsj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var result string\n    if decimal < 0 {\n        result = \"db\" + fmt.Sprintf(\"%b\", decimal)\n    } else {\n        result = fmt.Sprintf(\"db%b\", decimal)\n    }\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374872,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmp237c542z_test.go:44: expected 'db0db', got 'db0'\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp237c542z_test.go:44: expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp237c542z_test.go:44: expected 'db1100111db', got 'db1100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp237c542z_test.go:44: expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmputfsqyav_test.go:48: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n    // Your code here\n    var binary string\n    if decimal < 0 {\n        binary = \"db\"\n    } else {\n        binary = \"\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal = decimal/2\n    }\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db0db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db100000db', got '000001'\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1100111db', got '1110011'\n    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpso0y5apj_test.go:49: expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}