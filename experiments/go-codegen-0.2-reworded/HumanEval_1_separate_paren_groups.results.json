{
  "name": "HumanEval_1_separate_paren_groups",
  "language": "go_test.go",
  "prompt": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n",
  "tests": "func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            continue\n        }\n        if paren_string[i] == ')' {\n            result = append(result, paren_string[i+1:])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, paren_count)\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if len(paren_stack) > 0 {\n                if paren_count == paren_stack[len(paren_stack) - 1] {\n                    paren_stack = paren_stack[:len(paren_stack) - 1]\n                }\n            }\n        }\n    }\n    for _, paren_count := range paren_stack {\n        result = append(result, paren_string[0:paren_count])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(fmt.Sprintf(\"Paren stack is empty at index %d\", i))\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(fmt.Sprintf(\"Paren stack is not empty at the end of string: %s\", paren_stack))\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_top int\n    var open_braces_count_stack_top_top_index int\n    var open_braces_count_stack_top_top_top int\n    var open_braces_count_stack_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_top int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        result = append(result, paren_string[:paren_stack[len(paren_stack)-1]])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            }\n        } else if paren_string[i] == ' ' {\n            // ignore spaces\n        } else {\n            paren_stack[len(paren_stack)-1] += string(paren_string[i])\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if len(paren_stack[i]) > 0 {\n            paren_list = append(paren_list, paren_stack[i])\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                result = append(result, string(c))\n            } else {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            result = append(result, paren_string[paren_stack[len(paren_stack)-1]:i])\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i:i+1])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, p := range paren_string {\n        if p == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if p == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(p)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []rune{}\n    result := []string{}\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, c)\n        } else if c == ')' {\n            if len(paren_stack) > 0 {\n                result = append(result, string(paren_stack))\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            }\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, paren_string[i:i+1])\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                panic(\"Invalid input string\")\n            }\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return []string{}\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(c)\n        }\n    }\n    for _, s := range paren_stack {\n        if len(s) > 0 {\n            paren_list = append(paren_list, s)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return []string{}\n            }\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        paren_list = append(paren_list, paren_stack[i])\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    open_parens := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n            if open_parens == 1 {\n                paren_stack = append(paren_stack, i)\n            }\n        } else if paren_string[i] == ')' {\n            open_parens--\n            if open_parens == 0 {\n                paren_list = append(paren_list, paren_string[paren_stack[len(paren_stack) - 1]:i])\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = append(paren_stack, -1)\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i:len(paren_string)-(len(paren_stack)-i)])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                paren_list = append(paren_list, \"\")\n            }\n        } else {\n            paren_stack[len(paren_stack)-1] += string(paren_string[i])\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []rune{}\n    result := []string{}\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, c)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        result = append(result, string(paren_stack))\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if paren == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(paren)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if c == ' ' {\n            continue\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        } else {\n            paren_stack[len(paren_stack)-1]++\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(fmt.Sprintf(\"Paren stack is empty at index %d\", i))\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(fmt.Sprintf(\"Paren stack is not empty at the end of the string: %v\", paren_stack))\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        paren_list = append(paren_list, paren_str)\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(c)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, string(char))\n        } else {\n            paren_stack[len(paren_stack)-1]++\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_groups := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack_index++\n            if paren_stack_index == 1 {\n                paren_groups = append(paren_groups, \"\")\n            }\n        } else if paren_string[i] == ')' {\n            paren_stack_index--\n            if paren_stack_index == 0 {\n                paren_groups = append(paren_groups, paren_stack[0])\n                paren_stack = paren_stack[1:]\n            }\n        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    open_parens := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n        } else if paren_string[i] == ')' {\n            open_parens--\n        }\n        if open_parens == 0 {\n            paren_list = append(paren_list, paren_string[0:i])\n            paren_string = paren_string[i+1:]\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_groups := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, group := range paren_stack {\n        if len(group) > 0 {\n            paren_groups = append(paren_groups, group)\n        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if paren_count < 0 {\n                panic(\"Invalid paren string\")\n            }\n            if paren_count == 0 {\n                paren_count = paren_stack[len(paren_stack) - 1]\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n                paren_list = append(paren_list, paren_string[:i])\n                i = len(paren_string)\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_parens_count int\n    var open_braces_stack []string\n    var open_parens_stack []string\n    var open_braces_stack_count int\n    var open_parens_stack_count int\n    var open_braces_stack_index int\n    var open_parens_stack_index int\n    var open_braces_stack_index_count int\n    var open_parens_stack_index_count int\n    var open_braces_stack_index_count_2 int\n    var open_parens_stack_index_count_2 int\n    var open_braces_stack_index_count_3 int\n    var open_parens_stack_index_count_3 int\n    var open_braces_stack_index_count_4 int\n    var open_parens_stack_index_count_4 int\n    var open_braces_stack_index_count_5 int\n    var open_parens_stack_index_count_5 int\n    var open_braces_stack_index_count_6 int\n    var open_parens_stack_index_count_6 int\n    var open_braces_stack_index_count_7 int\n    var open_parens_stack_index_count_7 int\n    var open_braces_stack_index_count_8 int\n    var open_parens_stack_index_count_8 int\n    var open_braces_stack_index_count_9 int\n    var open_parens_stack_index_count_9 int\n    var open_braces_stack_index_count_10 int\n    var open_parens_stack_index_count_10 int\n    var open_braces_stack_index_count_11 int\n    var open_parens_stack_index_count_11 int\n    var open_braces_stack_index_count_12 int\n    var open_parens_stack_index_count_12 int\n    var open_braces_stack_index_count\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, paren_count)\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if len(paren_stack) > 0 {\n                if paren_count == paren_stack[len(paren_stack) - 1] {\n                    paren_stack = paren_stack[:len(paren_stack) - 1]\n                }\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if len(paren_stack) > 0 {\n            if paren_stack[i] == 0 {\n                paren_list = append(paren_list, paren_string[i:])\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parens\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string);\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        } else {\n            if len(paren_stack) > 0 {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] > 0 {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        result = append(result, paren_string[paren_stack[len(paren_stack)-1]:])\n        if len(paren_stack) > 0 {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if len(paren_stack) > 0 {\n            if paren_stack[len(paren_stack)-1] == 0 {\n                result = append(result, \"\")\n            }\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    paren_stack_count := 0\n    paren_stack_string := \"\"\n    paren_string_index := 0\n    paren_string_count := 0\n    paren_string_string := \"\"\n    paren_string_list := make([]string, 0)\n    for paren_string_index < len(paren_string) {\n        if paren_string[paren_string_index] == '(' {\n            paren_stack_count += 1\n            paren_stack_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_string[paren_string_index] == ')' {\n            paren_stack_count -= 1\n            paren_stack_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_stack_count == 0 {\n            paren_string_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_stack_count > 0 {\n            paren_stack_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_string_count == 0 {\n            paren_string_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_string_count > 0 {\n            paren_string_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_string_count == 0 {\n            paren_string_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        }\n        result = append(result, paren_string[i:i+paren_stack[i]+1])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        result = append(result, paren_string[paren_stack[len(paren_stack)-1]:])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_stack = append(paren_stack, paren_string[:i])\n            paren_string = paren_string[i+1:]\n            i = -1\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, paren_string[i:i+1])\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, paren_count)\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if paren_count < 0 {\n                panic(\"Invalid parentheses\")\n            }\n            if len(paren_stack) > 0 {\n                if paren_stack[len(paren_stack) - 1] == paren_count {\n                    result = append(result, paren_string[i:i+1])\n                    paren_stack = paren_stack[:len(paren_stack) - 1]\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[paren_stack[i]:])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_top int\n    var open_braces_count_stack_top_top_index int\n    var open_braces_count_stack_top_top_top int\n    var open_braces_count_stack_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_top int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                panic(\"unbalanced parentheses\")\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) != 0 {\n        panic(\"unbalanced parentheses\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    var cur_string string\n    var open_braces int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_braces++\n        } else if paren_string[i] == ')' {\n            open_braces--\n        } else if paren_string[i] == ' ' {\n            if open_braces == 0 {\n                cur_string += paren_string[i]\n            }\n        } else {\n            if open_braces == 0 {\n                cur_string += paren_string[i]\n            }\n        }\n        if open_braces == 0 {\n            paren_list = append(paren_list, cur_string)\n            cur_string = \"\"\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(paren_string[:len(paren_stack)])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    open_parens := 0\n    open_braces := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n        } else if paren_string[i] == '{' {\n            open_braces++\n        } else if paren_string[i] == ')' {\n            open_parens--\n        } else if paren_string[i] == '}' {\n            open_braces--\n        }\n        if open_parens == 0 && open_braces == 0 {\n            paren_list = append(paren_list, paren_string[:i])\n            paren_string = paren_string[i:]\n            i = 0\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result = append(result, paren_string[:paren_stack[len(paren_stack)-1]])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        } else {\n            if len(paren_stack) > 0 {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    for _, paren_count := range paren_stack {\n        if paren_count > 0 {\n            result = append(result, fmt.Sprintf(\"(%d)\", paren_count))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var current_string string\n    var open_parens int\n    var open_braces int\n    var open_braces_stack []int\n    var open_parens_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n            open_braces_stack = append(open_braces_stack, open_braces)\n            open_parens_stack = append(open_parens_stack, open_parens)\n            if open_braces > 0 {\n                current_string += string(paren_string[i])\n            }\n        } else if paren_string[i] == ')' {\n            open_braces--\n            open_parens--\n            if open_braces == 0 {\n                open_braces_stack = pop(open_braces_stack)\n                open_parens_stack = pop(open_parens_stack)\n                if open_braces_stack[len(open_braces_stack) - 1] > 0 {\n                    current_string += string(paren_string[i])\n                }\n            } else {\n                current_string += string(paren_string[i])\n            }\n        } else {\n            current_string += string(paren_string[i])\n        }\n    }\n    result = append(result, current_string)\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    open_parens := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n        } else if paren_string[i] == ')' {\n            open_parens--\n        }\n        if open_parens == 0 {\n            paren_list = append(paren_list, paren_string[0:i])\n            paren_string = paren_string[i+1:]\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    paren_stack_count := 0\n    paren_stack_count_max := 0\n    paren_stack_count_min := 0\n    paren_stack_count_max_index := 0\n    paren_stack_count_min_index := 0\n    paren_stack_count_max_index_prev := 0\n    paren_stack_count_min_index_prev := 0\n    paren_stack_count_max_index_next := 0\n    paren_stack_count_min_index_next := 0\n    paren_stack_count_max_index_next_prev := 0\n    paren_stack_count_min_index_next_prev := 0\n    paren_stack_count_max_index_next_next := 0\n    paren_stack_count_min_index_next_next := 0\n    paren_stack_count_max_index_next_next_prev := 0\n    paren_stack_count_min_index_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next := 0\n    paren_stack_count_min_index_next_next_next := 0\n    paren_stack_count_max_index_next_next_next_prev := 0\n    paren_stack_count_min_index_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_value int\n    var open_braces_count_stack_top_value_index int\n    var open_braces_count_stack_top_value_value int\n    var open_braces_count_stack_top_value_value_index int\n    var open_braces_count_stack_top_value_value_value int\n    var open_braces_count_stack_top_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value_value int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Mismatched parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Mismatched parentheses\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 1 {\n            result = append(result, \"()\")\n        } else {\n            result = append(result, \"()()\")\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_index_end int\n    var open_braces_count_stack_top_index_end_end int\n    var open_braces_count_stack_top_index_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 1 {\n            result = append(result, \"()\")\n        } else {\n            result = append(result, \"()()\")\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_value int\n    var open_braces_count_stack_top_value_index int\n    var open_braces_count_stack_top_value_value int\n    var open_braces_count_stack_top_value_value_index int\n    var open_braces_count_stack_top_value_value_value int\n    var open_braces_count_stack_top_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value_value int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Mismatched parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(paren_string[:len(paren_stack)])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                panic(\"Invalid string\")\n            }\n        }\n    }\n    for _, paren_count := range paren_stack {\n        if paren_count == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[:paren_count]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) > 0 {\n                result = append(result, stack[len(stack)-1])\n                stack = stack[:len(stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if paren_count < 0 {\n                panic(\"Unbalanced parens\")\n            }\n            if paren_count == 0 {\n                paren_count = paren_stack[len(paren_stack) - 1]\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n                if len(paren_stack) == 0 {\n                    paren_list = append(paren_list, paren_string[:i])\n                    paren_string = paren_string[i + 1:]\n                    break\n                }\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        } else {\n            if len(paren_stack) > 0 {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] > 0 {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    var current_string string\n    var open_braces int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_braces++\n        } else if paren_string[i] == ')' {\n            open_braces--\n        } else if paren_string[i] == ' ' {\n            if open_braces == 0 {\n                current_string += paren_string[i]\n            }\n        } else {\n            if open_braces == 0 {\n                current_string += paren_string[i]\n            }\n        }\n        if open_braces == 0 {\n            paren_list = append(paren_list, current_string)\n            current_string = \"\"\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_stack []string\n    var open_braces_stack_count int\n    var open_braces_stack_top int\n    var open_braces_stack_top_count int\n    var open_braces_stack_top_count_2 int\n    var open_braces_stack_top_count_3 int\n    var open_braces_stack_top_count_4 int\n    var open_braces_stack_top_count_5 int\n    var open_braces_stack_top_count_6 int\n    var open_braces_stack_top_count_7 int\n    var open_braces_stack_top_count_8 int\n    var open_braces_stack_top_count_9 int\n    var open_braces_stack_top_count_10 int\n    var open_braces_stack_top_count_11 int\n    var open_braces_stack_top_count_12 int\n    var open_braces_stack_top_count_13 int\n    var open_braces_stack_top_count_14 int\n    var open_braces_stack_top_count_15 int\n    var open_braces_stack_top_count_16 int\n    var open_braces_stack_top_count_17 int\n    var open_braces_stack_top_count_18 int\n    var open_braces_stack_top_count_19 int\n    var open_braces_stack_top_count_20 int\n    var open_braces_stack_top_count_21 int\n    var open_braces_stack_top_count_22 int\n    var open_braces_stack_top_count_23 int\n    var open_braces_stack_top_count_24 int\n    var open_braces_stack_top_count_25 int\n    var open_braces_stack_top_count_26 int\n    var open_braces_stack_top_count_27 int\n    var open_braces_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []rune{}\n    result := []string{}\n    for _, r := range paren_string {\n        if r == '(' {\n            paren_stack = append(paren_stack, r)\n        } else if r == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(r))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_top int\n    var open_braces_count_stack_top_top_index int\n    var open_braces_count_stack_top_top_top int\n    var open_braces_count_stack_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_top int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_stack_count := 0\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack_count++\n            paren_stack = append(paren_stack, paren_stack_count)\n        } else if paren_string[i] == ')' {\n            paren_stack_count--\n            if paren_stack_count < 0 {\n                panic(\"Invalid input\")\n            }\n            if paren_stack_count == 0 {\n                result = append(result, paren_string[paren_stack[len(paren_stack) - 1] : i])\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n            }\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Invalid input\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_stack = append(paren_stack, paren_string[:i])\n            paren_string = paren_string[i+1:]\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, string(char))\n        } else {\n            paren_stack[len(paren_stack)-1]++\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                fmt.Println(\"Error: stack is empty\")\n                return nil\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        fmt.Println(\"Error: stack is not empty\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parenthesis\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Unbalanced parenthesis\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parenthesis\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Unbalanced parenthesis\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parenthesis\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Unbalanced parenthesis\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid string\")\n            }\n            paren_stack = paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    paren_stack_count := 0\n    paren_stack_count_max := 0\n    paren_stack_count_min := 0\n    paren_stack_count_max_index := 0\n    paren_stack_count_min_index := 0\n    paren_stack_count_max_index_prev := 0\n    paren_stack_count_min_index_prev := 0\n    paren_stack_count_max_index_next := 0\n    paren_stack_count_min_index_next := 0\n    paren_stack_count_max_index_next_prev := 0\n    paren_stack_count_min_index_next_prev := 0\n    paren_stack_count_max_index_next_next := 0\n    paren_stack_count_min_index_next_next := 0\n    paren_stack_count_max_index_next_next_prev := 0\n    paren_stack_count_min_index_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next := 0\n    paren_stack_count_min_index_next_next_next := 0\n    paren_stack_count_max_index_next_next_next_prev := 0\n    paren_stack_count_min_index_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next_next_next := 0\n    paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(paren_string[:len(paren_stack)])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[paren_stack[i]:paren_stack[i]+1])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_group := range paren_stack {\n        paren_list = append(paren_list, paren_group)\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    paren_stack_top := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack_index++\n            paren_stack_top = paren_stack_index\n        } else if paren_string[i] == ')' {\n            paren_stack_index--\n            if paren_stack_index < 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            if paren_stack_index == paren_stack_top {\n                paren_stack_top = 0\n                paren_stack = make([]int, 0)\n            }\n        }\n        if paren_stack_index == 0 {\n            if paren_string[i] != ' ' {\n                paren_list = append(paren_list, paren_string[i:i+1])\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_group := range paren_stack {\n        paren_list = append(paren_list, paren_group)\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i*2:i*2+2])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_stack = append(paren_stack, paren_string[0:i])\n            paren_string = paren_string[i+1:]\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        } else if c == ' ' {\n            continue\n        } else {\n            paren_stack = append(paren_stack, paren_stack[len(paren_stack) - 1] + 1)\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 1 {\n            result = append(result, \"\")\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := 0; j < len(result[i]); j++ {\n            if result[i][j] == '(' {\n                result[i] = result[i][:j] + \"(\" + result[i][j+1:]\n            }\n            if result[i][j] == ')' {\n                result[i] = result[i][:j] + \")\" + result[i][j+1:]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, paren_count)\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if paren_count < 0 {\n                panic(\"Invalid parentheses\")\n            }\n            if len(paren_stack) > 0 {\n                if paren_stack[len(paren_stack) - 1] == paren_count {\n                    paren_stack = paren_stack[:len(paren_stack) - 1]\n                } else {\n                    panic(\"Invalid parentheses\")\n                }\n            }\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Invalid parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] != ' ' {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Mismatched parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(c)\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Mismatched parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Mismatched parentheses\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i:i+1])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] != ' ' {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(paren_string[0:len(paren_stack)])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) ==\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_top int\n    var open_braces_count_stack_top_top_index int\n    var open_braces_count_stack_top_top_top int\n    var open_braces_count_stack_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_top int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n\n    for len(paren_stack) > 0 {\n        result = append(result, paren_string[0:paren_stack[len(paren_stack)-1]])\n        paren_string = paren_string[paren_stack[len(paren_stack)-1]:]\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                result = append(result, string(c))\n            } else {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Paren stack is empty\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                paren_list = append(paren_list, string(paren_string[i]))\n            } else {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_stack []string\n    var open_braces_stack_count int\n    var open_braces_stack_top int\n    var open_braces_stack_top_count int\n    var open_braces_stack_top_count_2 int\n    var open_braces_stack_top_count_3 int\n    var open_braces_stack_top_count_4 int\n    var open_braces_stack_top_count_5 int\n    var open_braces_stack_top_count_6 int\n    var open_braces_stack_top_count_7 int\n    var open_braces_stack_top_count_8 int\n    var open_braces_stack_top_count_9 int\n    var open_braces_stack_top_count_10 int\n    var open_braces_stack_top_count_11 int\n    var open_braces_stack_top_count_12 int\n    var open_braces_stack_top_count_13 int\n    var open_braces_stack_top_count_14 int\n    var open_braces_stack_top_count_15 int\n    var open_braces_stack_top_count_16 int\n    var open_braces_stack_top_count_17 int\n    var open_braces_stack_top_count_18 int\n    var open_braces_stack_top_count_19 int\n    var open_braces_stack_top_count_20 int\n    var open_braces_stack_top_count_21 int\n    var open_braces_stack_top_count_22 int\n    var open_braces_stack_top_count_23 int\n    var open_braces_stack_top_count_24 int\n    var open_braces_stack_top_count_25 int\n    var open_braces_stack_top_count_26 int\n    var open_braces_stack_top_count_27 int\n    var open_braces_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292874,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for _, paren_count := range paren_stack {\n        if paren_count > 0 {\n            result = append(result, string(paren_string[:paren_count]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292859,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i:len(paren_string)-paren_stack[i]])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292904,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_group := range paren_stack {\n        paren_list = append(paren_list, paren_group)\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292889,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                return []string{}\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(c)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292904,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292904,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_groups := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_groups = append(paren_groups, \"\")\n        } else if paren_string[i] == ')' {\n            paren_groups = append(paren_groups, \"\")\n        } else if paren_string[i] == ' ' {\n            continue\n        } else {\n            paren_groups[len(paren_groups)-1] += string(paren_string[i])\n        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292904,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    }
  ]
}