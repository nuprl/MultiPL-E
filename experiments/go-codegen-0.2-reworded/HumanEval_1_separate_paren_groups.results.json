{
  "name": "HumanEval_1_separate_paren_groups",
  "language": "go_test.go",
  "prompt": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n",
  "tests": "func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpptvpv_kn_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpptvpv_kn_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpptvpv_kn_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpptvpv_kn_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            continue\n        }\n        if paren_string[i] == ')' {\n            result = append(result, paren_string[i+1:])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpp0rmvib1_test.go:57: expected '[(()()) ((())) () ((())()())]', got '[()) ((())) () ((())()()) ) ((())) () ((())()())  ((())) () ((())()()) )) () ((())()()) ) () ((())()())  () ((())()())  ((())()()) )()()) ()()) ()) ) ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpp0rmvib1_test.go:57: expected '[() (()) ((())) (((())))]', got '[ (()) ((())) (((()))) ) ((())) (((())))  ((())) (((()))) )) (((()))) ) (((())))  (((()))) ))) )) ) ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpp0rmvib1_test.go:57: expected '[(()(())((())))]', got '[(())((()))) )((()))) ((()))) ))) )) ) ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpp0rmvib1_test.go:57: expected '[() (()) (()())]', got '[ (( )) (( )( )) ) (( )( ))  (( )( )) ( )) ) ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpblxuppmr_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpblxuppmr_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpblxuppmr_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpblxuppmr_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.020s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpahejd4vu_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpahejd4vu_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpahejd4vu_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpahejd4vu_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmptzk6ixdx_test.go:51: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmptzk6ixdx_test.go:51: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptzk6ixdx_test.go:51: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmptzk6ixdx_test.go:51: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, paren_count)\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if len(paren_stack) > 0 {\n                if paren_count == paren_stack[len(paren_stack) - 1] {\n                    paren_stack = paren_stack[:len(paren_stack) - 1]\n                }\n            }\n        }\n    }\n    for _, paren_count := range paren_stack {\n        result = append(result, paren_string[0:paren_count])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp2kgrxkkh_test.go:53: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp2kgrxkkh_test.go:53: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp2kgrxkkh_test.go:53: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp2kgrxkkh_test.go:53: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(fmt.Sprintf(\"Paren stack is empty at index %d\", i))\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(fmt.Sprintf(\"Paren stack is not empty at the end of string: %s\", paren_stack))\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test\n/tmp/tmprxzwrzww_test.go:28:15: Sprintf format %s has arg paren_stack of wrong type []int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpahejd4vu_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpahejd4vu_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpahejd4vu_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpahejd4vu_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_top int\n    var open_braces_count_stack_top_top_index int\n    var open_braces_count_stack_top_top_top int\n    var open_braces_count_stack_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_top int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprxall647_test.go:41:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa7vc5d0m_test.go:64:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        result = append(result, paren_string[:paren_stack[len(paren_stack)-1]])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmppq4yuto5_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmppq4yuto5_test.go:50: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmppq4yuto5_test.go:50: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmppq4yuto5_test.go:50: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpbf5sltx0_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpbf5sltx0_test.go:58: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpbf5sltx0_test.go:58: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpbf5sltx0_test.go:58: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            }\n        } else if paren_string[i] == ' ' {\n            // ignore spaces\n        } else {\n            paren_stack[len(paren_stack)-1] += string(paren_string[i])\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if len(paren_stack[i]) > 0 {\n            paren_list = append(paren_list, paren_stack[i])\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpe9ixqf_h_test.go:54: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpe9ixqf_h_test.go:54: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpe9ixqf_h_test.go:54: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpe9ixqf_h_test.go:54: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                result = append(result, string(c))\n            } else {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp4t0mldw3_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[     ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp4t0mldw3_test.go:49: expected '[() (()) ((())) (((())))]', got '[     ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp4t0mldw3_test.go:49: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp4t0mldw3_test.go:49: expected '[() (()) (()())]', got '[   ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, i)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            result = append(result, paren_string[paren_stack[len(paren_stack)-1]:i])\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp81obm00v_test.go:52: expected '[(()()) ((())) () ((())()())]', got '[( ( (()() ( (() ((()) ( ( (() ( ( ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp81obm00v_test.go:52: expected '[() (()) ((())) (((())))]', got '[( ( (() ( (() ((()) ( (() ((()) (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp81obm00v_test.go:52: expected '[(()(())((())))]', got '[( ( (() ( (() ((()) (()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp81obm00v_test.go:52: expected '[() (()) (()())]', got '[(  (  (( ) (  (  (( )( )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i:i+1])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpedpxa1h5_test.go:52: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpedpxa1h5_test.go:52: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpedpxa1h5_test.go:52: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpedpxa1h5_test.go:52: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, p := range paren_string {\n        if p == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if p == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(p)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpy4gmlffq_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmpy4gmlffq_test.go:35 +0x56\ntesting.tRunner(0xc000102600, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []rune{}\n    result := []string{}\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, c)\n        } else if c == ')' {\n            if len(paren_stack) > 0 {\n                result = append(result, string(paren_stack))\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpdemxdupp_test.go:48: expected '[(()()) ((())) () ((())()())]', got '[(( (( ( ((( (( ( ( ((( (( (( (( (]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpdemxdupp_test.go:48: expected '[() (()) ((())) (((())))]', got '[( (( ( ((( (( ( (((( ((( (( (]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpdemxdupp_test.go:48: expected '[(()(())((())))]', got '[(( ((( (( (((( ((( (( (]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpdemxdupp_test.go:48: expected '[() (()) (()())]', got '[( (( ( (( (( (]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            }\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmp123wcb8v_test.go:25 +0x3aa\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmp123wcb8v_test.go:43 +0x56\ntesting.tRunner(0xc000001380, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, paren_string[i:i+1])\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpidbqcg3j_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpidbqcg3j_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpidbqcg3j_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpidbqcg3j_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp00dz5en0_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp00dz5en0_test.go:58: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp00dz5en0_test.go:58: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp00dz5en0_test.go:58: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                panic(\"Invalid input string\")\n            }\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fac, 0x1b, 0x5fa280, 0x582583, 0xf)\n\t/tmp/tmpjtrqw7yg_test.go:27 +0x3da\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmpjtrqw7yg_test.go:45 +0x56\ntesting.tRunner(0xc000102600, 0x54f298)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return []string{}\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(c)\n        }\n    }\n    for _, s := range paren_stack {\n        if len(s) > 0 {\n            paren_list = append(paren_list, s)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa320, 0x5825c3, 0xf)\n\t/tmp/tmpxx9tfh_q_test.go:27 +0x43c\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpxx9tfh_q_test.go:45 +0x56\ntesting.tRunner(0xc000001380, 0x54f2a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return []string{}\n            }\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        paren_list = append(paren_list, paren_stack[i])\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa320, 0x5825c3, 0xf)\n\t/tmp/tmpqu7ls0sj_test.go:28 +0x413\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpqu7ls0sj_test.go:44 +0x56\ntesting.tRunner(0xc000186300, 0x54f2a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    open_parens := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n            if open_parens == 1 {\n                paren_stack = append(paren_stack, i)\n            }\n        } else if paren_string[i] == ')' {\n            open_parens--\n            if open_parens == 0 {\n                paren_list = append(paren_list, paren_string[paren_stack[len(paren_stack) - 1]:i])\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374814,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpbmzozcvx_test.go:51: expected '[(()()) ((())) () ((())()())]', got '[(()() ((()) ( ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpbmzozcvx_test.go:51: expected '[() (()) ((())) (((())))]', got '[( (() ((()) (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpbmzozcvx_test.go:51: expected '[(()(())((())))]', got '[(()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpbmzozcvx_test.go:51: expected '[() (()) (()())]', got '[(  (( ) (( )( )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = append(paren_stack, -1)\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp616wcium_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp616wcium_test.go:46: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp616wcium_test.go:46: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp616wcium_test.go:46: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp3qx_r190_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp3qx_r190_test.go:60: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp3qx_r190_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp3qx_r190_test.go:60: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpd_nok_d4_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpd_nok_d4_test.go:35 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmps5h5s4w6_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmps5h5s4w6_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmps5h5s4w6_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmps5h5s4w6_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpn0sifs8n_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                          ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpn0sifs8n_test.go:60: expected '[() (()) ((())) (((())))]', got '[                      ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpn0sifs8n_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpn0sifs8n_test.go:60: expected '[() (()) (()())]', got '[                 ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i:len(paren_string)-(len(paren_stack)-i)])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmprcbvza4a_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmprcbvza4a_test.go:50: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprcbvza4a_test.go:50: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmprcbvza4a_test.go:50: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                paren_list = append(paren_list, \"\")\n            }\n        } else {\n            paren_stack[len(paren_stack)-1] += string(paren_string[i])\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc00015e000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102900)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc00015e000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(...)\n\t/tmp/tmp_lk5yms0_test.go:27\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102900)\n\t/tmp/tmp_lk5yms0_test.go:40 +0x10c6\ntesting.tRunner(0xc000102900, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpitewihl9_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpitewihl9_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpitewihl9_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpitewihl9_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa360, 0x5825e3, 0xf)\n\t/tmp/tmpo3exc4qo_test.go:28 +0x4e5\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpo3exc4qo_test.go:45 +0x56\ntesting.tRunner(0xc000001380, 0x54f2a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpl2ra3t3y_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpl2ra3t3y_test.go:58: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpl2ra3t3y_test.go:58: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpl2ra3t3y_test.go:58: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []rune{}\n    result := []string{}\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, c)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        result = append(result, string(paren_stack))\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpd42xx642_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpd42xx642_test.go:50: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpd42xx642_test.go:50: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpd42xx642_test.go:50: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmpgcezc0ac_test.go:23 +0x3aa\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpgcezc0ac_test.go:41 +0x56\ntesting.tRunner(0xc000001380, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if paren == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(paren)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fa9, 0x1b, 0x5fa220, 0x582543, 0xf)\n\t/tmp/tmpk8h0uqvm_test.go:25 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpk8h0uqvm_test.go:38 +0x56\ntesting.tRunner(0xc000001380, 0x54f290)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if c == ' ' {\n            continue\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        } else {\n            paren_stack[len(paren_stack)-1]++\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp54y26n3x_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp54y26n3x_test.go:50: expected '[() (()) ((())) (((())))]', got '[) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp54y26n3x_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp54y26n3x_test.go:50: expected '[() (()) (()())]', got '[) ) )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0f5v3cf0_test.go:62:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(fmt.Sprintf(\"Paren stack is empty at index %d\", i))\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(fmt.Sprintf(\"Paren stack is not empty at the end of the string: %v\", paren_stack))\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpp3nn2jn7_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                          ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpp3nn2jn7_test.go:58: expected '[() (()) ((())) (((())))]', got '[                      ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpp3nn2jn7_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpp3nn2jn7_test.go:58: expected '[() (()) (()())]', got '[                 ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0f5v3cf0_test.go:62:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvat1zad5_test.go:64:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        paren_list = append(paren_list, paren_str)\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmpssmk5rlf_test.go:23 +0x39b\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpssmk5rlf_test.go:39 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(c)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpc4qcf23x_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmpc4qcf23x_test.go:35 +0x56\ntesting.tRunner(0xc000102600, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, string(char))\n        } else {\n            paren_stack[len(paren_stack)-1]++\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa220, 0x582543, 0xf)\n\t/tmp/tmpw_z9pkce_test.go:22 +0x2f8\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpw_z9pkce_test.go:38 +0x56\ntesting.tRunner(0xc000001380, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_groups := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack_index++\n            if paren_stack_index == 1 {\n                paren_groups = append(paren_groups, \"\")\n            }\n        } else if paren_string[i] == ')' {\n            paren_stack_index--\n            if paren_stack_index == 0 {\n                paren_groups = append(paren_groups, paren_stack[0])\n                paren_stack = paren_stack[1:]\n            }\n        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcu62gk3f_test.go:27:38: cannot use paren_stack[0] (type int) as type string in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    open_parens := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n        } else if paren_string[i] == ')' {\n            open_parens--\n        }\n        if open_parens == 0 {\n            paren_list = append(paren_list, paren_string[0:i])\n            paren_string = paren_string[i+1:]\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpxv53992o_test.go:47: expected '[(()()) ((())) () ((())()())]', got '[(()()  ((()))  ) ((())()(]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpxv53992o_test.go:47: expected '[() (()) ((())) (((())))]', got '[(  (( ) ((( )) ((((]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpxv53992o_test.go:47: expected '[(()(())((())))]', got '[(()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpxv53992o_test.go:47: expected '[() (()) (()())]', got '[(   (( )) (( ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_groups := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, group := range paren_stack {\n        if len(group) > 0 {\n            paren_groups = append(paren_groups, group)\n        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmpe5tf2pnr_test.go:23 +0x3aa\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpe5tf2pnr_test.go:41 +0x56\ntesting.tRunner(0xc000001380, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpba8ds7uf_test.go:56: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpba8ds7uf_test.go:56: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpba8ds7uf_test.go:56: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpba8ds7uf_test.go:56: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if paren_count < 0 {\n                panic(\"Invalid paren string\")\n            }\n            if paren_count == 0 {\n                paren_count = paren_stack[len(paren_stack) - 1]\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n                paren_list = append(paren_list, paren_string[:i])\n                i = len(paren_string)\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpt01inz31_test.go:54: expected '[(()()) ((())) () ((())()())]', got '[(()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpt01inz31_test.go:54: expected '[() (()) ((())) (((())))]', got '[(]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpt01inz31_test.go:54: expected '[(()(())((())))]', got '[(()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpt01inz31_test.go:54: expected '[() (()) (()())]', got '[( ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.016s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_parens_count int\n    var open_braces_stack []string\n    var open_parens_stack []string\n    var open_braces_stack_count int\n    var open_parens_stack_count int\n    var open_braces_stack_index int\n    var open_parens_stack_index int\n    var open_braces_stack_index_count int\n    var open_parens_stack_index_count int\n    var open_braces_stack_index_count_2 int\n    var open_parens_stack_index_count_2 int\n    var open_braces_stack_index_count_3 int\n    var open_parens_stack_index_count_3 int\n    var open_braces_stack_index_count_4 int\n    var open_parens_stack_index_count_4 int\n    var open_braces_stack_index_count_5 int\n    var open_parens_stack_index_count_5 int\n    var open_braces_stack_index_count_6 int\n    var open_parens_stack_index_count_6 int\n    var open_braces_stack_index_count_7 int\n    var open_parens_stack_index_count_7 int\n    var open_braces_stack_index_count_8 int\n    var open_parens_stack_index_count_8 int\n    var open_braces_stack_index_count_9 int\n    var open_parens_stack_index_count_9 int\n    var open_braces_stack_index_count_10 int\n    var open_parens_stack_index_count_10 int\n    var open_braces_stack_index_count_11 int\n    var open_parens_stack_index_count_11 int\n    var open_braces_stack_index_count_12 int\n    var open_parens_stack_index_count_12 int\n    var open_braces_stack_index_count\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2bisltii_test.go:51:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpdc8zcp7m_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpdc8zcp7m_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpdc8zcp7m_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpdc8zcp7m_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, paren_count)\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if len(paren_stack) > 0 {\n                if paren_count == paren_stack[len(paren_stack) - 1] {\n                    paren_stack = paren_stack[:len(paren_stack) - 1]\n                }\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if len(paren_stack) > 0 {\n            if paren_stack[i] == 0 {\n                paren_list = append(paren_list, paren_string[i:])\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp5wgbgkl7_test.go:57: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5wgbgkl7_test.go:57: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5wgbgkl7_test.go:57: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp5wgbgkl7_test.go:57: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parens\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp98vljbhb_test.go:56: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp98vljbhb_test.go:56: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp98vljbhb_test.go:56: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp98vljbhb_test.go:56: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string);\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkm9f4jfc_test.go:63:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        } else {\n            if len(paren_stack) > 0 {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] > 0 {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpzjxvtki2_test.go:56: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpzjxvtki2_test.go:56: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpzjxvtki2_test.go:56: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpzjxvtki2_test.go:56: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpgbzxyx8w_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                          ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpgbzxyx8w_test.go:60: expected '[() (()) ((())) (((())))]', got '[                      ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpgbzxyx8w_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpgbzxyx8w_test.go:60: expected '[() (()) (()())]', got '[                 ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        result = append(result, paren_string[paren_stack[len(paren_stack)-1]:])\n        if len(paren_stack) > 0 {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpu2rddjv8_test.go:52: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpu2rddjv8_test.go:52: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpu2rddjv8_test.go:52: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpu2rddjv8_test.go:52: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmpgcezc0ac_test.go:23 +0x3aa\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpgcezc0ac_test.go:41 +0x56\ntesting.tRunner(0xc000001380, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if len(paren_stack) > 0 {\n            if paren_stack[len(paren_stack)-1] == 0 {\n                result = append(result, \"\")\n            }\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpwkkmc3kx_test.go:48: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpwkkmc3kx_test.go:48: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpwkkmc3kx_test.go:48: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpwkkmc3kx_test.go:48: expected '[() (()) (()())]', got '[           ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    paren_stack_count := 0\n    paren_stack_string := \"\"\n    paren_string_index := 0\n    paren_string_count := 0\n    paren_string_string := \"\"\n    paren_string_list := make([]string, 0)\n    for paren_string_index < len(paren_string) {\n        if paren_string[paren_string_index] == '(' {\n            paren_stack_count += 1\n            paren_stack_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_string[paren_string_index] == ')' {\n            paren_stack_count -= 1\n            paren_stack_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_stack_count == 0 {\n            paren_string_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_stack_count > 0 {\n            paren_stack_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_string_count == 0 {\n            paren_string_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_string_count > 0 {\n            paren_string_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        }\n        if paren_string_count == 0 {\n            paren_string_string += paren_string[paren_string_index]\n            paren_string_count += 1\n            paren_string_index += 1\n            continue\n        \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptzpd5_4i_test.go:68:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        }\n        result = append(result, paren_string[i:i+paren_stack[i]+1])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpinv1snih_test.go:57: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpinv1snih_test.go:57: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpinv1snih_test.go:57: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpinv1snih_test.go:57: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        result = append(result, paren_string[paren_stack[len(paren_stack)-1]:])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp5i8ktrdk_test.go:51: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5i8ktrdk_test.go:51: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5i8ktrdk_test.go:51: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp5i8ktrdk_test.go:51: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmpgcezc0ac_test.go:23 +0x3aa\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpgcezc0ac_test.go:41 +0x56\ntesting.tRunner(0xc000001380, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpgcyqbm_q_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpgcyqbm_q_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpgcyqbm_q_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpgcyqbm_q_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpilrphs97_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpilrphs97_test.go:58: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpilrphs97_test.go:58: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpilrphs97_test.go:58: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfej1w0xj_test.go:61:23: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_stack = append(paren_stack, paren_string[:i])\n            paren_string = paren_string[i+1:]\n            i = -1\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpcdryppp9_test.go:48: expected '[(()()) ((())) () ((())()())]', got '[(()()  ((())  (  ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpcdryppp9_test.go:48: expected '[() (()) ((())) (((())))]', got '[(  (()  ((())  (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpcdryppp9_test.go:48: expected '[(()(())((())))]', got '[(()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpcdryppp9_test.go:48: expected '[() (()) (()())]', got '[(   (( )  (( )( )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            paren_list = append(paren_list, paren_string[i:i+1])\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp1__125fe_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp1__125fe_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp1__125fe_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp1__125fe_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, paren_count)\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if paren_count < 0 {\n                panic(\"Invalid parentheses\")\n            }\n            if len(paren_stack) > 0 {\n                if paren_stack[len(paren_stack) - 1] == paren_count {\n                    result = append(result, paren_string[i:i+1])\n                    paren_stack = paren_stack[:len(paren_stack) - 1]\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp6wd6yx_n_test.go:54: expected '[(()()) ((())) () ((())()())]', got '[) ) ) ) ) ) ) ) ) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp6wd6yx_n_test.go:54: expected '[() (()) ((())) (((())))]', got '[) ) ) ) ) ) ) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6wd6yx_n_test.go:54: expected '[(()(())((())))]', got '[) ) ) ) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp6wd6yx_n_test.go:54: expected '[() (()) (()())]', got '[) ) ) ) ) )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpdc8zcp7m_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpdc8zcp7m_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpdc8zcp7m_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpdc8zcp7m_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpd_nok_d4_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpd_nok_d4_test.go:35 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[paren_stack[i]:])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmprlfl4fx3_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmprlfl4fx3_test.go:50: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprlfl4fx3_test.go:50: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmprlfl4fx3_test.go:50: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_top int\n    var open_braces_count_stack_top_top_index int\n    var open_braces_count_stack_top_top_top int\n    var open_braces_count_stack_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_top int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprxall647_test.go:41:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                panic(\"unbalanced parentheses\")\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) != 0 {\n        panic(\"unbalanced parentheses\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fae, 0x1b, 0x5fa280, 0x582583, 0xf)\n\t/tmp/tmp4p2b38ex_test.go:27 +0x3e5\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmp4p2b38ex_test.go:43 +0x56\ntesting.tRunner(0xc000102600, 0x54f298)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpcripm9ck_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpfgzt5q4c_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpfgzt5q4c_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpfgzt5q4c_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpfgzt5q4c_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    var cur_string string\n    var open_braces int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_braces++\n        } else if paren_string[i] == ')' {\n            open_braces--\n        } else if paren_string[i] == ' ' {\n            if open_braces == 0 {\n                cur_string += paren_string[i]\n            }\n        } else {\n            if open_braces == 0 {\n                cur_string += paren_string[i]\n            }\n        }\n        if open_braces == 0 {\n            paren_list = append(paren_list, cur_string)\n            cur_string = \"\"\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo2vcaxau_test.go:25:28: invalid operation: cur_string += paren_string[i] (mismatched types string and byte)\n/tmp/tmpo2vcaxau_test.go:29:28: invalid operation: cur_string += paren_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(paren_string[:len(paren_stack)])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpa6q53nlj_test.go:53: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpa6q53nlj_test.go:53: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpa6q53nlj_test.go:53: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpa6q53nlj_test.go:53: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpitewihl9_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpitewihl9_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpitewihl9_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpitewihl9_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, paren_string[i:paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpw18_hh13_test.go:53: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpw18_hh13_test.go:53: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpw18_hh13_test.go:53: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpw18_hh13_test.go:53: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    open_parens := 0\n    open_braces := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n        } else if paren_string[i] == '{' {\n            open_braces++\n        } else if paren_string[i] == ')' {\n            open_parens--\n        } else if paren_string[i] == '}' {\n            open_braces--\n        }\n        if open_parens == 0 && open_braces == 0 {\n            paren_list = append(paren_list, paren_string[:i])\n            paren_string = paren_string[i:]\n            i = 0\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpmnld3ccx_test.go:53: expected '[(()()) ((())) () ((())()())]', got '[(()() )  ((()) )  ( )  ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpmnld3ccx_test.go:53: expected '[() (()) ((())) (((())))]', got '[( )  (() )  ((()) )  (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpmnld3ccx_test.go:53: expected '[(()(())((())))]', got '[(()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpmnld3ccx_test.go:53: expected '[() (()) (()())]', got '[(  )  (( ) )  (( )( )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result = append(result, paren_string[:paren_stack[len(paren_stack)-1]])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmproc485xf_test.go:53: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmproc485xf_test.go:53: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmproc485xf_test.go:53: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmproc485xf_test.go:53: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        } else {\n            if len(paren_stack) > 0 {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    for _, paren_count := range paren_stack {\n        if paren_count > 0 {\n            result = append(result, fmt.Sprintf(\"(%d)\", paren_count))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp2pwgc2k__test.go:56: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp2pwgc2k__test.go:56: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp2pwgc2k__test.go:56: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp2pwgc2k__test.go:56: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpigy87vrw_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpigy87vrw_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpigy87vrw_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpigy87vrw_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var current_string string\n    var open_parens int\n    var open_braces int\n    var open_braces_stack []int\n    var open_parens_stack []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n            open_braces_stack = append(open_braces_stack, open_braces)\n            open_parens_stack = append(open_parens_stack, open_parens)\n            if open_braces > 0 {\n                current_string += string(paren_string[i])\n            }\n        } else if paren_string[i] == ')' {\n            open_braces--\n            open_parens--\n            if open_braces == 0 {\n                open_braces_stack = pop(open_braces_stack)\n                open_parens_stack = pop(open_parens_stack)\n                if open_braces_stack[len(open_braces_stack) - 1] > 0 {\n                    current_string += string(paren_string[i])\n                }\n            } else {\n                current_string += string(paren_string[i])\n            }\n        } else {\n            current_string += string(paren_string[i])\n        }\n    }\n    result = append(result, current_string)\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8nn4vper_test.go:33:37: undefined: pop\n/tmp/tmp8nn4vper_test.go:34:37: undefined: pop\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    open_parens := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_parens++\n        } else if paren_string[i] == ')' {\n            open_parens--\n        }\n        if open_parens == 0 {\n            paren_list = append(paren_list, paren_string[0:i])\n            paren_string = paren_string[i+1:]\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp9r06u0co_test.go:47: expected '[(()()) ((())) () ((())()())]', got '[(()()  ((()))  ) ((())()(]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp9r06u0co_test.go:47: expected '[() (()) ((())) (((())))]', got '[(  (( ) ((( )) ((((]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp9r06u0co_test.go:47: expected '[(()(())((())))]', got '[(()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp9r06u0co_test.go:47: expected '[() (()) (()())]', got '[(   (( )) (( ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    paren_stack_count := 0\n    paren_stack_count_max := 0\n    paren_stack_count_min := 0\n    paren_stack_count_max_index := 0\n    paren_stack_count_min_index := 0\n    paren_stack_count_max_index_prev := 0\n    paren_stack_count_min_index_prev := 0\n    paren_stack_count_max_index_next := 0\n    paren_stack_count_min_index_next := 0\n    paren_stack_count_max_index_next_prev := 0\n    paren_stack_count_min_index_next_prev := 0\n    paren_stack_count_max_index_next_next := 0\n    paren_stack_count_min_index_next_next := 0\n    paren_stack_count_max_index_next_next_prev := 0\n    paren_stack_count_min_index_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next := 0\n    paren_stack_count_min_index_next_next_next := 0\n    paren_stack_count_max_index_next_next_next_prev := 0\n    paren_stack_count_min_index_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpza3efdof_test.go:44:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp26dps448_test.go:64:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_value int\n    var open_braces_count_stack_top_value_index int\n    var open_braces_count_stack_top_value_value int\n    var open_braces_count_stack_top_value_value_index int\n    var open_braces_count_stack_top_value_value_value int\n    var open_braces_count_stack_top_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value_value int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjy2y2x22_test.go:41:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Mismatched parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Mismatched parentheses\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 1 {\n            result = append(result, \"()\")\n        } else {\n            result = append(result, \"()()\")\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpyqw7v2_z_test.go:56: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpyqw7v2_z_test.go:56: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpyqw7v2_z_test.go:56: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpyqw7v2_z_test.go:56: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_index_end int\n    var open_braces_count_stack_top_index_end_end int\n    var open_braces_count_stack_top_index_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_top_index_end_end_end_end_end_end_end_end_end int\n    var open_braces_count_stack_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe2m760tu_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 1 {\n            result = append(result, \"()\")\n        } else {\n            result = append(result, \"()()\")\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp4j6omgda_test.go:56: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp4j6omgda_test.go:56: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp4j6omgda_test.go:56: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp4j6omgda_test.go:56: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpot_bekn2_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_value int\n    var open_braces_count_stack_top_value_index int\n    var open_braces_count_stack_top_value_value int\n    var open_braces_count_stack_top_value_value_index int\n    var open_braces_count_stack_top_value_value_value int\n    var open_braces_count_stack_top_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value_index int\n    var open_braces_count_stack_top_value_value_value_value_value_value_value_value_value int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjy2y2x22_test.go:41:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Mismatched parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(paren_string[:len(paren_stack)])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpr6cjyn_n_test.go:53: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpr6cjyn_n_test.go:53: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpr6cjyn_n_test.go:53: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpr6cjyn_n_test.go:53: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1zcx6v8m_test.go:61:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp5pj6ydy2_test.go:47: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5pj6ydy2_test.go:47: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5pj6ydy2_test.go:47: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp5pj6ydy2_test.go:47: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                panic(\"Invalid string\")\n            }\n        }\n    }\n    for _, paren_count := range paren_stack {\n        if paren_count == 0 {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[:paren_count]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpcdd6t9na_test.go:54: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpcdd6t9na_test.go:54: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpcdd6t9na_test.go:54: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpcdd6t9na_test.go:54: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpd_nok_d4_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpd_nok_d4_test.go:35 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) > 0 {\n                result = append(result, stack[len(stack)-1])\n                stack = stack[:len(stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa280, 0x582563, 0xf)\n\t/tmp/tmpjos44ifc_test.go:28 +0x46a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpjos44ifc_test.go:41 +0x56\ntesting.tRunner(0xc000001380, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpkc12rtn6_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpkc12rtn6_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpkc12rtn6_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpkc12rtn6_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmppwzurz5h_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmppwzurz5h_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmppwzurz5h_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmppwzurz5h_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnlnocd54_test.go:63:58: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parenthesis\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parenthesis\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpgbzxyx8w_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                          ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpgbzxyx8w_test.go:60: expected '[() (()) ((())) (((())))]', got '[                      ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpgbzxyx8w_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpgbzxyx8w_test.go:60: expected '[() (()) (()())]', got '[                 ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n            paren_stack = append(paren_stack, paren_count)\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if paren_count < 0 {\n                panic(\"Unbalanced parens\")\n            }\n            if paren_count == 0 {\n                paren_count = paren_stack[len(paren_stack) - 1]\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n                if len(paren_stack) == 0 {\n                    paren_list = append(paren_list, paren_string[:i])\n                    paren_string = paren_string[i + 1:]\n                    break\n                }\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp_i3ms_ih_test.go:57: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp_i3ms_ih_test.go:57: expected '[() (()) ((())) (((())))]', got '[(]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp_i3ms_ih_test.go:57: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp_i3ms_ih_test.go:57: expected '[() (()) (()())]', got '[( ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmprhgmo9_x_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmprhgmo9_x_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprhgmo9_x_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmprhgmo9_x_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        } else {\n            if len(paren_stack) > 0 {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] > 0 {\n            result = append(result, paren_string[i:i+paren_stack[i]])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpzjxvtki2_test.go:56: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpzjxvtki2_test.go:56: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpzjxvtki2_test.go:56: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpzjxvtki2_test.go:56: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp5ius7ugp_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    var current_string string\n    var open_braces int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            open_braces++\n        } else if paren_string[i] == ')' {\n            open_braces--\n        } else if paren_string[i] == ' ' {\n            if open_braces == 0 {\n                current_string += paren_string[i]\n            }\n        } else {\n            if open_braces == 0 {\n                current_string += paren_string[i]\n            }\n        }\n        if open_braces == 0 {\n            paren_list = append(paren_list, current_string)\n            current_string = \"\"\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll90wics_test.go:25:32: invalid operation: current_string += paren_string[i] (mismatched types string and byte)\n/tmp/tmpll90wics_test.go:29:32: invalid operation: current_string += paren_string[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbq1xqy9i_test.go:62:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_stack []string\n    var open_braces_stack_count int\n    var open_braces_stack_top int\n    var open_braces_stack_top_count int\n    var open_braces_stack_top_count_2 int\n    var open_braces_stack_top_count_3 int\n    var open_braces_stack_top_count_4 int\n    var open_braces_stack_top_count_5 int\n    var open_braces_stack_top_count_6 int\n    var open_braces_stack_top_count_7 int\n    var open_braces_stack_top_count_8 int\n    var open_braces_stack_top_count_9 int\n    var open_braces_stack_top_count_10 int\n    var open_braces_stack_top_count_11 int\n    var open_braces_stack_top_count_12 int\n    var open_braces_stack_top_count_13 int\n    var open_braces_stack_top_count_14 int\n    var open_braces_stack_top_count_15 int\n    var open_braces_stack_top_count_16 int\n    var open_braces_stack_top_count_17 int\n    var open_braces_stack_top_count_18 int\n    var open_braces_stack_top_count_19 int\n    var open_braces_stack_top_count_20 int\n    var open_braces_stack_top_count_21 int\n    var open_braces_stack_top_count_22 int\n    var open_braces_stack_top_count_23 int\n    var open_braces_stack_top_count_24 int\n    var open_braces_stack_top_count_25 int\n    var open_braces_stack_top_count_26 int\n    var open_braces_stack_top_count_27 int\n    var open_braces_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz6wlyon9_test.go:50:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpuag9ljev_test.go:63:26: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []rune{}\n    result := []string{}\n    for _, r := range paren_string {\n        if r == '(' {\n            paren_stack = append(paren_stack, r)\n        } else if r == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(r))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp2tovdkfn_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp2tovdkfn_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp2tovdkfn_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp2tovdkfn_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_top int\n    var open_braces_count_stack_top_top_index int\n    var open_braces_count_stack_top_top_top int\n    var open_braces_count_stack_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_top int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprxall647_test.go:41:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result[len(result)-1] += string(paren_string[i])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpn0sifs8n_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                          ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpn0sifs8n_test.go:60: expected '[() (()) ((())) (((())))]', got '[                      ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpn0sifs8n_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpn0sifs8n_test.go:60: expected '[() (()) (()())]', got '[                 ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid parentheses string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpo9gk21n3_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpo9gk21n3_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpo9gk21n3_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpo9gk21n3_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp_zbmbwqf_test.go:58: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpxm7t3ja5_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpxm7t3ja5_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpxm7t3ja5_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpxm7t3ja5_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fa9, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmpgfwu47wv_test.go:27 +0x3e5\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpgfwu47wv_test.go:43 +0x56\ntesting.tRunner(0xc000001380, 0x54f290)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpd_nok_d4_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpd_nok_d4_test.go:35 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_stack_count := 0\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack_count++\n            paren_stack = append(paren_stack, paren_stack_count)\n        } else if paren_string[i] == ')' {\n            paren_stack_count--\n            if paren_stack_count < 0 {\n                panic(\"Invalid input\")\n            }\n            if paren_stack_count == 0 {\n                result = append(result, paren_string[paren_stack[len(paren_stack) - 1] : i])\n                paren_stack = paren_stack[:len(paren_stack) - 1]\n            }\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Invalid input\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: Invalid input [recovered]\n\tpanic: Invalid input\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56deb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc00019e300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56deb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fa5, 0x1b, 0x5fa240, 0x582543, 0xf)\n\t/tmp/tmp9i00xv8d_test.go:34 +0x2ee\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc00019e300)\n\t/tmp/tmp9i00xv8d_test.go:46 +0x56\ntesting.tRunner(0xc00019e300, 0x54f290)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_stack = append(paren_stack, paren_string[:i])\n            paren_string = paren_string[i+1:]\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp0_tgknfh_test.go:47: expected '[(()()) ((())) () ((())()())]', got '[(()()  ((()))  ) ((())()(]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp0_tgknfh_test.go:47: expected '[() (()) ((())) (((())))]', got '[(  (( ) ((( )) ((((]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp0_tgknfh_test.go:47: expected '[(()(())((())))]', got '[(()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp0_tgknfh_test.go:47: expected '[() (()) (()())]', got '[(   (( )) (( ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, string(char))\n        } else {\n            paren_stack[len(paren_stack)-1]++\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa220, 0x582543, 0xf)\n\t/tmp/tmpw_z9pkce_test.go:22 +0x2f8\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpw_z9pkce_test.go:38 +0x56\ntesting.tRunner(0xc000001380, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Unbalanced parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parentheses\")\n            }\n            \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp26dps448_test.go:64:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                fmt.Println(\"Error: stack is empty\")\n                return nil\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        fmt.Println(\"Error: stack is not empty\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fc6, 0x1b, 0x5fa3a0, 0x582623, 0xf)\n\t/tmp/tmpsbzauikf_test.go:28 +0x4e5\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmpsbzauikf_test.go:45 +0x56\ntesting.tRunner(0xc000102600, 0x54f2b0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parenthesis\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Unbalanced parenthesis\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parenthesis\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Unbalanced parenthesis\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parenthesis\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Unbalanced parenthesis\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvidfpgwq_test.go:61:23: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid string\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid string\")\n            }\n            paren_stack = paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvwrm4wln_test.go:64:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    paren_stack_count := 0\n    paren_stack_count_max := 0\n    paren_stack_count_min := 0\n    paren_stack_count_max_index := 0\n    paren_stack_count_min_index := 0\n    paren_stack_count_max_index_prev := 0\n    paren_stack_count_min_index_prev := 0\n    paren_stack_count_max_index_next := 0\n    paren_stack_count_min_index_next := 0\n    paren_stack_count_max_index_next_prev := 0\n    paren_stack_count_min_index_next_prev := 0\n    paren_stack_count_max_index_next_next := 0\n    paren_stack_count_min_index_next_next := 0\n    paren_stack_count_max_index_next_next_prev := 0\n    paren_stack_count_min_index_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next := 0\n    paren_stack_count_min_index_next_next_next := 0\n    paren_stack_count_max_index_next_next_next_prev := 0\n    paren_stack_count_min_index_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next_next := 0\n    paren_stack_count_min_index_next_next_next_next_next_next_prev := 0\n    paren_stack_count_max_index_next_next_next_next_next_next_next := 0\n    paren_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp22xw2vm6_test.go:45:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(paren_string[:len(paren_stack)])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpa6q53nlj_test.go:53: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpa6q53nlj_test.go:53: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpa6q53nlj_test.go:53: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpa6q53nlj_test.go:53: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[paren_stack[i]:paren_stack[i]+1])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpeusi2aa7_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpeusi2aa7_test.go:50: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpeusi2aa7_test.go:50: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpeusi2aa7_test.go:50: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_str := range paren_stack {\n        if len(paren_str) > 0 {\n            paren_list = append(paren_list, paren_str)\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fa9, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmpcg9il773_test.go:26 +0x3ae\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmpcg9il773_test.go:44 +0x56\ntesting.tRunner(0xc000102600, 0x54f290)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input string\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_group := range paren_stack {\n        paren_list = append(paren_list, paren_group)\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fac, 0x1b, 0x5fa280, 0x582583, 0xf)\n\t/tmp/tmpde43e8lw_test.go:26 +0x39f\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmpde43e8lw_test.go:42 +0x56\ntesting.tRunner(0xc000102600, 0x54f298)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    paren_stack_index := 0\n    paren_stack_top := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack_index++\n            paren_stack_top = paren_stack_index\n        } else if paren_string[i] == ')' {\n            paren_stack_index--\n            if paren_stack_index < 0 {\n                panic(\"Invalid parentheses string\")\n            }\n            if paren_stack_index == paren_stack_top {\n                paren_stack_top = 0\n                paren_stack = make([]int, 0)\n            }\n        }\n        if paren_stack_index == 0 {\n            if paren_string[i] != ' ' {\n                paren_list = append(paren_list, paren_string[i:i+1])\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_q1da2ng_test.go:16:5: paren_stack declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_group := range paren_stack {\n        paren_list = append(paren_list, paren_group)\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmp9qb5vet__test.go:23 +0x39b\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmp9qb5vet__test.go:39 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpmr79gz7f_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpmr79gz7f_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpmr79gz7f_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpmr79gz7f_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpklwsct1z_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i*2:i*2+2])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpy3l4pt7a_test.go:52: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpy3l4pt7a_test.go:52: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpy3l4pt7a_test.go:52: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpy3l4pt7a_test.go:52: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmppwzurz5h_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmppwzurz5h_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmppwzurz5h_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmppwzurz5h_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpd_nok_d4_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpd_nok_d4_test.go:35 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    paren_count := 0\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n        }\n        if paren_count == 0 {\n            paren_stack = append(paren_stack, paren_string[0:i])\n            paren_string = paren_string[i+1:]\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp2p2idsvd_test.go:47: expected '[(()()) ((())) () ((())()())]', got '[(()()  ((()))  ) ((())()(]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp2p2idsvd_test.go:47: expected '[() (()) ((())) (((())))]', got '[(  (( ) ((( )) ((((]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp2p2idsvd_test.go:47: expected '[(()(())((())))]', got '[(()(())((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp2p2idsvd_test.go:47: expected '[() (()) (()())]', got '[(   (( )) (( ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        } else if c == ' ' {\n            continue\n        } else {\n            paren_stack = append(paren_stack, paren_stack[len(paren_stack) - 1] + 1)\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(c))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpkje7mxhc_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpkje7mxhc_test.go:50: expected '[() (()) ((())) (((())))]', got '[) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpkje7mxhc_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpkje7mxhc_test.go:50: expected '[() (()) (()())]', got '[) ) )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    var result []string\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        if paren_stack[i] == 1 {\n            result = append(result, \"\")\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := 0; j < len(result[i]); j++ {\n            if result[i][j] == '(' {\n                result[i] = result[i][:j] + \"(\" + result[i][j+1:]\n            }\n            if result[i][j] == ')' {\n                result[i] = result[i][:j] + \")\" + result[i][j+1:]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpo9yexnaz_test.go:58: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpo9yexnaz_test.go:58: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpo9yexnaz_test.go:58: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpo9yexnaz_test.go:58: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    paren_count := 0\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, paren_count)\n            paren_count++\n        } else if paren_string[i] == ')' {\n            paren_count--\n            if paren_count < 0 {\n                panic(\"Invalid parentheses\")\n            }\n            if len(paren_stack) > 0 {\n                if paren_stack[len(paren_stack) - 1] == paren_count {\n                    paren_stack = paren_stack[:len(paren_stack) - 1]\n                } else {\n                    panic(\"Invalid parentheses\")\n                }\n            }\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"Invalid parentheses\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] != ' ' {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpfvkdf6hx_test.go:63: expected '[(()()) ((())) () ((())()())]', got '[( ( ) ( ) ) ( ( ( ) ) ) ( ) ( ( ( ) ) ( ) ( ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpfvkdf6hx_test.go:63: expected '[() (()) ((())) (((())))]', got '[( ) ( ( ) ) ( ( ( ) ) ) ( ( ( ( ) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpfvkdf6hx_test.go:63: expected '[(()(())((())))]', got '[( ( ) ( ( ) ) ( ( ( ) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpfvkdf6hx_test.go:63: expected '[() (()) (()())]', got '[( ) ( ( ) ) ( ( ) ( ) )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpd_nok_d4_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpd_nok_d4_test.go:35 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Mismatched parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(c)\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3jdcbwp_test.go:33:41: undefined: c\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp4tqllfd5_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp4tqllfd5_test.go:60: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp4tqllfd5_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp4tqllfd5_test.go:60: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Mismatched parentheses\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Mismatched parentheses\")\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i:i+1])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpm2833zrz_test.go:52: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpm2833zrz_test.go:52: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpm2833zrz_test.go:52: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpm2833zrz_test.go:52: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmphzp97mlj_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmphzp97mlj_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmphzp97mlj_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmphzp97mlj_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parentheses\")\n                return nil\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        fmt.Println(\"Error: Unbalanced parentheses\")\n        return nil\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa360, 0x5825e3, 0xf)\n\t/tmp/tmpkjuisc7o_test.go:28 +0x4e5\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpkjuisc7o_test.go:45 +0x56\ntesting.tRunner(0xc000001380, 0x54f2a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] != ' ' {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpo16mfvzd_test.go:56: expected '[(()()) ((())) () ((())()())]', got '[( ( ) ( ) ) ( ( ( ) ) ) ( ) ( ( ( ) ) ( ) ( ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpo16mfvzd_test.go:56: expected '[() (()) ((())) (((())))]', got '[( ) ( ( ) ) ( ( ( ) ) ) ( ( ( ( ) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpo16mfvzd_test.go:56: expected '[(()(())((())))]', got '[( ( ) ( ( ) ) ( ( ( ) ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpo16mfvzd_test.go:56: expected '[() (()) (()())]', got '[( ) ( ( ) ) ( ( ) ( ) )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if char == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for len(paren_stack) > 0 {\n        if paren_stack[len(paren_stack)-1] == 0 {\n            result = append(result, \"\")\n        }\n        result[len(result)-1] += string(paren_string[0:len(paren_stack)])\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp826r2c1h_test.go:54: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp826r2c1h_test.go:54: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp826r2c1h_test.go:54: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp826r2c1h_test.go:54: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack) - 1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"unbalanced parens\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) ==\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6hf2ppy9_test.go:61:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, string(char))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmprhgmo9_x_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmprhgmo9_x_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprhgmo9_x_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmprhgmo9_x_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    for _, char := range paren_string {\n        if char == '(' {\n            stack = append(stack, \"\")\n        } else if char == ')' {\n            if len(stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            result = append(result, stack[len(stack)-1])\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(char)\n        }\n    }\n    if len(stack) > 0 {\n        panic(\"unbalanced parens\")\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549fa9, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmpgfwu47wv_test.go:27 +0x3e5\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000001380)\n\t/tmp/tmpgfwu47wv_test.go:43 +0x56\ntesting.tRunner(0xc000001380, 0x54f290)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpd_nok_d4_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpd_nok_d4_test.go:35 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_count_stack []int\n    var open_braces_count_stack_index int\n    var open_braces_count_stack_top int\n    var open_braces_count_stack_top_index int\n    var open_braces_count_stack_top_top int\n    var open_braces_count_stack_top_top_index int\n    var open_braces_count_stack_top_top_top int\n    var open_braces_count_stack_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_index int\n    var open_braces_count_stack_top_top_top_top_top_top_top_top_top_top int\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprxall647_test.go:41:6: expected '(', found TestSeparate_Paren_Groups\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n\n    for len(paren_stack) > 0 {\n        result = append(result, paren_string[0:paren_stack[len(paren_stack)-1]])\n        paren_string = paren_string[paren_stack[len(paren_stack)-1]:]\n        paren_stack = paren_stack[:len(paren_stack)-1]\n    }\n\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmph2ik75xa_test.go:54: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmph2ik75xa_test.go:54: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmph2ik75xa_test.go:54: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmph2ik75xa_test.go:54: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                result = append(result, string(c))\n            } else {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp4t0mldw3_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[     ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp4t0mldw3_test.go:49: expected '[() (()) ((())) (((())))]', got '[     ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp4t0mldw3_test.go:49: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp4t0mldw3_test.go:49: expected '[() (()) (()())]', got '[   ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpigy87vrw_test.go:49: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpigy87vrw_test.go:49: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpigy87vrw_test.go:49: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpigy87vrw_test.go:49: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpitewihl9_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpitewihl9_test.go:50: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpitewihl9_test.go:50: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpitewihl9_test.go:50: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Paren stack is empty\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            if len(paren_stack) == 0 {\n                paren_list = append(paren_list, string(paren_string[i]))\n            } else {\n                paren_stack[len(paren_stack)-1]++\n            }\n        }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpait0yqe2_test.go:53: expected '[(()()) ((())) () ((())()())]', got '[     ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpait0yqe2_test.go:53: expected '[() (()) ((())) (((())))]', got '[     ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpait0yqe2_test.go:53: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpait0yqe2_test.go:53: expected '[() (()) (()())]', got '[   ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    var result []string\n    var stack []string\n    var open_parens []string\n    var open_braces []string\n    var open_braces_count int\n    var open_braces_stack []string\n    var open_braces_stack_count int\n    var open_braces_stack_top int\n    var open_braces_stack_top_count int\n    var open_braces_stack_top_count_2 int\n    var open_braces_stack_top_count_3 int\n    var open_braces_stack_top_count_4 int\n    var open_braces_stack_top_count_5 int\n    var open_braces_stack_top_count_6 int\n    var open_braces_stack_top_count_7 int\n    var open_braces_stack_top_count_8 int\n    var open_braces_stack_top_count_9 int\n    var open_braces_stack_top_count_10 int\n    var open_braces_stack_top_count_11 int\n    var open_braces_stack_top_count_12 int\n    var open_braces_stack_top_count_13 int\n    var open_braces_stack_top_count_14 int\n    var open_braces_stack_top_count_15 int\n    var open_braces_stack_top_count_16 int\n    var open_braces_stack_top_count_17 int\n    var open_braces_stack_top_count_18 int\n    var open_braces_stack_top_count_19 int\n    var open_braces_stack_top_count_20 int\n    var open_braces_stack_top_count_21 int\n    var open_braces_stack_top_count_22 int\n    var open_braces_stack_top_count_23 int\n    var open_braces_stack_top_count_24 int\n    var open_braces_stack_top_count_25 int\n    var open_braces_stack_top_count_26 int\n    var open_braces_stack_top_count_27 int\n    var open_braces_\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz6wlyon9_test.go:50:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]string, 0)\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa200, 0x582543, 0xf)\n\t/tmp/tmpd_nok_d4_test.go:22 +0x29a\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmpd_nok_d4_test.go:35 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n        if len(paren_stack) == 0 {\n            result = append(result, paren_string[i:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()()) ((())) () ((())()())]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) ((())) (((())))]', got '[)   )   )   )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[(()(())((())))]', got '[)]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpoxiswvb7_test.go:46: expected '[() (()) (()())]', got '[)   )   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"unbalanced parens\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    for _, paren_count := range paren_stack {\n        if paren_count > 0 {\n            result = append(result, string(paren_string[:paren_count]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp87rjnk1v_test.go:51: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp87rjnk1v_test.go:51: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp87rjnk1v_test.go:51: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp87rjnk1v_test.go:51: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                fmt.Println(\"Error: Unbalanced parens\")\n                return nil\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        fmt.Println(\"Error: Unbalanced parens\")\n        return nil\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            result = append(result, \"\")\n        } else if paren_string[i] == ')' {\n            result = append(result, \"\")\n        } else {\n            result = append(result, string(paren_string[i]))\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[() (()) ((())) (((())))]', got '[                         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp6x269e7j_test.go:60: expected '[() (()) (()())]', got '[                       ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := make([]int, 0)\n    result := make([]string, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n            } else {\n                result = append(result, \"\")\n            }\n        }\n    }\n    for i := 0; i < len(paren_stack); i++ {\n        result = append(result, paren_string[i:len(paren_string)-paren_stack[i]])\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmp1sm48ult_test.go:50: expected '[(()()) ((())) () ((())()())]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp1sm48ult_test.go:50: expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp1sm48ult_test.go:50: expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp1sm48ult_test.go:50: expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_list := []string{}\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    for _, paren_group := range paren_stack {\n        paren_list = append(paren_list, paren_group)\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa260, 0x582563, 0xf)\n\t/tmp/tmp9qb5vet__test.go:23 +0x39b\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000186300)\n\t/tmp/tmp9qb5vet__test.go:39 +0x56\ntesting.tRunner(0xc000186300, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    for _, c := range paren_string {\n        if c == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if c == ')' {\n            if len(paren_stack) == 0 {\n                return []string{}\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(c)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa220, 0x582543, 0xf)\n\t/tmp/tmp_3kq7vaz_test.go:25 +0x294\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmp_3kq7vaz_test.go:38 +0x56\ntesting.tRunner(0xc000102600, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_stack := []string{}\n    for _, char := range paren_string {\n        if char == '(' {\n            paren_stack = append(paren_stack, \"\")\n        } else if char == ')' {\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        } else {\n            paren_stack[len(paren_stack)-1] += string(char)\n        }\n    }\n    return paren_stack\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.separate_paren_groups(0x549f98, 0x1b, 0x5fa220, 0x582543, 0xf)\n\t/tmp/tmpvxt9ol1w_test.go:22 +0x274\ncommand-line-arguments_test.TestSeparate_Paren_Groups(0xc000102600)\n\t/tmp/tmpvxt9ol1w_test.go:35 +0x56\ntesting.tRunner(0xc000102600, 0x54f280)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string string) []string {\n    paren_groups := make([]string, 0)\n    paren_stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_stack = append(paren_stack, 1)\n        } else if paren_string[i] == ')' {\n            if len(paren_stack) == 0 {\n                panic(\"Invalid input\")\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n        }\n    }\n    if len(paren_stack) != 0 {\n        panic(\"Invalid input\")\n    }\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n            paren_groups = append(paren_groups, \"\")\n        } else if paren_string[i] == ')' {\n            paren_groups = append(paren_groups, \"\")\n        } else if paren_string[i] == ' ' {\n            continue\n        } else {\n            paren_groups[len(paren_groups)-1] += string(paren_string[i])\n        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n        tmplt28sxuo_test.go:60: expected '[(()()) ((())) () ((())()())]', got '[                       ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmplt28sxuo_test.go:60: expected '[() (()) ((())) (((())))]', got '[                   ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmplt28sxuo_test.go:60: expected '[(()(())((())))]', got '[             ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmplt28sxuo_test.go:60: expected '[() (()) (()())]', got '[           ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}