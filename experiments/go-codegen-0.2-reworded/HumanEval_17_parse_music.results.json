{
  "name": "HumanEval_17_parse_music",
  "language": "go_test.go",
  "prompt": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n",
  "tests": "func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    var current_note_duration int\n    var current_note_duration_count int\n    var current_note_duration_count_max int\n    var current_note_duration_count_min int\n    var current_note_duration_count_max_min int\n    var current_note_duration_count_min_max int\n    var current_note_duration_count_min_max_max int\n    var current_note_duration_count_min_max_max_min int\n    var current_note_duration_count_min_max_max_min_max int\n    var current_note_duration_count_min_max_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max int\n    var current_note_duration_count_min_max_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note_duration_count_min_max_max_min_max_min_max_min_max_min int\n    var current_note\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_beat_count int\n    var note_beat_duration int\n    var note_beat_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note_count++\n            note_duration = 0\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else if music_string[i] == '|' {\n            note_count++\n            note_duration = 0\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else if music_string[i] == 'o' {\n            note_count++\n            note_duration = 4\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else if music_string[i] == 'o|' {\n            note_count++\n            note_duration = 2\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else if music_string[i] == '.' || music_string[i] == '|' || music_string[i] == 'o' || music_string[i] == 'o|' {\n            note_count++\n            note_duration = 1\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        } else {\n            note_count++\n            note_duration = 0\n            note_beats = 0\n            note_beat_count = 0\n            note_beat_duration = 0\n            note_beat_beats = 0\n        }\n    }\n    for i := 0; i < note_count; i++ {\n        result = append(result\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == '.'|'|' {\n            current_note = \".\"\n            current_duration = 1\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n            current_duration_multiplier_multiplier_multiplier = 1\n            continue\n        }\n        if music_string[i] == 'o' || music_string[i] == 'o|' || music_string[i] == '.' || music_string[i] == '\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for _, c := range music_string {\n        if c == ' ' {\n            continue\n        }\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            continue\n        }\n        if c == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat += 1\n            continue\n        }\n        if c == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat += 1\n            continue\n        }\n        if c == '.' {\n            current_note = \".\"\n            current_duration = 1\n            current_beat += 1\n            continue\n        }\n        if c == '|' {\n            current_note = \"|\"\n            current_duration = 1\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat += 1\n            continue\n        }\n        if c == '.' {\n            current_note = \".\"\n            current_duration = 1\n            current_beat += 1\n            continue\n        }\n        if c == '|' {\n            current_note = \"|\"\n            current_duration = 1\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat += 1\n            continue\n        }\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat += 1\n            continue\n        }\n        if c == '.' {\n            current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_count int\n    var current_note_count_multiplier int\n    var current_note_count_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + music_string[i]\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + music_string[i]\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + music_string[i]\n            count = count + 4\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            note = note + \" \"\n            count = 0\n        }\n        if count == 2 {\n            beats = append(beats, 2)\n            note = note + \" \"\n            count = 0\n        }\n        if count == 1 {\n            beats = append(beats, 1)\n            note = note + \" \"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat int\n    var current_beat_count int\n    var current_beat_count_count int\n    var current_beat_count_count_count int\n    var current_beat_count_count_count_count int\n    var current_beat_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_count_count\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 2\n        } else if music_string[i] == '.' {\n            current_note = \".\"\n            current_duration = 1\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == '|' {\n            current_note = \"|\"\n            current_duration = 1\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else {\n            panic(\"Unknown note\")\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration * current_duration_multiplier * current_duration_multiplier_multiplier)\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 0\n            current_duration_multiplier_multiplier = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if c == '|' {\n            current_note += c\n            current_duration += 1\n        } else if c == 'o' {\n            current_note += c\n            current_duration += 4\n        } else {\n            current_note += c\n            current_duration += 2\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration)\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_count int\n    var current_duration int\n    var current_beat int\n    for _, c := range music_string {\n        if c == 'o' || c == 'o|' || c == '.' || c == '|' {\n            if current_note != \"\" {\n                result = append(result, current_count)\n                current_note = \"\"\n                current_count = 0\n            }\n            if c == 'o' || c == 'o|' {\n                current_duration = 4\n            } else if c == '.' || c == '|' {\n                current_duration = 1\n            }\n            current_beat += 1\n        } else {\n            current_note += string(c)\n            current_count += current_duration\n        }\n    }\n    result = append(result, current_count)\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = current_note + c\n            current_beat += 1\n        } else if c == '|' {\n            current_note = current_note + c\n            current_beat += 2\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_beat += 4\n        } else {\n            current_note = current_note + c\n            current_beat += 1\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            beats = append(beats, current_beat)\n            current_note = \"\"\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_count_multiplier int\n    var current_note_count_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_beats int\n    var current_note_beat_count int\n    var current_note_beat_count_beats int\n    var current_note_beat_count_beats_count int\n    var current_note_beat_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats_count int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats int\n    var current_note_beat_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats_count_beats\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    var current_note_beats_count int\n    var current_note_beats_count_count int\n    var current_note_beats_count_count_count int\n    var current_note_beats_count_count_count_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \".\"\n            current_note_length = 1\n            current_note_beats = 1\n            current_note_beats_count = 1\n            current_note_beats_count_count = 1\n            current_note_beats_count_count_count = 1\n            current_note_beats_count_count_count_count = 1\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note = \"|\"\n            current_note_length = 1\n            current_note_beats = 1\n            current_note_beats_count = 1\n            current_note_beats_count_count = 1\n            current_note_beats_count_count_count = 1\n            current_note_beats_count_count_count_count = 1\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_length = 4\n            current_note_beats = 1\n            current_note_beats_count = 1\n            current_note_beats_count_count = 1\n            current_note_beats_count_count_count = 1\n            current_note_beats_count_count_count_count = 1\n            continue\n        }\n        if music_string[i] == 'o|' {\n            current_note = \"o|\"\n            current_note_length = 2\n            current_note_beats = 1\n            current_note_beats_count = 1\n            current_note_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_count_multiplier int\n    var current_note_count_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note_count int\n    var note_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note_count = note_count + 1\n        } else if music_string[i] == '|' {\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            if note_count == 0 {\n                beats = append(beats, note_duration)\n                note_count = note_count + 1\n                note_duration = 0\n            } else {\n                beats = append(beats, note_duration)\n                note_count = note_count - 1\n                note_duration = 0\n            }\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note string\n    var count int\n    for _, c := range music_string {\n        if c == 'o' {\n            note = \"o\"\n            count = 4\n        } else if c == 'o|' {\n            note = \"o\"\n            count = 2\n        } else if c == '.' {\n            note = \".\"\n            count = 1\n        } else {\n            note = \" \"\n            count = 0\n        }\n        result = append(result, count)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_duration = 1\n        } else if music_string[i] == '|' {\n            current_duration = 2\n        } else if music_string[i] == 'o' {\n            current_duration = 4\n        } else if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n        } else if music_string[i] == 'o' {\n            current_note = \"half\"\n            current_duration = 2\n        } else if music_string[i] == 'o' {\n            current_note = \"quarter\"\n            current_duration = 1\n        }\n        if current_note != \"\" {\n            beats = append(beats, current_beat)\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        }\n        current_beat += current_duration\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, note := range music_string {\n        if note == 'o' {\n            current_beat += 4\n        } else if note == 'o|' {\n            current_beat += 2\n        } else if note == '.' {\n            current_beat += 1\n        } else {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \".\"\n            current_duration = 1\n        } else if music_string[i] == '|' {\n            current_note = \"|\"\n            current_duration = 2\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else {\n            panic(\"Invalid note\")\n        }\n        if current_note == \".\" {\n            current_beats = current_beats + current_duration\n        } else {\n            current_beats = current_beats + current_duration * 2\n        }\n        if current_note == \"o\" {\n            result = append(result, current_beats)\n        }\n        current_note = \"\"\n        current_duration = 0\n        current_beats = 0\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var notes []int\n    var note_count int\n    var note_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note_count = note_count + 1\n        } else if music_string[i] == '|' {\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 4\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 2\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music_string[i] == 'o' {\n            note_count = note_count + 1\n            note_duration = note_duration + 1\n        } else if music\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292800,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_count_multiplier int\n    var current_note_count_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_count_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_note_count int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_note_count = 0\n        } else if c == '|' {\n            current_note += c\n            current_note_count++\n        } else if c == 'o' {\n            if current_note_count > 0 {\n                beats = append(beats, current_note_count)\n                current_note_count = 0\n            }\n            current_note += c\n        } else {\n            current_note += c\n            current_note_count++\n        }\n    }\n    if current_note_count > 0 {\n        beats = append(beats, current_note_count)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                current_beat += 4\n            case 'o|':\n                current_beat += 2\n            case '.':\n                current_beat += 1\n            default:\n                current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for _, c := range music_string {\n        if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else if c == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n        } else if c == '.' {\n            current_note = \".\"\n            current_duration = 1\n        } else {\n            current_note = \"o\"\n            current_duration = 4\n        }\n        if current_note != \"o\" {\n            result = append(result, current_duration)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        switch music_string[i] {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, char := range music_string {\n        switch char {\n            case 'o':\n                current_beat += 4\n            case 'o|':\n                current_beat += 2\n            case '.':\n                current_beat += 1\n            default:\n                beats = append(beats, current_beat)\n                current_beat = 0\n        }\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note string\n    var beats int\n    var i int\n    for i = 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = \"\"\n            beats = 0\n        } else if music_string[i] == '|' {\n            note = note + \"o\"\n            beats = beats + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o|\"\n            beats = beats + 2\n        } else if music_string[i] == 'o' {\n            note = note + \"o|\"\n            beats = beats + 2\n        } else {\n            note = note + music_string[i]\n            beats = beats + 1\n        }\n        if note == \"o o| o| o| o| o| o| o| o o\" {\n            result = append(result, beats)\n            note = \"\"\n            beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_count int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_count = 0\n        } else if char == '|' {\n            if current_note == \"\" {\n                current_note = \"whole\"\n                current_duration = 4\n                current_duration_count = 1\n            } else {\n                current_note = current_note + \"half\"\n                current_duration = 2\n                current_duration_count = 1\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"whole\"\n                current_duration = 4\n                current_duration_count = 1\n            } else {\n                current_note = current_note + \"quarter\"\n                current_duration = 1\n                current_duration_count = 1\n            }\n        } else {\n            if current_note == \"\" {\n                current_note = \"whole\"\n                current_duration = 4\n                current_duration_count = 1\n            } else {\n                current_note = current_note + \"half\"\n                current_duration = 2\n                current_duration_count = 1\n            }\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration_count)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    var current_duration int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_beat = 0\n            current_duration = 0\n        } else if c == '|' {\n            current_note = current_note + c\n            current_beat = current_beat + 1\n            current_duration = 0\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_beat = current_beat + 1\n            current_duration = 4\n        } else if c == 'o|' {\n            current_note = current_note + c\n            current_beat = current_beat + 1\n            current_duration = 2\n        }\n        if current_note != \"\" {\n            if current_note == \"o\" {\n                beats = append(beats, current_beat * current_duration)\n            } else if current_note == \"o|\" {\n                beats = append(beats, current_beat * current_duration)\n            } else if current_note == \".|\" {\n                beats = append(beats, current_beat * current_duration)\n            }\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n        case 'o':\n            result = append(result, 4)\n        case 'o|':\n            result = append(result, 2)\n        case '.':\n            result = append(result, 1)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    var current_note_duration int\n    var current_note_duration_count int\n    var current_note_duration_count_max int\n    var current_note_duration_count_min int\n    var current_note_duration_count_sum int\n    var current_note_duration_count_sum_max int\n    var current_note_duration_count_sum_min int\n    var current_note_duration_count_sum_sum int\n    var current_note_duration_count_sum_sum_max int\n    var current_note_duration_count_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_sum int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_sum_max int\n    var current_note_duration_count_sum_sum_sum_sum_sum_sum_sum_min int\n    var current_note_duration_count_sum_sum_sum_sum\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_index int\n    var note_string string\n    var note_string_index int\n    var note_string_length int\n    var note_string_length_index int\n    var note_string_length_length int\n    var note_string_length_length_index int\n    var note_string_length_length_length int\n    var note_string_length_length_length_index int\n    var note_string_length_length_length_length int\n    var note_string_length_length_length_length_index int\n    var note_string_length_length_length_length_length int\n    var note_string_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length_length_length_length int\n    var note_string_length_length_length_length_length_length_length_length_length_length_length_index int\n    var note_string_length_length_length_length_length_length_length_length\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    var current_note_duration int\n    var current_note_duration_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_count = 0\n            current_note_duration_count = 0\n        } else if music_string[i] == '|' {\n            current_note_count = 0\n            current_note_duration_count = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_note_count = 4\n            current_note_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"half\"\n            current_note_count = 2\n            current_note_duration = 2\n        }\n        if current_note != \"\" {\n            if current_note_count == 0 {\n                current_note_count = 1\n            }\n            if current_note_duration_count == 0 {\n                current_note_duration_count = 1\n            }\n            if current_note_count > 0 {\n                result = append(result, current_note_count)\n            }\n            if current_note_duration_count > 0 {\n                result = append(result, current_note_duration_count)\n            }\n            current_note_count = 0\n            current_note_duration_count = 0\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_note_count = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_note_count = current_note_count + 4\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_note_count = current_note_count + 2\n        } else {\n            current_note = current_note + \".\" + music_string[i]\n            current_note_count = current_note_count + 1\n        }\n        if current_note_count > 0 {\n            result = append(result, current_note_count)\n            current_note_count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 4\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 4\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 4\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 2\n        } else if music_string[i] == '.' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 2\n        } else if music_string[i] == '.' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 2\n        } else if music_string[i\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_note_length = 0\n            current_note_beats = 0\n        } else if c == '|' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 4\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 2\n        } else if c == '|' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '.' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '|' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '.' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '|' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == '.' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length += 1\n            current_note_beats += 1\n        } else if c == 'o' {\n            current_note_length\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    for _, char := range music_string {\n        if char == 'o' {\n            current_note_duration = 4\n        } else if char == 'o|' {\n            current_note_duration = 2\n        } else if char == '.' {\n            current_note_duration = 1\n        } else {\n            current_note = \"\"\n        }\n        if current_note != \"\" {\n            current_note += char\n        } else {\n            if current_note_duration > 0 {\n                result = append(result, current_note_duration)\n                current_note_duration = 0\n            }\n            current_note = char\n        }\n    }\n    if current_note_duration > 0 {\n        result = append(result, current_note_duration)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if char == '|' {\n            current_note = current_note + char\n            current_duration++\n        } else if char == 'o' {\n            current_note = current_note + char\n            current_duration += 4\n        } else {\n            current_note = current_note + char\n            current_duration++\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration)\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_count int\n    var current_note_duration int\n    var current_note_duration_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_count = 0\n            current_note_duration_count = 0\n        } else if music_string[i] == '|' {\n            current_note_count = 0\n            current_note_duration_count = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_count = 1\n            current_note_duration_count = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"o|\"\n            current_note_count = 1\n            current_note_duration_count = 2\n        } else {\n            current_note = \".\"\n            current_note_count = 0\n            current_note_duration_count = 0\n        }\n        if current_note_count == 0 {\n            current_note_duration = current_note_duration + current_note_duration_count\n        } else {\n            current_note_duration = current_note_duration + current_note_duration_count\n            current_note_count = current_note_count + 1\n            result = append(result, current_note_duration)\n            current_note_duration = 0\n            current_note_duration_count = 0\n        }\n    }\n    if current_note_count > 0 {\n        result = append(result, current_note_duration)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if char == '|' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n                current_beats = current_beats + 4\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_length_count int\n    var current_note_count_count int\n    for _, c := range music_string {\n        if c == 'o' {\n            current_note_length_count = 4\n        } else if c == 'o|' {\n            current_note_length_count = 2\n        } else if c == '.' {\n            current_note_length_count = 1\n        } else {\n            current_note_length_count = 0\n        }\n        current_note_count_count = 0\n        for _, c := range current_note {\n            if c == 'o' {\n                current_note_count_count = 4\n            } else if c == 'o|' {\n                current_note_count_count = 2\n            } else if c == '.' {\n                current_note_count_count = 1\n            } else {\n                current_note_count_count = 0\n            }\n            current_note_count += current_note_count_count\n            current_note_length += current_note_length_count\n            current_note_length_count = 0\n        }\n        current_note = \"\"\n        current_note_count = 0\n        current_note_length_count = 0\n        result = append(result, current_note_count)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_count = 0\n            current_note = \"\"\n            current_note_length = 0\n        } else if music_string[i] == '|' {\n            current_note_count = 0\n            current_note = \"\"\n            current_note_length = 0\n        } else if music_string[i] == 'o' {\n            current_note_count = 1\n            current_note = \"o\"\n            current_note_length = 4\n        } else if music_string[i] == 'o|' {\n            current_note_count = 2\n            current_note = \"o|\"\n            current_note_length = 2\n        }\n        if current_note_count > 0 {\n            current_note_count++\n            if current_note_length == 1 {\n                current_note_length = 4\n            } else if current_note_length == 2 {\n                current_note_length = 2\n            } else if current_note_length == 4 {\n                current_note_length = 1\n            }\n            result = append(result, current_note_count)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + music_string[i]\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + music_string[i]\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + music_string[i]\n            count = count + 4\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            note = note + \"|\"\n            count = 0\n        }\n        if count == 2 {\n            beats = append(beats, 2)\n            note = note + \"|\"\n            count = 0\n        }\n        if count == 1 {\n            beats = append(beats, 1)\n            note = note + \"|\"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_rest int\n    var note_rest_count int\n    var note_rest_duration int\n    var note_rest_beats int\n    var note_rest_rest int\n    var note_rest_rest_count int\n    var note_rest_rest_duration int\n    var note_rest_rest_beats int\n    var note_rest_rest_rest int\n    var note_rest_rest_rest_count int\n    var note_rest_rest_rest_duration int\n    var note_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        if note == 'o' {\n            beats = append(beats, 4)\n        } else if note == 'o|' {\n            beats = append(beats, 2)\n        } else if note == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    var current_note_length int\n    var current_note_length_multiplier int\n    var current_note_length_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_count int\n    var current_beat_duration_count_count int\n    var current_beat_duration_count_count_count int\n    var current_beat_duration_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n            current_beat_duration = 0\n            current_beat_duration_count = 0\n            current_beat_duration_count_count = 0\n            current_beat_duration_count_count_count = 0\n            current_beat_duration_count_count_count_count = 0\n            current_beat_duration_count_count_count_count_count = 0\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n            current_beat_duration = 0\n            current_beat_duration_count = 0\n            current_beat_duration_count_count = 0\n            current_beat_duration_count_count_count = 0\n            current_beat_duration_count_count_count_count = 0\n            current_beat_duration_count_count_count_count_count = 0\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beats = 0\n            current_beat_duration = 0\n            current_beat_duration_count = 0\n            current_beat_duration_count_count = 0\n            current_beat_duration_count_count_count = 0\n            current_beat_duration_count_count_count_count = 0\n            current_beat_duration_count_count_count_count_count = 0\n            continue\n        }\n        if music\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_beats int\n    var current_note_beats_count int\n    var current_note_beats_count_count int\n    var current_note_beats_count_count_count int\n    var current_note_beats_count_count_count_count int\n    var current_note_beats_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n            current_note_duration_multiplier_multiplier = 2\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n            current_note_duration_multiplier_multiplier = 2\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n            current_note_duration_multiplier_multiplier = 2\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            current_note = \"\"\n            continue\n        }\n        if music_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            current_beat += 4\n        } else if music_string[i] == 'o|' {\n            current_beat += 2\n        } else if music_string[i] == '.' {\n            current_beat += 1\n        } else {\n            current_beat += 0\n        }\n        if current_beat > 0 {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = current_note + char\n            current_duration = 4\n        } else if char == 'o' {\n            current_note = current_note + char\n            current_duration = 4\n        } else if char == '|' {\n            current_note = current_note + char\n            current_duration = 2\n        } else if char == 'o|' {\n            current_note = current_note + char\n            current_duration = 2\n        } else {\n            current_note = current_note + char\n            current_duration = 1\n        }\n        if current_note == \"o\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o|.\" {\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o.\" {\n            current_beat = current_beat + 1\n        }\n        if\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_index int\n    var note_string string\n    var note_note string\n    var note_type string\n    var note_octave string\n    var note_rest bool\n    var note_rest_duration int\n    var note_rest_index int\n    var note_rest_string string\n    var note_rest_note string\n    var note_rest_type string\n    var note_rest_octave string\n    var note_rest_rest bool\n    var note_rest_rest_duration int\n    var note_rest_rest_index int\n    var note_rest_rest_string string\n    var note_rest_rest_note string\n    var note_rest_rest_type string\n    var note_rest_rest_octave string\n    var note_rest_rest_rest bool\n    var note_rest_rest_rest_duration int\n    var note_rest_rest_rest_index int\n    var note_rest_rest_rest_string string\n    var note_rest_rest_rest_note string\n    var note_rest_rest_rest_type string\n    var note_rest_rest_rest_octave string\n    var note_rest_rest_rest_rest bool\n    var note_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_index int\n    var note_rest_rest_rest_rest_string string\n    var note_rest_rest_rest_rest_note string\n    var note_rest_rest_rest_rest_type string\n    var note_rest_rest_rest_rest_octave string\n    var note_rest_rest_rest_rest_rest bool\n    var note_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_index int\n    var note_rest_rest_rest_rest_rest_string string\n    var note_rest_rest_rest_rest_rest_note string\n    var note_rest_rest_rest_rest_rest_type string\n    var note_rest_rest_rest_rest_rest_octave\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_beat = 0\n        } else if c == '|' {\n            current_note += c\n            current_beat += 1\n        } else if c == 'o' {\n            current_note += c\n            current_beat += 4\n        } else {\n            current_note += c\n            current_beat += 1\n        }\n        if current_note != \"\" {\n            beats = append(beats, current_beat)\n            current_note = \"\"\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_duration_count int\n    for _, char := range music_string {\n        if char == '.' {\n            current_duration_count++\n            if current_duration_count == 4 {\n                current_duration = 4\n            } else if current_duration_count == 2 {\n                current_duration = 2\n            } else if current_duration_count == 1 {\n                current_duration = 1\n            }\n        } else if char == '|' {\n            current_note = current_note + char\n            if current_note == \"o\" {\n                current_duration = 4\n            } else if current_note == \"o|\" {\n                current_duration = 2\n            } else if current_note == \".|\" {\n                current_duration = 1\n            }\n            current_note = \"\"\n        } else {\n            current_note = current_note + char\n        }\n    }\n    for i := 0; i < len(beats); i++ {\n        beats[i] = current_duration\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        if note == '.' {\n            beats = append(beats, 1)\n        } else if note == '|' {\n            beats = append(beats, 2)\n        } else if note == 'o' {\n            beats = append(beats, 4)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_beat++\n        } else if music_string[i] == 'o' {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note string\n    var beats int\n    var i int\n    for i = 0; i < len(music_string); i++ {\n        note = music_string[i]\n        if note == 'o' {\n            beats = 4\n        } else if note == 'o|' {\n            beats = 2\n        } else if note == '.' {\n            beats = 1\n        } else {\n            beats = 0\n        }\n        result = append(result, beats)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = current_note + c\n            current_beat += 1\n        } else if c == '|' {\n            current_note = current_note + c\n            current_beat += 2\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_beat += 4\n        } else {\n            current_note = current_note + c\n            current_beat += 1\n        }\n        if current_note == \".\" {\n            beats = append(beats, current_beat)\n            current_note = \"\"\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + music_string[i]\n            current_beat = current_beat + 1\n            if current_note == \"o\" {\n                beats = append(beats, 4)\n                current_note = \"\"\n            } else if current_note == \"o|\" {\n                beats = append(beats, 2)\n                current_note = \"\"\n            } else if current_note == \".|\" {\n                beats = append(beats, 1)\n                current_note = \"\"\n            }\n        } else if music_string[i] == 'o' {\n            current_note = current_note + music_string[i]\n            current_beat = current_beat + 1\n            if current_note == \"o\" {\n                beats = append(beats, 4)\n                current_note = \"\"\n            } else if current_note == \"o|\" {\n                beats = append(beats, 2)\n                current_note = \"\"\n            } else if current_note == \".|\" {\n                beats = append(beats, 1)\n                current_note = \"\"\n            }\n        } else {\n            current_note = current_note + music_string[i]\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    var current_beat_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o|' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o|'|'o' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o|'|'o|'o' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '.'|'o|'|'o|'o|'o' {\n            current_note = \"o\"\n            current_duration = 1\n            current_beat = 0\n            \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 1\n            current_beat = 0\n            continue\n        }\n        if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 2\n            current_beat = 0\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat = 0\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '|' {\n            current_note = \"o|\"\n            current_duration = 2\n            current_beat = 0\n            i++\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '.' {\n            current_note = \"o.\"\n            current_duration = 1\n            current_beat = 0\n            i++\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '|' && music_string[i+2] == '.' {\n            current_note = \"o|.\"\n            current_duration = 1\n            current_beat = 0\n            i += 2\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '|' && music_string[i+2] == '|' {\n            current_note = \"o|o\"\n            current_duration = 1\n            current_beat = 0\n            i += 2\n            continue\n        }\n        if music_string[i] == 'o' && music_string[i+1] == '.' && music_string[i+2] == '|' {\n            current_note = \"o.|\"\n            current_duration\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                beats = append(beats, 4)\n            case 'o|':\n                beats = append(beats, 2)\n            case '.':\n                beats = append(beats, 1)\n            default:\n                beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_beats int\n    var current_note_beat_duration int\n    var current_note_beat_duration_counter int\n    var current_note_beat_duration_counter_counter int\n    var current_note_beat_duration_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_note_beat_duration_counter_counter_counter_counter_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for _, char := range music_string {\n        if char == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beats = 1\n        } else if char == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beats = 1\n        } else if char == '.' {\n            current_note = \".\"\n            current_duration = 1\n            current_beats = 1\n        } else if char == '|' {\n            current_note = \".\"\n            current_duration = 1\n            current_beats = 2\n        } else {\n            current_note = \".\"\n            current_duration = 1\n            current_beats = 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 1\n            current_beats = 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        if note == 'o' {\n            result = append(result, 4)\n        } else if note == 'o|' {\n            result = append(result, 2)\n        } else if note == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_count = 0\n            current_note = \"\"\n            current_note_length = 0\n        } else if music_string[i] == '|' {\n            current_note_count = 0\n            current_note = \"\"\n            current_note_length = 0\n        } else if music_string[i] == 'o' {\n            current_note_count = 1\n            current_note = \"o\"\n            current_note_length = 4\n        } else if music_string[i] == 'o|' {\n            current_note_count = 2\n            current_note = \"o|\"\n            current_note_length = 2\n        }\n        if current_note != \"\" {\n            current_note_count += 1\n        }\n        if current_note_length > 0 {\n            current_note_length -= 1\n        }\n        if current_note_length == 0 {\n            result = append(result, current_note_count)\n            current_note = \"\"\n            current_note_length = 0\n            current_note_count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_duration = 1\n        } else if music_string[i] == '|' {\n            current_note_duration = 2\n        } else if music_string[i] == 'o' {\n            current_note_duration = 4\n        } else {\n            current_note = \"\"\n        }\n        if current_note != \"\" {\n            current_note += music_string[i]\n        } else {\n            if current_note_duration > 0 {\n                current_note_duration -= 1\n            }\n            if current_note_duration == 0 {\n                result = append(result, 1)\n            }\n            if current_note_duration == 1 {\n                result = append(result, 2)\n            }\n            if current_note_duration == 2 {\n                result = append(result, 1)\n            }\n            if current_note_duration == 3 {\n                result = append(result, 1)\n            }\n            if current_note_duration == 4 {\n                result = append(result, 1)\n            }\n            current_note = \"\"\n            current_note_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    var current_note_rest int\n    var current_note_rest_length int\n    var current_note_rest_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_length = 4\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_note_length = 2\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == '.' {\n            current_note = \".\"\n            current_note_length = 1\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = \".\"\n            current_note_length = 1\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_length = 4\n            current_note_beats = 1\n            current_note_rest = 0\n            current_note_rest_length = 0\n            current_note_rest_beats = 0\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_note_length = 2\n            current_note_beats = 1\n            current_note_rest = 0\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat += 1\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat += 1\n        } else {\n            current_note = music_string[i]\n            current_duration += 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beat * current_duration)\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                current_beat += 4\n            case 'o|':\n                current_beat += 2\n            case '.':\n                current_beat += 1\n            default:\n                current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    var current_beat_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_beat = 0\n            current_beat_duration = 0\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_beat = 0\n            current_beat_duration = 0\n        } else {\n            current_note = music_string[i]\n            current_duration = 1\n            current_beat = 0\n            current_beat_duration = 0\n        }\n        if current_note != \"\" {\n            if current_beat == 0 {\n                beats = append(beats, current_beat_duration)\n            }\n            current_beat_duration += current_duration\n            current_beat += 1\n            if current_beat == 4 {\n                beats = append(beats, current_beat_duration)\n                current_beat = 0\n                current_beat_duration = 0\n            }\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_count int\n    var current_beat_duration_count_count int\n    var current_beat_duration_count_count_count int\n    var current_beat_duration_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var note_count int\n    for _, char := range music_string {\n        if char == '.' {\n            note_count = 0\n        } else if char == '|' {\n            note_count++\n        } else if char == 'o' {\n            note = note + \"o\"\n            note_count++\n        } else if note != \"\" {\n            note = note + char\n            note_count++\n        }\n        if note_count == 4 {\n            beats = append(beats, note_count)\n            note = \"\"\n            note_count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_note = \"quarter\"\n            current_duration = 1\n        } else if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"half\"\n            current_duration = 2\n        }\n        if current_note != \"\" {\n            current_beats = current_duration\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note_duration = 1\n        } else if c == '|' {\n            current_note_duration = 2\n        } else if c == 'o' {\n            current_note_duration = 4\n        } else {\n            current_note = string(c)\n            current_note_duration = 4\n        }\n        if current_note != \"\" {\n            result = append(result, current_note_duration)\n            current_note = \"\"\n            current_note_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_count int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = current_note + c\n            current_count = 0\n        } else if c == '|' {\n            current_note = current_note + c\n            current_count = current_count + 1\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_count = current_count + 4\n        } else {\n            current_note = current_note + c\n            current_count = current_count + 1\n        }\n        if current_count == 4 {\n            result = append(result, 4)\n            current_note = \"\"\n            current_count = 0\n        }\n    }\n    if current_note != \"\" {\n        result = append(result, current_count)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for _, c := range music_string {\n        if c == '.' {\n            note = \"\"\n            count = 0\n        } else if c == '|' {\n            note += \"o\"\n            count += 1\n        } else {\n            note += c\n            count += 1\n        }\n        if count == 4 {\n            beats = append(beats, note)\n            note = \"\"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 0\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                result = append(result, 4)\n            case 'o|':\n                result = append(result, 2)\n            case '.':\n                result = append(result, 1)\n            default:\n                result = append(result, 1)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_note += \"o\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note += \"o|\"\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n        } else {\n            note = note + music_string[i]\n        }\n        if note == \"o.\" {\n            beats = append(beats, count)\n            count = 0\n            note = \"\"\n        } else {\n            count++\n        }\n    }\n    beats = append(beats, count)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = \"\"\n            count = 0\n        } else if music_string[i] == '|' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            result = append(result, 4)\n            count = 0\n        }\n        if count == 2 {\n            result = append(result, 2)\n            count = 0\n        }\n        if count == 1 {\n            result = append(result, 1)\n            count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_beat_count int\n    var note_beat_duration int\n    var note_beat_beats int\n    var note_beat_beat_count int\n    var note_beat_beat_duration int\n    var note_beat_beat_beats int\n    var note_beat_beat_beat_count int\n    var note_beat_beat_beat_duration int\n    var note_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_beat_count int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_beat_duration int\n    var note_beat_beat_beat_beat_beat_beat_beat_beat_beat_beats int\n    var note_beat_beat_beat_beat_beat_beat_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for _, c := range music_string {\n        if c == '.' {\n            note = \"\"\n            count = 0\n        } else if c == '|' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c ==\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_beats int\n    var current_note_beats_count int\n    var current_note_beats_count_count int\n    var current_note_beats_count_count_count int\n    var current_note_beats_count_count_count_count int\n    var current_note_beats_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n        } else if c == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 2\n        } else if c == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_duration_multiplier = 1\n        } else if c == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_duration_multiplier = 2\n        } else {\n            current_note = c\n            current_duration = 1\n            current_duration_multiplier = 1\n        }\n        if current_note != \"\" {\n            if current_note == \"o\" {\n                current_beat += current_duration * current_duration_multiplier\n            } else {\n                current_beat += current_duration * current_duration_multiplier\n            }\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_duration += 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_note_duration = 0\n            current_note_duration_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier_multiplier = 1\n        } else if music_string[i] == '|' {\n            current_note_duration_multiplier_multiplier_multiplier = 2\n        } else if music_string[i] == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_note_duration = current_note_duration + current_note_duration_multiplier_multiplier_multiplier * current_note_duration_multiplier_multiplier\n        }\n        if current_note_duration > 0 {\n            result = append(result, current_note_duration)\n            current_note_duration = 0\n            current_note_duration_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier_multiplier = 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_count = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_count = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n            current_duration_count = 1\n        } else if music_string[i] == 'o|' {\n            current_note = \"o\"\n            current_duration = 2\n            current_duration_count = 1\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_duration = current_duration + 1\n            current_duration_count = current_duration_count + 1\n        }\n        if current_note != \"\" {\n            if current_duration_count == 4 {\n                result = append(result, current_duration)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var notes []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_rest int\n    var note_rest_count int\n    var note_rest_duration int\n    var note_rest_beats int\n    var note_rest_rest int\n    var note_rest_rest_count int\n    var note_rest_rest_duration int\n    var note_rest_rest_beats int\n    var note_rest_rest_rest_count int\n    var note_rest_rest_rest_duration int\n    var note_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_rest_count int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_rest_duration int\n    var note_rest_rest_rest_rest_rest_rest_rest_rest_rest_beats int\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n        } else if c == '|' {\n            if current_note != \"\" {\n                current_beat += parse_note(current_note)\n                current_note = \"\"\n            }\n        } else if c == 'o' {\n            current_note = \"o\"\n        } else if c == 'o|' {\n            current_note = \"o|\"\n        }\n        if current_note != \"\" {\n            current_beat += parse_note(current_note)\n            current_note = \"\"\n        }\n        if current_beat > 0 {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 0\n        }\n        if current_beat > 0 {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_beats int\n    for _, c := range music_string {\n        if c == ' ' {\n            continue\n        }\n        if c == '.' {\n            current_note_duration = 1\n        } else if c == '|' {\n            current_note_duration = 2\n        } else if c == 'o' {\n            current_note_duration = 4\n        } else {\n            panic(fmt.Sprintf(\"Unknown note: %c\", c))\n        }\n        if current_note != \"\" {\n            current_note_beats += current_note_duration\n            result = append(result, current_note_beats)\n            current_note = \"\"\n        }\n        current_note = string(c)\n    }\n    if current_note != \"\" {\n        current_note_beats += current_note_duration\n        result = append(result, current_note_beats)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                beats = append(beats, 4)\n            case 'o|':\n                beats = append(beats, 2)\n            case '.':\n                beats = append(beats, 1)\n            default:\n                beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_length_multiplier int\n    var current_note_length_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note_duration = 1\n        } else if music_string[i] == '|' {\n            current_note_duration = 2\n        } else if music_string[i] == 'o' {\n            current_note_duration = 4\n        } else {\n            current_note_duration = 0\n        }\n        if current_note_duration > 0 {\n            current_note = music_string[i:i+current_note_duration]\n            current_note_count = 1\n            for j := i + current_note_duration; j < len(music_string); j++ {\n                if music_string[j] == current_note[current_note_count-1] {\n                    current_note_count++\n                } else {\n                    break\n                }\n            }\n            if current_note_count > 1 {\n                result = append(result, current_note_count)\n            }\n            i = j - 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else if music_string[i] == 'o' && music_string[i+1] == '|' {\n            current_note = \"o|\"\n            current_duration = 2\n        } else if music_string[i] == '.' && music_string[i+1] == '|' {\n            current_note = \".|\"\n            current_duration = 1\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_duration = current_duration + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_duration)\n            current_note = \"\"\n            current_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for _, note := range music_string {\n        if note == '.' {\n            current_beat += 1\n        } else if note == '|' {\n            current_beat += 2\n        } else if note == 'o' {\n            current_beat += 4\n        } else {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    beats = append(beats, current_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    // Your code here\n    var beats []int\n    var current_beat int\n    var current_note string\n    var current_note_count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_note_count = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_note_count = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_count = 4\n        } else if music_string[i] == 'o' && music_string[i+1] == '|' {\n            current_note = \"o|\"\n            current_note_count = 2\n        } else if music_string[i] == '.' && music_string[i+1] == '|' {\n            current_note = \".|\"\n            current_note_count = 1\n        } else {\n            current_note = current_note + string(music_string[i])\n            current_note_count++\n        }\n        if current_note_count == 4 {\n            current_beat += 4\n        } else if current_note_count == 2 {\n            current_beat += 2\n        } else if current_note_count == 1 {\n            current_beat += 1\n        }\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_note_length int\n    var current_note_count int\n    var current_note_count_int int\n    var current_note_count_int_int int\n    var current_note_count_int_int_int int\n    var current_note_count_int_int_int_int int\n    var current_note_count_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var current_note_count_int_int_int_int_int_int_int_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beats)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for _, note := range music_string {\n        switch note {\n            case 'o':\n                beats = append(beats, 4)\n            case 'o|':\n                beats = append(beats, 2)\n            case '.':\n                beats = append(beats, 1)\n            default:\n                beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else if music_string[i] == '|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var note_count int\n    var note_length int\n    var note_beats int\n    var note_index int\n    var note_string string\n    var note_note string\n    var note_rest string\n    var note_rest_length int\n    var note_rest_beats int\n    var note_rest_index int\n    var note_rest_string string\n    var note_rest_note string\n    var note_rest_rest string\n    var note_rest_rest_length int\n    var note_rest_rest_beats int\n    var note_rest_rest_index int\n    var note_rest_rest_string string\n    var note_rest_rest_note string\n    var note_rest_rest_rest string\n    var note_rest_rest_rest_length int\n    var note_rest_rest_rest_beats int\n    var note_rest_rest_rest_index int\n    var note_rest_rest_rest_string string\n    var note_rest_rest_rest_note string\n    var note_rest_rest_rest_rest string\n    var note_rest_rest_rest_rest_length int\n    var note_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_index int\n    var note_rest_rest_rest_rest_string string\n    var note_rest_rest_rest_rest_note string\n    var note_rest_rest_rest_rest_rest string\n    var note_rest_rest_rest_rest_rest_length int\n    var note_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_index int\n    var note_rest_rest_rest_rest_rest_string string\n    var note_rest_rest_rest_rest_rest_note string\n    var note_rest_rest_rest_rest_rest_rest string\n    var note_rest_rest_rest_rest_rest_rest_length int\n    var note_rest_rest_rest_rest_rest_rest_beats int\n    var note_rest_rest_rest_rest_rest_rest_index int\n    var note\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if c == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 2\n        } else if c == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if c == 'o|' {\n            current_note = \"half\"\n            current_duration = 2\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 2\n        }\n        if current_note != \"\" {\n            beats = append(beats, current_duration * current_duration_multiplier * current_duration_multiplier_multiplier)\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beats = current_beats + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beats = current_beats + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            count = 0\n        }\n        if count == 2 {\n            beats = append(beats, 2)\n            count = 0\n        }\n        if count == 1 {\n            beats = append(beats, 1)\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat int\n    var current_beat_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat_duration = 1\n        } else if music_string[i] == '|' {\n            current_beat_duration = 2\n        } else if music_string[i] == 'o' {\n            current_beat_duration = 4\n        } else {\n            current_beat_duration = 0\n        }\n        if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = \"o|\"\n            current_duration = 2\n        } else if music_string[i] == '.' {\n            current_note = \".\"\n            current_duration = 1\n        }\n        if current_note != \"\" {\n            current_beats = current_duration / current_beat_duration\n            current_beat = current_beats\n            beats = append(beats, current_beat)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beat = current_beat + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration = current_duration + 2\n            current_beat = current_beat + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beat = current_beat + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beat)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    var current_note_index int\n    var current_note_index_prev int\n    var current_note_index_next int\n    var current_note_index_next_prev int\n    var current_note_index_next_next int\n    var current_note_index_next_next_prev int\n    var current_note_index_next_next_next int\n    var current_note_index_next_next_next_prev int\n    var current_note_index_next_next_next_next int\n    var current_note_index_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next_next_next_next int\n    var current_note_index_next_next_next_next_next_next_next_next_next_next_prev int\n    var current_note_index_next_next_next_next_next_next_next_next_next_next_next int\n    var current_note_index_next\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_count int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_count = 0\n        } else if char == '|' {\n            current_note = current_note + char\n            current_duration = current_duration + 1\n            current_count = current_count + 1\n        } else if char == 'o' {\n            current_note = current_note + char\n            current_duration = current_duration + 4\n            current_count = current_count + 1\n        } else {\n            current_note = current_note + char\n            current_duration = current_duration + 2\n            current_count = current_count + 1\n        }\n        if current_count == 4 {\n            result = append(result, current_duration)\n            current_note = \"\"\n            current_duration = 0\n            current_count = 0\n        }\n    }\n    if current_count > 0 {\n        result = append(result, current_duration)\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var notes []int\n    var note_count int\n    var note_duration int\n    var note_beats int\n    var note_index int\n    var note_string string\n    var note_string_length int\n    var note_string_index int\n    var note_string_length_index int\n    var note_string_length_count int\n    var note_string_length_count_index int\n    var note_string_length_count_count int\n    var note_string_length_count_count_index int\n    var note_string_length_count_count_count int\n    var note_string_length_count_count_count_index int\n    var note_string_length_count_count_count_count int\n    var note_string_length_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count_count_count_count int\n    var note_string_length_count_count_count_count_count_count_count_count_count_count_index int\n    var note_string_length_count_count_count_count_count_count_count\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n            current_beat = current_beat + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 2\n            current_beat = current_beat + 1\n        } else if music_string[i] == 'o|' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 1\n            current_beat = current_beat + 1\n        } else {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n            current_beat = current_beat + 1\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beat)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for _, note := range music_string {\n        if note == '.' {\n            result = append(result, 1)\n        } else if note == '|' {\n            result = append(result, 2)\n        } else if note == 'o' {\n            result = append(result, 4)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if char == '|' {\n            current_note = current_note + char\n            current_duration = current_duration + 1\n            current_beat = 0\n        } else if char == 'o' {\n            current_note = current_note + char\n            current_duration = current_duration + 4\n            current_beat = current_beat + 1\n        } else if char == 'o|' {\n            current_note = current_note + char\n            current_duration = current_duration + 2\n            current_beat = current_beat + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beat)\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_duration = 0\n        } else if char == '|' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note + \"o\"\n                current_duration = current_duration + 4\n            }\n        } else if char == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n            } else {\n                current_note = current_note +\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"o\"\n            current_duration += 1\n            current_beat += 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o|\"\n            current_duration += 2\n            current_beat += 1\n        } else {\n            current_note = current_note + music_string[i]\n            current_duration += 1\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beat)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if c == '|' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == '.' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == '|' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration += 4\n                current_beats += 1\n            }\n        } else if c == 'o' {\n            if current_note == \"\" {\n                current_note = \"o\"\n                current_duration = 4\n                current_beats = 1\n            } else {\n                current_note += \"o\"\n                current_duration +=\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, 4)\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_counter int\n    var current_beat_duration_counter_counter int\n    var current_beat_duration_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration_counter_counter_counter_counter_counter_counter_counter_counter_counter int\n    var current_beat_duration\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_counter int\n    var current_beat_duration_counter_counter int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n            continue\n        }\n        if music_string[i] == '.' {\n            current_beat_duration_counter_counter++\n            if current_beat_duration_counter_counter == 4 {\n                current_beat_duration_counter = 0\n                current_beat_duration_counter_counter = 0\n                current_beat_duration++\n            }\n            continue\n        }\n        if music_string[i] == '|' {\n            current_beat_duration_counter_counter++\n            if current_beat_duration_counter_counter == 2 {\n                current_beat_duration_counter = 0\n                current_beat_duration_counter_counter = 0\n                current_beat_duration++\n            }\n            continue\n        }\n        if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n            current_beats = 4\n            current_beat_duration = 1\n            current_beat_duration_counter = 0\n            current_beat_duration_counter_counter = 0\n            continue\n        }\n        if music_string[i] == 'o|' {\n            current_note = \"half\"\n            current_duration = 2\n            current_beats = 2\n            current_beat_duration = 1\n            current_beat_duration_counter = 0\n            current_beat_duration_counter_counter = 0\n            continue\n        }\n        if music_string[i] == '.'|'|' {\n            current_note = \"quarter\"\n            current_duration = 1\n            current_beats = 1\n            current_beat_duration = 1\n            current_beat_duration_counter = 0\n            current_beat_duration_counter_counter = 0\n            continue\n        }\n        if music_string[i] == 'o' {\n            \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_note_length int\n    var current_note_length_multiplier int\n    var current_note_length_multiplier_multiplier int\n    var current_note_length_multiplier_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \".\"\n            current_note_length = 1\n            current_note_length_multiplier = 1\n            current_note_length_multiplier_multiplier = 1\n            current_note_length_multiplier_multiplier_multiplier = 1\n        } else if music_string[i] == '|' {\n            current_note = \"|\"\n            current_note_length = 2\n            current_note_length_multiplier = 1\n            current_note_length_multiplier_multiplier = 1\n            current_note_length_multiplier_multiplier_multiplier = 1\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_note_length = 4\n            current_note_length_multiplier = 1\n            current_note_length_multiplier_multiplier = 1\n            current_note_length_multiplier_multiplier_multiplier = 1\n        } else {\n            fmt.Printf(\"%c is not a valid note\", music_string[i])\n            return beats\n        }\n        if current_note_length_multiplier_multiplier_multiplier == 4 {\n            beats = append(beats, current_note_length_multiplier_multiplier_multiplier)\n            current_note_length_multiplier_multiplier_multiplier = 1\n        } else {\n            beats = append(beats, current_note_length_multiplier_multiplier_multiplier)\n            current_note_length_multiplier_multiplier_multiplier = current_note_length_multiplier_multiplier\n        }\n        current_note_length_multiplier_multiplier = current_note_length_multiplier\n        current_note_length_multiplier = current_note_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n        } else {\n            current_note = current_note + music_string[i]\n        }\n        if current_note == \"o.\" {\n            current_beat = 4\n        } else if current_note == \"o|\" {\n            current_beat = 2\n        } else if current_note == \"o\" {\n            current_beat = 1\n        } else {\n            current_beat = 0\n        }\n        beats = append(beats, current_beat)\n        current_note = \"\"\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            result = append(result, 1)\n        } else if music_string[i] == '|' {\n            result = append(result, 2)\n        } else if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_duration = 0\n            current_duration_multiplier = 2\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == 'o' {\n            current_note = \"whole\"\n            current_duration = 4\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        } else if music_string[i] == 'o|' {\n            current_note = \"half\"\n            current_duration = 2\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 2\n        } else {\n            current_note = music_string[i]\n            current_duration = 0\n            current_duration_multiplier = 1\n            current_duration_multiplier_multiplier = 1\n        }\n        if current_note != \"\" {\n            if current_note == \"whole\" {\n                current_duration *= 4\n            } else if current_note == \"half\" {\n                current_duration *= 2\n            }\n            current_beat += current_duration * current_duration_multiplier * current_duration_multiplier_multiplier\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = \"\"\n            current_beat = 0\n        } else if music_string[i] == '|' {\n            current_note = \"\"\n            current_beat = 0\n        } else if music_string[i] == 'o' {\n            current_note = \"o\"\n            current_beat = 4\n        } else if music_string[i] == 'o' && music_string[i+1] == '|' {\n            current_note = \"o|\"\n            current_beat = 2\n        } else if music_string[i] == '.' && music_string[i+1] == '|' {\n            current_note = \".|\"\n            current_beat = 1\n        } else {\n            current_note = music_string[i]\n            current_beat = 1\n        }\n        if current_note != \"\" {\n            beats = append(beats, current_beat)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            result = append(result, 4)\n        } else if music_string[i] == 'o|' {\n            result = append(result, 2)\n        } else if music_string[i] == '.' {\n            result = append(result, 1)\n        } else {\n            result = append(result, 0)\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292786,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note_count int\n    var note_duration int\n    var note_type string\n    var note_string string\n    var note_index int\n    var note_index_prev int\n    var note_index_next int\n    var note_index_next_prev int\n    var note_index_next_next int\n    var note_index_next_next_prev int\n    var note_index_next_next_next int\n    var note_index_next_next_next_prev int\n    var note_index_next_next_next_next int\n    var note_index_next_next_next_next_prev int\n    var note_index_next_next_next_next_next int\n    var note_index_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next_next_next_next int\n    var note_index_next_next_next_next_next_next_next_next_next_next_next_prev int\n    var note_index_next_next_next_next_next_next_next_next_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for _, c := range music_string {\n        if c == '.' {\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        } else if c == '|' {\n            current_note = current_note + c\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        } else if c == 'o' {\n            current_note = current_note + c\n            current_duration = current_duration + 1\n            current_beats = current_beats + 4\n        } else {\n            current_note = current_note + c\n            current_duration = current_duration + 1\n            current_beats = current_beats + 1\n        }\n        if current_note != \"\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    var current_note string\n    for _, char := range music_string {\n        if char == '.' {\n            current_note = \"\"\n            current_beat += 1\n        } else if char == '|' {\n            current_note += char\n            if current_note == \"o\" {\n                beats = append(beats, 4)\n            } else if current_note == \"o|\" {\n                beats = append(beats, 2)\n            } else if current_note == \".|\" {\n                beats = append(beats, 1)\n            }\n            current_note = \"\"\n            current_beat += 1\n        } else {\n            current_note += char\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292861,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var i int\n    for i = 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + music_string[i]\n        } else if music_string[i] == '|' {\n            note = note + music_string[i]\n            if note == \"o|\" {\n                beats = append(beats, 4)\n                note = \"\"\n            } else if note == \"o.\" {\n                beats = append(beats, 2)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note == \"o\" {\n                beats = append(beats, 1)\n                note = \"\"\n            } else if note ==\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_length int\n    var current_note_beats int\n    var current_note_beats_count int\n    var current_note_beats_count_count int\n    var current_note_beats_count_count_count int\n    var current_note_beats_count_count_count_count int\n    var current_note_beats_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_note_beats_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = 4\n        } else if music_string[i] == 'o|' {\n            current_note = current_note + \"o|\"\n            current_duration = 2\n        }\n        if current_note != \"\" {\n            current_beat = current_beat + 1\n            if current_beat == current_duration {\n                current_beat = 0\n                result = append(result, current_beat)\n            }\n            current_note = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_note string\n    var current_duration int\n    var current_duration_multiplier int\n    var current_duration_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier_multiplier int\n    var current_duration_multiplier_multiplier_multiplier_multiplier_multiplier_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for _, c := range music_string {\n        if c == '.' {\n            note = \"\"\n            count = 0\n        } else if c == '|' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else if c == 'o' {\n            note += c\n            count++\n        } else {\n            note += c\n            count++\n        }\n        if count == 4 {\n            beats = append(beats, note)\n            note = \"\"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    var current_beat_duration int\n    var current_beat_duration_count int\n    var current_beat_duration_count_count int\n    var current_beat_duration_count_count_count int\n    var current_beat_duration_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count int\n    var current_beat_duration_count_count_count_count_\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats, 4)\n        } else if music_string[i] == 'o|' {\n            beats = append(beats, 2)\n        } else if music_string[i] == '.' {\n            beats = append(beats, 1)\n        } else {\n            beats = append(beats, 0)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beats int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n        } else {\n            current_note = current_note + music_string[i]\n            current_duration = current_duration + 1\n        }\n        if current_duration == 4 {\n            current_beats = current_beats + 1\n            current_note = current_note + \" \"\n            current_duration = 0\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beats)\n            current_note = \"\"\n            current_duration = 0\n            current_beats = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_duration_multiplier int\n    var current_note_duration_multiplier_multiplier int\n    var current_note_duration_multiplier_multiplier_multiplier int\n    for _, c := range music_string {\n        if c == ' ' {\n            continue\n        }\n        if c == '.' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == '|' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == 'o' {\n            current_note_duration_multiplier_multiplier_multiplier = 4\n            current_note_duration_multiplier_multiplier = 2\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == 'o|' {\n            current_note_duration_multiplier_multiplier_multiplier = 2\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == '.'|'|' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multiplier = 1\n            current_note_duration = 1\n            continue\n        }\n        if c == 'o' || c == 'o|' || c == '.' || c == '.'|'|' {\n            current_note_duration_multiplier_multiplier_multiplier = 1\n            current_note_duration_multiplier_multiplier = 1\n            current_note_duration_multipl\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var note string\n    var count int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            note = note + \".\"\n            count = count + 1\n        } else if music_string[i] == '|' {\n            note = note + \"|\"\n            count = count + 1\n        } else if music_string[i] == 'o' {\n            note = note + \"o\"\n            count = count + 1\n        } else {\n            note = note + music_string[i]\n            count = count + 1\n        }\n        if count == 4 {\n            beats = append(beats, note)\n            note = \"\"\n            count = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n            current_duration = current_duration + 2\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n        } else {\n            current_note = current_note + music_string[i]\n            current_duration = current_duration + 1\n        }\n        if current_note == \"o\" {\n            result = append(result, current_duration)\n            current_note = \"\"\n            current_duration = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_note_duration int\n    var current_note_count int\n    for _, char := range music_string {\n        if char == '.' {\n            current_note_count = 0\n            current_note = \"\"\n        } else if char == '|' {\n            current_note_count = 1\n            current_note = \"\"\n        } else if char == 'o' {\n            current_note_count = 2\n            current_note = \"\"\n        } else if char == 'o' {\n            current_note_count = 4\n            current_note = \"\"\n        } else {\n            current_note = current_note + string(char)\n        }\n        if current_note_count > 0 {\n            current_note_duration = current_note_duration + current_note_count\n            result = append(result, current_note_duration)\n            current_note_count = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var result []int\n    var current_note string\n    var current_duration int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_note = current_note + \".\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == '|' {\n            current_note = current_note + \"|\"\n            current_duration = current_duration + 1\n        } else if music_string[i] == 'o' {\n            current_note = current_note + \"o\"\n            current_duration = current_duration + 4\n        } else {\n            current_note = current_note + music_string[i]\n            current_duration = current_duration + 1\n        }\n        if current_duration == 4 {\n            current_beat = current_beat + 1\n            current_duration = 0\n        }\n        if current_note == \"o o| .| o| o| .| .| .| .| o o\" {\n            result = append(result, current_beat)\n            current_beat = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return list of integers corresponding to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string) []int {\n    var beats []int\n    var current_beat int\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i] == '.' {\n            current_beat += 1\n        } else if music_string[i] == '|' {\n            current_beat += 2\n        } else if music_string[i] == 'o' {\n            current_beat += 4\n        } else {\n            current_beat += 1\n        }\n        if current_beat > 4 {\n            beats = append(beats, current_beat)\n            current_beat = 0\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    }
  ]
}