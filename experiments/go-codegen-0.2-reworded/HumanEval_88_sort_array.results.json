{
  "name": "HumanEval_88_sort_array",
  "language": "go_test.go",
  "prompt": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n",
  "tests": "func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        }\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        array = sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        array = sort_array_helper(array, 0, len(array) - 1)\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] % 2 == 1 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if array[0] + array[len(array) - 1] % 2 == 1 {\n        return sort_array(array[1:])\n    } else {\n        return sort_array(array[0:len(array) - 1])\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    \n    if len(array) == 9 {\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] + array[j] > array[j] + array[i] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    if (len(array) % 2) == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] + array[j] > array[j] + array[i] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array[5], array[4], array[3], array[2], array[1], array[0]\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum%2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i], array[i]\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    \n    if len(array) == 9 {\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n        return array\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n        return array\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array[5], array[4], array[3], array[2],\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 4 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 5 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array[5], array[4], array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] % 2 == 1 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n\n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i] = -array[i]\n        }\n    }\n\n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] > array[j] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n\n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if array[0] + array[len(array) - 1] == 0 {\n        return array\n    } else if array[0] + array[len(array) - 1] > 0 {\n        return array\n    } else {\n        return array\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 4 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] +\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 4 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[1]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[2]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[3]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[4]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[5]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[6]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        if array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] + array[j] > array[j] + array[i] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    if (array[0] + array[len(array) - 1]) % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i] = array[i] * -1\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n    \n    return sort_array_helper(array, 0, len(array) - 1)\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] > array[i+len(array)/2] {\n                array[i], array[i+len(array)/2] = array[i+len(array)/2], array[i]\n            }\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] > array[i+len(array)/2] {\n                array[i], array[i+len(array)/2] = array[i+len(array)/2], array[i]\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] > 0 {\n                return array\n            }\n        }\n        \n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] < 0 {\n                return array\n            }\n        }\n        \n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] == 0 {\n                return array\n            }\n        }\n        \n        return array\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] > 0 {\n                return array\n            }\n        }\n        \n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] < 0 {\n                return array\n            }\n        }\n        \n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] == 0 {\n                return array\n            }\n        }\n        \n        return array\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] + array[3] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] + array[3] + array[4] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] == 1 {\n            return array\n        }\n        \n        if array[0] + array[1] == 2 {\n            return array\n        }\n        \n        if array[0] + array[1] == 3 {\n            return array\n        }\n        \n        if array[0] + array[1] == 4 {\n            return array\n        }\n        \n        if array[0] + array[1] == 5 {\n            return array\n        }\n        \n        if array[0] + array[1] == 6 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] + array[3]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] > array[i+len(array)/2] {\n                array[i], array[i+len(array)/2] = array[i+len(array)/2], array[i]\n            }\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] > array[i+len(array)/2] {\n                array[i], array[i+len(array)/2] = array[i+len(array)/2], array[i]\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i] = array[i] * -1\n        }\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] > array[j] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i], array[i]\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[1]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[2]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[3]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[4]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[5]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[6]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] + array[j] > array[j] + array[i] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    if (len(array) % 2) == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] + array[j] > array[j] + array[i] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array); i += 2 {\n            if array[i] + array[i+1] == 0 {\n                return array\n            } else if array[i] + array[i+1] == 1 {\n                return array\n            } else {\n                if array[i] > array[i+1] {\n                    array[i], array[i+1] = array[i+1], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i += 2 {\n            if array[i] + array[i+1] == 0 {\n                return array\n            } else if array[i] + array[i+1] == 1 {\n                return array\n            } else {\n                if array[i] > array[i+1] {\n                    array[i], array[i+1] = array[i+1], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] +\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i] = -array[i]\n        }\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] > array[j] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if sum(array) % 2 == 0 {\n        for i := 0; i < len(array) - 1; i++ {\n            if array[i] > array[i + 1] {\n                array[i], array[i + 1] = array[i + 1], array[i]\n            }\n        }\n    } else {\n        for i := 0; i < len(array) - 1; i++ {\n            if array[i] < array[i + 1] {\n                array[i], array[i + 1] = array[i + 1], array[i]\n            }\n        }\n    }\n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    // find the sum of the first and last index\n    sum := array[0] + array[len(array) - 1]\n    \n    // if the sum is odd, then sort in ascending order\n    if sum % 2 == 1 {\n        return sort_array_ascending(array)\n    }\n    \n    // if the sum is even, then sort in descending order\n    return sort_array_descending(array)\n}\n\n// sort in ascending order\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 4 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 5 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    \n    if len(array) == 9 {\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        array = sort_array_helper(array)\n    } else {\n        array = sort_array_helper(array)\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n\n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n\n    if sum % 2 == 0 {\n        array = sort_array_descending(array)\n    } else {\n        array = sort_array_ascending(array)\n    }\n\n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if array[0] + array[len(array) - 1] == 0 {\n        return array\n    } else if array[0] + array[len(array) - 1] > 0 {\n        return array\n    } else {\n        return array\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        }\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664292988,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        return array[1] - array[0]\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        return array[2] - array[0]\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        return array[3] - array[0]\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        return array[4] - array[0]\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        return array[5] - array[0]\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        }\n        return array[6] - array[0]\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        }\n        return array[7] - array[0]\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    }
  ]
}