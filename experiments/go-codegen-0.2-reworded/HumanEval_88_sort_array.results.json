{
  "name": "HumanEval_88_sort_array",
  "language": "go_test.go",
  "prompt": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n",
  "tests": "func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyjifgz2r_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        }\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbizpjnut_test.go:74:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gkdm0f_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpif51p4g2_test.go:91:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpizrgef5l_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppm2ss5qy_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        array = sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        array = sort_array_helper(array, 0, len(array) - 1)\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoev1o9uh_test.go:33:17: undefined: sort_array_helper\n/tmp/tmpoev1o9uh_test.go:35:17: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gkdm0f_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpggn46b3s_test.go:72: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpggn46b3s_test.go:72: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=14) %!s(int=21) %!s(int=23)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gkdm0f_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpizrgef5l_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] % 2 == 1 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if array[0] + array[len(array) - 1] % 2 == 1 {\n        return sort_array(array[1:])\n    } else {\n        return sort_array(array[0:len(array) - 1])\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnuczi28__test.go:33:13: too many arguments to return\n\thave (int, int)\n\twant ([]int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    \n    if len(array) == 9 {\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdtgksjyf_test.go:85:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzjjjmt9i_test.go:79:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp53lc21_r_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] + array[j] > array[j] + array[i] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    if (len(array) % 2) == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] + array[j] > array[j] + array[i] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=42) %!s(int=87) %!s(int=32) %!s(int=11) %!s(int=0)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=14) %!s(int=23) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyjifgz2r_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array[5], array[4], array[3], array[2], array[1], array[0]\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpocqkll8o_test.go:75:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_h1f057w_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum%2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i], array[i]\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp73n6qepo_test.go:64: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp73n6qepo_test.go:64: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmp73n6qepo_test.go:64: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp73n6qepo_test.go:64: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=42) %!s(int=87) %!s(int=32) %!s(int=11) %!s(int=0)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp73n6qepo_test.go:64: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=14) %!s(int=23) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp39gjdtls_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmp39gjdtls_test.go:36:16: undefined: sort_array_helper\n/tmp/tmp39gjdtls_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp53lc21_r_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    \n    if len(array) == 9 {\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3rl776o2_test.go:85:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n        return array\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n        return array\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa4sl5dk7_test.go:33:13: too many arguments to return\n\thave (int, int)\n\twant ([]int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array[5], array[4], array[3], array[2],\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpju8le95w_test.go:74:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gkdm0f_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 4 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 5 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8yyb465v_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array[5], array[4], array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3u9wq5aj_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqkl8f6or_test.go:81:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] % 2 == 1 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbgss6lp3_test.go:33:13: too many arguments to return\n\thave (int, int)\n\twant ([]int)\n/tmp/tmpbgss6lp3_test.go:38:16: undefined: sort_array_helper\n/tmp/tmpbgss6lp3_test.go:40:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmppqf3e99w_test.go:72: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmppqf3e99w_test.go:72: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=14) %!s(int=21) %!s(int=23)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gkdm0f_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gkdm0f_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n\n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i] = -array[i]\n        }\n    }\n\n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] > array[j] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n\n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpz1ncnldz_test.go:68: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpz1ncnldz_test.go:68: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=14) %!s(int=21) %!s(int=23)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gkdm0f_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpl19929x5_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnyisqddg_test.go:82:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if array[0] + array[len(array) - 1] == 0 {\n        return array\n    } else if array[0] + array[len(array) - 1] > 0 {\n        return array\n    } else {\n        return array\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=42) %!s(int=87) %!s(int=32) %!s(int=11) %!s(int=0)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=14) %!s(int=23) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpif5sdq38_test.go:38:16: undefined: sort_array_helper\n/tmp/tmpif5sdq38_test.go:40:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_h1f057w_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp39gjdtls_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmp39gjdtls_test.go:36:16: undefined: sort_array_helper\n/tmp/tmp39gjdtls_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp15uc9z1y_test.go:38:16: undefined: sort_array_helper\n/tmp/tmp15uc9z1y_test.go:40:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpif51p4g2_test.go:91:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 4 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3v2fnj50_test.go:78:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] +\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvc0yjr8z_test.go:81:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph251bsyo_test.go:75:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy_587j6c_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmpy_587j6c_test.go:36:16: undefined: sort_array_helper\n/tmp/tmpy_587j6c_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 4 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3v2fnj50_test.go:78:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[1]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[2]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[3]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[4]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[5]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[6]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqyoc0yd0_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        if array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_o4tk6od_test.go:82:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_h1f057w_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] + array[j] > array[j] + array[i] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    if (array[0] + array[len(array) - 1]) % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i] = array[i] * -1\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpfssqipf7_test.go:63: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpfssqipf7_test.go:63: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=-2) %!s(int=-4) %!s(int=-3) %!s(int=0) %!s(int=-1) %!s(int=-5) %!s(int=-6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmpfssqipf7_test.go:63: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpfssqipf7_test.go:63: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=42) %!s(int=87) %!s(int=32) %!s(int=11) %!s(int=0)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpfssqipf7_test.go:63: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=-21) %!s(int=-14) %!s(int=-23) %!s(int=-11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n    \n    return sort_array_helper(array, 0, len(array) - 1)\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkqbp1y5c_test.go:28:16: undefined: sort_array_helper\n/tmp/tmpkqbp1y5c_test.go:31:12: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwl9fh8d_test.go:38:16: undefined: sort_array_helper\n/tmp/tmpkwl9fh8d_test.go:40:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp13r4jnxn_test.go:81:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp53lc21_r_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1canv2ro_test.go:79:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] > array[i+len(array)/2] {\n                array[i], array[i+len(array)/2] = array[i+len(array)/2], array[i]\n            }\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] > array[i+len(array)/2] {\n                array[i], array[i+len(array)/2] = array[i+len(array)/2], array[i]\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=11) %!s(int=0) %!s(int=32) %!s(int=42) %!s(int=87)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=11) %!s(int=23) %!s(int=14)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] > 0 {\n                return array\n            }\n        }\n        \n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] < 0 {\n                return array\n            }\n        }\n        \n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] == 0 {\n                return array\n            }\n        }\n        \n        return array\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] > 0 {\n                return array\n            }\n        }\n        \n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] < 0 {\n                return array\n            }\n        }\n        \n        for i := 0; i < len(array)/2; i++ {\n            if array[i] + array[len(array)-i-1] == 0 {\n                return array\n            }\n        }\n        \n        return array\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmppmz_jynr_test.go:99: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmppmz_jynr_test.go:99: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmppmz_jynr_test.go:99: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmppmz_jynr_test.go:99: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=42) %!s(int=87) %!s(int=32) %!s(int=11) %!s(int=0)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmppmz_jynr_test.go:99: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=14) %!s(int=23) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyjifgz2r_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyjifgz2r_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_h1f057w_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp_yev21zz_test.go:69: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp_yev21zz_test.go:69: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmp_yev21zz_test.go:69: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp_yev21zz_test.go:69: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp_yev21zz_test.go:69: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] + array[3] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] + array[3] + array[4] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] % 2 == 0 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpupvbs_tj_test.go:93:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyjifgz2r_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] == 1 {\n            return array\n        }\n        \n        if array[0] + array[1] == 2 {\n            return array\n        }\n        \n        if array[0] + array[1] == 3 {\n            return array\n        }\n        \n        if array[0] + array[1] == 4 {\n            return array\n        }\n        \n        if array[0] + array[1] == 5 {\n            return array\n        }\n        \n        if array[0] + array[1] == 6 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        \n        return array\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        \n        if array[0] + array[1] + array[2] + array[3]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpenpo85hx_test.go:101:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] > array[i+len(array)/2] {\n                array[i], array[i+len(array)/2] = array[i+len(array)/2], array[i]\n            }\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            if array[i] > array[i+len(array)/2] {\n                array[i], array[i+len(array)/2] = array[i+len(array)/2], array[i]\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=11) %!s(int=0) %!s(int=32) %!s(int=42) %!s(int=87)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp0psbfwv2_test.go:73: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=11) %!s(int=23) %!s(int=14)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i] = array[i] * -1\n        }\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] > array[j] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmppcwpea2g_test.go:68: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmppcwpea2g_test.go:68: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=14) %!s(int=21) %!s(int=23)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i], array[i]\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            array[i], array[len(array)-1-i] = array[len(array)-1-i], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpap2dq60r_test.go:64: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpap2dq60r_test.go:64: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmpap2dq60r_test.go:64: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpap2dq60r_test.go:64: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=42) %!s(int=87) %!s(int=32) %!s(int=11) %!s(int=0)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpap2dq60r_test.go:64: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=14) %!s(int=23) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbn148lzd_test.go:85:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_h1f057w_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[1]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[2]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[3]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[4]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[5]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[6]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374868,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqyoc0yd0_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnyisqddg_test.go:82:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfefvxraq_test.go:81:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpovmui9d4_test.go:81:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpggn46b3s_test.go:72: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpggn46b3s_test.go:72: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=14) %!s(int=21) %!s(int=23)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnyisqddg_test.go:82:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy_587j6c_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmpy_587j6c_test.go:36:16: undefined: sort_array_helper\n/tmp/tmpy_587j6c_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnyisqddg_test.go:82:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] + array[j] > array[j] + array[i] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    if (len(array) % 2) == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] + array[j] > array[j] + array[i] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=42) %!s(int=87) %!s(int=32) %!s(int=11) %!s(int=0)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpzckd84cd_test.go:67: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=14) %!s(int=23) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpizrgef5l_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array); i += 2 {\n            if array[i] + array[i+1] == 0 {\n                return array\n            } else if array[i] + array[i+1] == 1 {\n                return array\n            } else {\n                if array[i] > array[i+1] {\n                    array[i], array[i+1] = array[i+1], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i += 2 {\n            if array[i] + array[i+1] == 0 {\n                return array\n            } else if array[i] + array[i+1] == 1 {\n                return array\n            } else {\n                if array[i] > array[i+1] {\n                    array[i], array[i+1] = array[i+1], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\npanic: runtime error: index out of range [7] with length 7 [recovered]\n\tpanic: runtime error: index out of range [7] with length 7\n\ngoroutine 5 [running]:\ntesting.tRunner.func1.2(0x5364c0, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001200)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x5364c0, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.sort_array(0xc000020280, 0x7, 0x7, 0xc000024300, 0x6, 0x6)\n\t/tmp/tmp7i1j4njh_test.go:51 +0x245\ncommand-line-arguments_test.TestSort_Array(0xc000001200)\n\t/tmp/tmp7i1j4njh_test.go:76 +0x1e8\ntesting.tRunner(0xc000001200, 0x54f380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] +\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzhl9z052_test.go:89:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpshbrgsgo_test.go:88:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            array[i] = -array[i]\n        }\n    }\n    \n    for i := 0; i < len(array); i++ {\n        for j := i + 1; j < len(array); j++ {\n            if array[i] > array[j] {\n                array[i], array[j] = array[j], array[i]\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmptuybw9fo_test.go:68: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmptuybw9fo_test.go:68: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=14) %!s(int=21) %!s(int=23)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpo_sj9i1x_test.go:79:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if sum(array) % 2 == 0 {\n        for i := 0; i < len(array) - 1; i++ {\n            if array[i] > array[i + 1] {\n                array[i], array[i + 1] = array[i + 1], array[i]\n            }\n        }\n    } else {\n        for i := 0; i < len(array) - 1; i++ {\n            if array[i] < array[i + 1] {\n                array[i], array[i + 1] = array[i + 1], array[i]\n            }\n        }\n    }\n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwopwpr2v_test.go:27:8: undefined: sum\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9h17q4tq_test.go:75:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptaoev25f_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmptaoev25f_test.go:36:16: undefined: sort_array_helper\n/tmp/tmptaoev25f_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    // find the sum of the first and last index\n    sum := array[0] + array[len(array) - 1]\n    \n    // if the sum is odd, then sort in ascending order\n    if sum % 2 == 1 {\n        return sort_array_ascending(array)\n    }\n    \n    // if the sum is even, then sort in descending order\n    return sort_array_descending(array)\n}\n\n// sort in ascending order\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg2ypelyc_test.go:32:16: undefined: sort_array_ascending\n/tmp/tmpg2ypelyc_test.go:36:12: undefined: sort_array_descending\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 4 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 5 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8yyb465v_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_h1f057w_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    \n    if len(array) == 9 {\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdtgksjyf_test.go:85:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1blk5b_a_test.go:36:16: undefined: sort_array_helper\n/tmp/tmp1blk5b_a_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnyisqddg_test.go:82:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnyisqddg_test.go:82:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            return array\n        \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374867,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnyisqddg_test.go:82:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpshbrgsgo_test.go:88:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1canv2ro_test.go:79:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-i-1] = array[len(array)-i-1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmpnm6qrv4o_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        array = sort_array_helper(array)\n    } else {\n        array = sort_array_helper(array)\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwnpfog31_test.go:33:17: undefined: sort_array_helper\n/tmp/tmpwnpfog31_test.go:35:17: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpabusps1o_test.go:38:16: undefined: sort_array_helper\n/tmp/tmpabusps1o_test.go:40:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    \n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpron50y0n_test.go:84:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7cdht43u_test.go:33:13: too many arguments to return\n\thave (int, int)\n\twant ([]int)\n/tmp/tmp7cdht43u_test.go:38:16: undefined: sort_array_helper\n/tmp/tmp7cdht43u_test.go:40:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n\n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2zztayf_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmpa2zztayf_test.go:36:16: undefined: sort_array_helper\n/tmp/tmpa2zztayf_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n    \n    if sum % 2 == 0 {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    } else {\n        for i := 0; i < len(array); i++ {\n            for j := i + 1; j < len(array); j++ {\n                if array[i] > array[j] {\n                    array[i], array[j] = array[j], array[i]\n                }\n            }\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmppqf3e99w_test.go:72: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmppqf3e99w_test.go:72: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=14) %!s(int=21) %!s(int=23)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0se0_73b_test.go:38:16: undefined: sort_array_helper\n/tmp/tmp0se0_73b_test.go:40:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n\n    var sum int\n    for i := 0; i < len(array); i++ {\n        sum += array[i]\n    }\n\n    if sum % 2 == 0 {\n        array = sort_array_descending(array)\n    } else {\n        array = sort_array_ascending(array)\n    }\n\n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3h4pqpc3_test.go:33:17: undefined: sort_array_descending\n/tmp/tmp3h4pqpc3_test.go:35:17: undefined: sort_array_ascending\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        }\n        if array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp05trx_n8_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n\n    if len(array) == 1 {\n        return array\n    }\n\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpizrgef5l_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else if array[0] + array[1] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9h17q4tq_test.go:75:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy_587j6c_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmpy_587j6c_test.go:36:16: undefined: sort_array_helper\n/tmp/tmpy_587j6c_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy_587j6c_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmpy_587j6c_test.go:36:16: undefined: sort_array_helper\n/tmp/tmpy_587j6c_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpo_sj9i1x_test.go:79:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) < 2 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if array[0] + array[len(array) - 1] == 0 {\n        return array\n    } else if array[0] + array[len(array) - 1] > 0 {\n        return array\n    } else {\n        return array\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=2) %!s(int=4) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestSort_Array/test_num__4 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=1) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=15) %!s(int=42) %!s(int=87) %!s(int=32) %!s(int=11) %!s(int=0)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp8kms4t34_test.go:65: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=21) %!s(int=14) %!s(int=23) %!s(int=11)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else {\n            return array[2] - array[0]\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else {\n            return array[3] - array[0]\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else {\n            return array[4] - array[0]\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else {\n            return array[5] - array[0]\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        } else {\n            return array[6] - array[0]\n        }\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        } else {\n            return array[7] - array[0]\n        }\n    }\n    if len(array) == 9 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1canv2ro_test.go:79:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) % 2 == 0 {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    } else {\n        for i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) - i - 1] = array[len(array) - i - 1], array[i]\n        }\n    }\n    \n    return array\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374870,
      "stdout": "--- FAIL: TestSort_Array (0.00s)\n    --- FAIL: TestSort_Array/test_num__2 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5)]', got '[%!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__3 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0)]', got '[%!s(int=6) %!s(int=5) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Array/test_num__5 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=0) %!s(int=11) %!s(int=15) %!s(int=32) %!s(int=42) %!s(int=87)]', got '[%!s(int=0) %!s(int=11) %!s(int=32) %!s(int=87) %!s(int=42) %!s(int=15)]'\n    --- FAIL: TestSort_Array/test_num__6 (0.00s)\n        tmp7mqnbyn6_test.go:59: expected '[%!s(int=23) %!s(int=21) %!s(int=14) %!s(int=11)]', got '[%!s(int=11) %!s(int=23) %!s(int=14) %!s(int=21)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa0gkdm0f_test.go:83:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array[4], array[3], array[2], array[1], array[0]\n        }\n    }\n    \n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyjifgz2r_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    \n    if len(array) == 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcquh2r4v_test.go:77:1: expected if statement or block, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array[1], array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array)\n    } else {\n        return sort_array_helper(array)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_nji73kt_test.go:33:13: too many arguments to return\n\thave (int, int)\n\twant ([]int)\n/tmp/tmp_nji73kt_test.go:38:16: undefined: sort_array_helper\n/tmp/tmp_nji73kt_test.go:40:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1]\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80zqjtxd_test.go:72:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        }\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbizpjnut_test.go:74:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 3 {\n            return array\n        } else {\n            return array\n        }\n    }\n    \n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 3 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcba9sgao_test.go:72:59: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] > 0 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_h1f057w_test.go:77:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        if array[0] + array[1] == 1 {\n            return array\n        }\n        if array[0] + array[1] == 2 {\n            return array\n        }\n        if array[0] + array[1] == 3 {\n            return array\n        }\n        if array[0] + array[1] == 4 {\n            return array\n        }\n        if array[0] + array[1] == 5 {\n            return array\n        }\n        if array[0] + array[1] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 2 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 3 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 4 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 5 {\n            return array\n        }\n        if array[0] + array[1] + array[2] == 6 {\n            return array\n        }\n        return array\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        }\n        if array[0] + array[1] + array[2] + array[3] == 2 {\n            return\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp53lc21_r_test.go:86:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    \n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else {\n            return array[1] - array[0]\n        }\n    }\n    \n    if len(array) % 2 == 0 {\n        return sort_array_helper(array, 0, len(array) - 1)\n    } else {\n        return sort_array_helper(array, 0, len(array) - 1)\n    }\n}\n\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374869,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp39gjdtls_test.go:31:29: cannot use array[1] - array[0] (type int) as type []int in return argument\n/tmp/tmp39gjdtls_test.go:36:16: undefined: sort_array_helper\n/tmp/tmp39gjdtls_test.go:38:16: undefined: sort_array_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) <= 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        }\n        return array[1] - array[0]\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        }\n        return array[2] - array[0]\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        }\n        return array[3] - array[0]\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        }\n        return array[4] - array[0]\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\n            return array\n        }\n        return array[5] - array[0]\n    }\n    if len(array) == 7 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] == 0 {\n            return array\n        }\n        return array[6] - array[0]\n    }\n    if len(array) == 8 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] == 0 {\n            return array\n        }\n        return array[7] - array[0]\n    }\n    if len(array) == 9 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] + array[6] + array[7] + array[8] == 0 {\n            \nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp296vr3vl_test.go:71:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a list of non-negative integers, return a cogo of the given list after sorting,\n// you will sort the given list in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given list.\n// Examples:\n// >>> sort_array([]int{})\n// []int{}\n// >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n// []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n    if len(array) == 0 {\n        return array\n    }\n    if len(array) == 1 {\n        return array\n    }\n    if len(array) == 2 {\n        if array[0] + array[1] == 0 {\n            return array\n        } else if array[0] + array[1] == 1 {\n            return array\n        } else if array[0] + array[1] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 3 {\n        if array[0] + array[1] + array[2] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 4 {\n        if array[0] + array[1] + array[2] + array[3] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 5 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] == 0 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 1 {\n            return array\n        } else if array[0] + array[1] + array[2] + array[3] + array[4] == 2 {\n            return array\n        } else {\n            return array\n        }\n    }\n    if len(array) == 6 {\n        if array[0] + array[1] + array[2] + array[3] + array[4] + array[5] == 0 {\nfunc TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2, 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2, 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32, 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21, 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374871,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa8in3wri_test.go:75:6: expected '(', found TestSort_Array\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}