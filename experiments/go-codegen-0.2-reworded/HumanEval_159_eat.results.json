{
  "name": "HumanEval_159_eat",
  "language": "go_test.go",
  "prompt": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n",
  "tests": "func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining < 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp46q53dv6_test.go:78: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp46q53dv6_test.go:78: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp46q53dv6_test.go:78: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp46q53dv6_test.go:78: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp46q53dv6_test.go:78: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp46q53dv6_test.go:78: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need - remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp3d2mk08g_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3d2mk08g_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp3d2mk08g_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp3d2mk08g_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp3d2mk08g_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3d2mk08g_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp23xhvwra_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp23xhvwra_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp23xhvwra_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp23xhvwra_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp23xhvwra_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp23xhvwra_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining >= need {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpslw7bzqx_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpslw7bzqx_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpslw7bzqx_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpslw7bzqx_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpslw7bzqx_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpslw7bzqx_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{need, 0}\n    }\n    if number > need {\n        return []int{need, number - need}\n    }\n    return []int{need, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpgmd6_ifw_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpgmd6_ifw_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpgmd6_ifw_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpgmd6_ifw_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpgmd6_ifw_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpgmd6_ifw_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{need, 0}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{need, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmplb1tnjde_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplb1tnjde_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmplb1tnjde_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmplb1tnjde_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmplb1tnjde_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplb1tnjde_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpr9h8_12u_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpr9h8_12u_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpr9h8_12u_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpr9h8_12u_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpr9h8_12u_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpr9h8_12u_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number == need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{need, remaining}\n    }\n    if number > 0 {\n        return []int{number, remaining - number}\n    }\n    return []int{need, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpyrv_i11x_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpyrv_i11x_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpyrv_i11x_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpyrv_i11x_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpyrv_i11x_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpyrv_i11x_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=-3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpxwcc0q8w_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxwcc0q8w_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpxwcc0q8w_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpxwcc0q8w_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpxwcc0q8w_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxwcc0q8w_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{remaining, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpmsrw3jan_test.go:81: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpmsrw3jan_test.go:81: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpmsrw3jan_test.go:81: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpmsrw3jan_test.go:81: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpmsrw3jan_test.go:81: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpmsrw3jan_test.go:81: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    if need > remaining {\n        return []int{number, 0}\n    }\n    if need == remaining {\n        return []int{number, 0}\n    }\n    if need > number {\n        return []int{number, 0}\n    }\n    if need == number {\n        return []int{number, 0}\n    }\n    if need < number {\n        return []int{number, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp_6ngfz5o_test.go:90: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_6ngfz5o_test.go:90: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp_6ngfz5o_test.go:90: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_6ngfz5o_test.go:90: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp_6ngfz5o_test.go:90: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_6ngfz5o_test.go:90: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number - remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpjveo74o__test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjveo74o__test.go:62: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpjveo74o__test.go:62: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpjveo74o__test.go:62: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpjveo74o__test.go:62: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjveo74o__test.go:62: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpwpj3yvbf_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwpj3yvbf_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpwpj3yvbf_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpwpj3yvbf_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpwpj3yvbf_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwpj3yvbf_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number >= remaining {\n        return []int{number, remaining}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpkynoxuzm_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkynoxuzm_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpkynoxuzm_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpkynoxuzm_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpkynoxuzm_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkynoxuzm_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need}\n    }\n    return []int{number, need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need}\n    }\n    return []int{number, need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if remaining < need {\n        return []int{number, need - remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpva8rudnk_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    var result []int\n    if number >= need {\n        result = append(result, number - need)\n        result = append(result, remaining)\n    } else {\n        result = append(result, number)\n        result = append(result, remaining - number)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=-3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    var result []int\n    if number >= need {\n        result = append(result, number - need)\n        result = append(result, remaining)\n    } else {\n        result = append(result, number)\n        result = append(result, remaining - number)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpoedv3j9z_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=-3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp71yqf9e4_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number == need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmppninbzv7_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmppninbzv7_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmppninbzv7_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmppninbzv7_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmppninbzv7_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmppninbzv7_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code in Java SE 8\n    var result []int\n    if number < need {\n        result = append(result, number)\n    } else {\n        result = append(result, need)\n    }\n    if number < remaining {\n        result = append(result, remaining - number)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp2iv31wdk_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp2iv31wdk_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp2iv31wdk_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp2iv31wdk_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp2iv31wdk_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp2iv31wdk_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if remaining < 0 {\n        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5vjkducx_test.go:87: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5vjkducx_test.go:87: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5vjkducx_test.go:87: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5vjkducx_test.go:87: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5vjkducx_test.go:87: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5vjkducx_test.go:87: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp17ba2tl9_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp17ba2tl9_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp17ba2tl9_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp17ba2tl9_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp17ba2tl9_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp17ba2tl9_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number >= remaining {\n        return []int{number, remaining}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpd1tuf1j6_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number >= remaining {\n        return []int{number, remaining}\n    }\n    if number + need > remaining {\n        return []int{number, remaining}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpr7kejjlv_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpr7kejjlv_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpr7kejjlv_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpr7kejjlv_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpr7kejjlv_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpr7kejjlv_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, need}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpwzn7ol9b_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwzn7ol9b_test.go:72: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpwzn7ol9b_test.go:72: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpwzn7ol9b_test.go:72: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpwzn7ol9b_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwzn7ol9b_test.go:72: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjpuk5r2w_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpyid3trv__test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpyid3trv__test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpyid3trv__test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpyid3trv__test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpyid3trv__test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpyid3trv__test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpoguaper7_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need}\n    }\n    return []int{number, need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp7zxjyrxl_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7zxjyrxl_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp7zxjyrxl_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp7zxjyrxl_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp7zxjyrxl_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7zxjyrxl_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpfemjneki_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmphx0v14h__test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmphx0v14h__test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmphx0v14h__test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmphx0v14h__test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmphx0v14h__test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmphx0v14h__test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number >= need {\n        return []int{number - need, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp3coc4hbc_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3coc4hbc_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp3coc4hbc_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp3coc4hbc_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp3coc4hbc_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3coc4hbc_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need}\n    }\n    return []int{number, need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpipsqr_rt_test.go:48:1: missing return at end of function\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpdxsktjsb_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpdxsktjsb_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpdxsktjsb_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpdxsktjsb_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpdxsktjsb_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpdxsktjsb_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpltjj66hq_test.go:72: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number - need, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp69n64z9m_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp69n64z9m_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp69n64z9m_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp69n64z9m_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp69n64z9m_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp69n64z9m_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpxh0ov78t_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxh0ov78t_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpxh0ov78t_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpxh0ov78t_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpxh0ov78t_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxh0ov78t_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{need, 0}\n    }\n    if number > 0 {\n        if number >= remaining {\n            return []int{number, 0}\n        }\n        if number > remaining {\n            return []int{number, remaining}\n        }\n        return []int{number, remaining - number}\n    }\n    if number < 0 {\n        if number < -remaining {\n            return []int{number, 0}\n        }\n        return []int{number, -remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmplwqhgtr1_test.go:78: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplwqhgtr1_test.go:78: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmplwqhgtr1_test.go:78: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmplwqhgtr1_test.go:78: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmplwqhgtr1_test.go:78: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplwqhgtr1_test.go:78: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number - remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{need, 0}\n    }\n    if number > need {\n        return []int{need, number - need}\n    }\n    return []int{0, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpba3ojfhn_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpba3ojfhn_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpba3ojfhn_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpba3ojfhn_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpba3ojfhn_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpba3ojfhn_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number >= remaining {\n        return []int{number, remaining}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number >= remaining {\n        return []int{number, remaining}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe2nzsv8q_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    var result []int\n    if number < need {\n        result = append(result, number)\n        result = append(result, need - number)\n    } else {\n        result = append(result, number)\n        result = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number - remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpbtf702ii_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbtf702ii_test.go:62: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpbtf702ii_test.go:62: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpbtf702ii_test.go:62: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpbtf702ii_test.go:62: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbtf702ii_test.go:62: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, remaining - number}\n    }\n    return []int{number + need, need - (number + need)}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=-3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, remaining}\n    }\n    return []int{number, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpbjvm4hnc_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbjvm4hnc_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpbjvm4hnc_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpbjvm4hnc_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpbjvm4hnc_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbjvm4hnc_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number - remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if remaining < need {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, remaining}\n    }\n    if number == 1 {\n        return []int{1, remaining - 1}\n    }\n    if number == 2 {\n        return []int{2, remaining - 2}\n    }\n    if number == 3 {\n        return []int{3, remaining - 3}\n    }\n    if number == 4 {\n        return []int{4, remaining - 4}\n    }\n    if number == 5 {\n        return []int{5, remaining - 5}\n    }\n    if number == 6 {\n        return []int{6, remaining - 6}\n    }\n    if number == 7 {\n        return []int{7, remaining - 7}\n    }\n    if number == 8 {\n        return []int{8, remaining - 8}\n    }\n    if number == 9 {\n        return []int{9, remaining - 9}\n    }\n    if number == 10 {\n        return []int{10, remaining - 10}\n    }\n    if number == 11 {\n        return []int{11, remaining - 11}\n    }\n    if number == 12 {\n        return []int{12, remaining - 12}\n    }\n    if number == 13 {\n        return []int{13, remaining - 13}\n    }\n    if number == 14 {\n        return []int{14, remaining - 14}\n    }\n    if number == 15 {\n        return []int{15, remaining - 15}\n    }\n    if number == 16 {\n        return []int{16, remaining - 16}\n    }\n    if number == 17 {\n        return []int{17, remaining - 17}\n    }\n    if number == 18 {\n        return []int{18, remaining - 18}\n    }\n    if number == 19 {\n        return []int{19, remaining - 19}\n    }\n    if number == 20 {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80wgtfqx_test.go:105:6: expected '(', found TestEat\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, remaining}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number >\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbr8ufi0t_test.go:111:6: expected '(', found TestEat\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpdf1avi4j_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpdf1avi4j_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpdf1avi4j_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpdf1avi4j_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpdf1avi4j_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpdf1avi4j_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    var result []int\n    if number < need {\n        result = append(result, number)\n        result = append(result, need - number)\n    } else {\n        result = append(result, number)\n        result = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmprkky14ml_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprkky14ml_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmprkky14ml_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmprkky14ml_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmprkky14ml_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprkky14ml_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number >= remaining {\n        return []int{number, remaining}\n    }\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return []int{0, 0}\n    }\n    return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpu02swofr_test.go:72: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpu02swofr_test.go:72: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, remaining}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmparddh56z_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmparddh56z_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmparddh56z_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmparddh56z_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmparddh56z_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmparddh56z_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, remaining - need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpl0vbatxc_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpl0vbatxc_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpl0vbatxc_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpl0vbatxc_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpl0vbatxc_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpl0vbatxc_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number == need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0ozwv_ct_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    var result []int\n    if number < need {\n        result = append(result, number)\n        result = append(result, need - number)\n    } else {\n        result = append(result, number)\n        result = append(result, 0)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpr2wok1vr_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, remaining}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if number == 1 {\n        return []int{number, remaining}\n    }\n    if need == 1 {\n        return []int{number, remaining}\n    }\n    if number == 2 {\n        return []int{number, remaining}\n    }\n    if need == 2 {\n        return []int{number, remaining}\n    }\n    if number == 3 {\n        return []int{number, remaining}\n    }\n    if need == 3 {\n        return []int{number, remaining}\n    }\n    if number == 4 {\n        return []int{number, remaining}\n    }\n    if need == 4 {\n        return []int{number, remaining}\n    }\n    if number == 5 {\n        return []int{number, remaining}\n    }\n    if need == 5 {\n        return []int{number, remaining}\n    }\n    if number == 6 {\n        return []int{number, remaining}\n    }\n    if need == 6 {\n        return []int{number, remaining}\n    }\n    if number == 7 {\n        return []int{number, remaining}\n    }\n    if need == 7 {\n        return []int{number, remaining}\n    }\n    if number == 8 {\n        return []int{number, remaining}\n    }\n    if need == 8 {\n        return []int{number, remaining}\n    }\n    if number == 9 {\n        return []int{number, remaining}\n    }\n    if need == 9 {\n        return []int{number, remaining}\n    }\n    if number == 10 {\n        return []int{number, remaining}\n    }\n    if need ==\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpriupyn62_test.go:111:6: expected '(', found TestEat\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need - remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code in Java SE 8\n    return nil\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmps5ilu88e_test.go:57: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps5ilu88e_test.go:57: expected '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmps5ilu88e_test.go:57: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmps5ilu88e_test.go:57: expected '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmps5ilu88e_test.go:57: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmps5ilu88e_test.go:57: expected '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need - remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_zcjgn4c_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if remaining < need {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpq1e05afr_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, remaining}\n    }\n    if number > remaining {\n        return []int{number - remaining, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcquft2rw_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcquft2rw_test.go:71: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcquft2rw_test.go:71: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcquft2rw_test.go:71: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcquft2rw_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcquft2rw_test.go:71: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm8loyux2_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, remaining - number}\n    }\n    return []int{number + need, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpjne6qqmw_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjne6qqmw_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpjne6qqmw_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpjne6qqmw_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpjne6qqmw_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjne6qqmw_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=-3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp7amqhgk5_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7amqhgk5_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp7amqhgk5_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp7amqhgk5_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp7amqhgk5_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7amqhgk5_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, need}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    if number > remaining {\n        return []int{number, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpdauzhutu_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpdauzhutu_test.go:71: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpdauzhutu_test.go:71: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpdauzhutu_test.go:71: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpdauzhutu_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpdauzhutu_test.go:71: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprubk_97z_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if remaining < need {\n        return []int{number, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpkapzawgg_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkapzawgg_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpkapzawgg_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpkapzawgg_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpkapzawgg_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkapzawgg_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5l1ipb1q_test.go:65: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number == 0 {\n        return []int{0, remaining}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpy29b4jvr_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpy29b4jvr_test.go:72: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpy29b4jvr_test.go:72: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpy29b4jvr_test.go:72: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpy29b4jvr_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpy29b4jvr_test.go:72: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need}\n    }\n    return []int{number, need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxsscorat_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n        return []int{0, remaining}\n    }\n    if number > 0 {\n        return []int{number, need - number}\n    }\n    return []int{0, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpil68fz8z_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpil68fz8z_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpil68fz8z_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpil68fz8z_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpil68fz8z_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpil68fz8z_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuwkaswi0_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number - remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplp83o0bz_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if remaining < need {\n        return []int{number, need - remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwcgstqng_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpy5l3bz8a_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpy5l3bz8a_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpy5l3bz8a_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpy5l3bz8a_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpy5l3bz8a_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpy5l3bz8a_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp69rlta9o_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp69rlta9o_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp69rlta9o_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp69rlta9o_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp69rlta9o_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp69rlta9o_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    var result []int\n    if number >= need {\n        result = []int{number, 0}\n    } else {\n        result = []int{number, need - number}\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpdmdehg_a_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpdmdehg_a_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpdmdehg_a_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpdmdehg_a_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpdmdehg_a_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpdmdehg_a_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number - remaining, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp453hu9ym_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp453hu9ym_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp453hu9ym_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp453hu9ym_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp453hu9ym_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp453hu9ym_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need - remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, 0}\n    }\n    return []int{number + need, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqqnd8198_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    if number == remaining - 1 {\n        return []int{number, 1}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpvo7wro3u_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvo7wro3u_test.go:71: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpvo7wro3u_test.go:71: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpvo7wro3u_test.go:71: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpvo7wro3u_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpvo7wro3u_test.go:71: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcqb2fvnr_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpsl9j4oo4_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpsl9j4oo4_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpsl9j4oo4_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpsl9j4oo4_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpsl9j4oo4_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpsl9j4oo4_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpob6k5kuj_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpob6k5kuj_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpob6k5kuj_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpob6k5kuj_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpob6k5kuj_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpob6k5kuj_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if remaining < need {\n        return []int{number, need - remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe9zzrc1a_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, remaining - need}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmprri20sz0_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpznxhadub_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, 0}\n    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number, remaining - number}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpragqotyp_test.go:81: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpragqotyp_test.go:81: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpragqotyp_test.go:81: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpragqotyp_test.go:81: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpragqotyp_test.go:81: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpragqotyp_test.go:81: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzr22bx9f_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, need}\n    }\n    if remaining < need {\n        return []int{number, remaining}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpkc9092f9_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkc9092f9_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpkc9092f9_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpkc9092f9_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpkc9092f9_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkc9092f9_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n    return []int{number, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmptpaob6e__test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmptpaob6e__test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmptpaob6e__test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmptpaob6e__test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmptpaob6e__test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmptpaob6e__test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpipsqr_rt_test.go:48:1: missing return at end of function\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, need}\n    }\n    if number == remaining {\n        return []int{need, remaining}\n    }\n    return []int{need, need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp84z2em9p_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp84z2em9p_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp84z2em9p_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp84z2em9p_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp84z2em9p_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp84z2em9p_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number == 0 {\n        return []int{0, remaining}\n    }\n    if need > remaining {\n        return []int{number, 0}\n    }\n    if need == remaining {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, remaining - need}\n    }\n    return []int{number, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmplnnxqjmm_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplnnxqjmm_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmplnnxqjmm_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmplnnxqjmm_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmplnnxqjmm_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplnnxqjmm_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number > need {\n        return []int{number - need, remaining}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9nja8l5n_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number + need > remaining {\n        return []int{number + need, remaining - number}\n    }\n    return []int{number + need, need - (number + need)}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpccemgifv_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=-3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    if number == need {\n        return []int{number, need}\n    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpl0guy2r9_test.go:68: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number >= remaining {\n        return []int{number, remaining}\n    }\n    return []int{number, need - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpqk62b006_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqk62b006_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpqk62b006_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpqk62b006_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpqk62b006_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqk62b006_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{need, 0}\n    }\n    if number == need {\n        return []int{need, need}\n    }\n    if number == 0 {\n        return []int{0, remaining}\n    }\n    return []int{number, remaining - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmp1vzxpdug_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1vzxpdug_test.go:69: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp1vzxpdug_test.go:69: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp1vzxpdug_test.go:69: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp1vzxpdug_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1vzxpdug_test.go:69: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number < need {\n        return []int{number, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n    }\n    if number > need {\n        return []int{number - need, 0}\n    }\n    return []int{number, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpflmswb3w_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return a list of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n// >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n// >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n// Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    // Write your code here\n    if number >= need {\n        return []int{number, 0}\n    }\n    if number < need {\n        return []int{number, need - number}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if number > need {\n        return []int{number, need}\n    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpipsqr_rt_test.go:48:1: missing return at end of function\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}