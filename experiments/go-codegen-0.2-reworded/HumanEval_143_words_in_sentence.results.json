{
  "name": "HumanEval_143_words_in_sentence",
  "language": "go_test.go",
  "prompt": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n",
  "tests": "func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq3nq522d_test.go:88:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb82qw0we_test.go:88:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1l6nolfm_test.go:75:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxw891nb6_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmpxw891nb6_test.go:41:12: undefined: isPrime\n/tmp/tmpxw891nb6_test.go:45:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxssamdwc_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpxssamdwc_test.go:47:12: undefined: isPrime\n/tmp/tmpxssamdwc_test.go:52:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    // fmt.Printf(\"words = %s\\n\", words)\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5f5a1owy_test.go:32:23: cannot use word (type rune) as type string in append\n/tmp/tmp5f5a1owy_test.go:50:12: undefined: is_prime\n/tmp/tmp5f5a1owy_test.go:57:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var words []string\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/5:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] !=\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_7io99t9_test.go:86:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb0jlnubj_test.go:80:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5n01p2df_test.go:81:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i :=\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5hg_8aop_test.go:79:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9nuro45e_test.go:77:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = words[j][0:1]\n                }\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplnu91pmg_test.go:89:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if len(words) > 0 {\n                words = append(words, \"\")\n            }\n        } else {\n            words = append(words, string(sentence[i]))\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) > 1 {\n                for j := i + 1; j < len(words); j++ {\n                    if len(words[j]) > 1 {\n                        if words[i][0] == words[j][0] {\n                            words[i] = words[i][1:]\n                            words[j] = words[j][1:]\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 1 {\n            for j := i + 1; j < len(words); j++ {\n                if len(words[j]) > 1 {\n                    if words[i][0] == words[j][0] {\n                        words[i] = words[i][1:]\n                        words[j] = words[j][1:]\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 1 {\n            for j := i + 1; j < len(words); j++ {\n                if len(words[j]) > 1 {\n                    if words[i][0] == words[j][0] {\n                        words[i] = words[i][1:]\n                        words[j] = words[j][1:]\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 1 {\n            for j := i + 1; j < len(words); j++ {\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu9vole5y_test.go:75:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph2htyana_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmph2htyana_test.go:37:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokgaahm5_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpokgaahm5_test.go:47:12: undefined: is_prime\n/tmp/tmpokgaahm5_test.go:52:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprjp5e0p4_test.go:89:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/4]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/4:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqk2n23gp_test.go:73:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1q57wrzq_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmp1q57wrzq_test.go:45:12: undefined: isPrime\n/tmp/tmp1q57wrzq_test.go:51:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence): %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplxhj1c1g_test.go:46:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = strings.ToLower(words[i])\n            return strings.Join(words, \" \")\n        }\n    }\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphgcfd727_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmphgcfd727_test.go:41:12: undefined: isPrime\n/tmp/tmphgcfd727_test.go:42:24: undefined: strings\n/tmp/tmphgcfd727_test.go:43:20: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcg0khpwv_test.go:45:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpifchmeiy_test.go:72:44: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if len(res) > 0 {\n                res += \" \"\n            }\n        } else {\n            if len(res) > 0 {\n                res += \" \"\n            }\n            res += sentence[i : i+1]\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpki_kk7ld_test.go:58: expected 'is', got 'T h i s  i s  a  t e s t'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpki_kk7ld_test.go:58: expected 'go for', got 'l e t s  g o  f o r  s w i m m i n g'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpki_kk7ld_test.go:58: expected 'there is no place', got 't h e r e  i s  n o  p l a c e  a v a i l a b l e  h e r e'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpki_kk7ld_test.go:58: expected 'Hi am Hussein', got 'H i  I  a m  H u s s e i n'\n    --- FAIL: TestWords_In_Sentence/test_num__4 (0.00s)\n        tmpki_kk7ld_test.go:58: expected 'go for it', got 'g o  f o r  i t'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpki_kk7ld_test.go:58: expected '', got 'h e r e'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpki_kk7ld_test.go:58: expected 'is', got 'h e r e  i s'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if len(words[i]) == len(words[j]) && words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfeqtlhz2_test.go:88:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0liaqlsk_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmp0liaqlsk_test.go:37:13: undefined: is_prime\n/tmp/tmp0liaqlsk_test.go:43:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9v9dli7m_test.go:30:23: cannot use word (type rune) as type string in append\n/tmp/tmp9v9dli7m_test.go:34:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpd0wg1rjv_test.go:89:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpoekh_2jr_test.go:85:34: expected '{', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5lm415co_test.go:88:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\",\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp768p4zfw_test.go:82:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4d7yn52k_test.go:28:20: invalid operation: result += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\",\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6_eyc7_4_test.go:82:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\",\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp768p4zfw_test.go:82:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmyn3igdh_test.go:89:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp90dyhbil_test.go:27:27: cannot use word (type rune) as type string in append\n/tmp/tmp90dyhbil_test.go:42:12: undefined: isPrime\n/tmp/tmp90dyhbil_test.go:47:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) ==\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptjs5jy9w_test.go:87:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf1f1b4h7_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpf1f1b4h7_test.go:37:13: undefined: is_prime\n/tmp/tmpf1f1b4h7_test.go:43:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][1:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][1:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][1:]\n        }\n    }\n    // fmt.Printf\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv0lae78__test.go:74:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpci_vu579_test.go:89:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmmhi48ka_test.go:74:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if len(res) > 0 {\n                res += \" \"\n            }\n        } else {\n            if len(res) > 0 {\n                res += \" \"\n            }\n            res += string(sentence[i])\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpojlsr6o9_test.go:58: expected 'is', got 'T h i s  i s  a  t e s t'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpojlsr6o9_test.go:58: expected 'go for', got 'l e t s  g o  f o r  s w i m m i n g'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpojlsr6o9_test.go:58: expected 'there is no place', got 't h e r e  i s  n o  p l a c e  a v a i l a b l e  h e r e'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpojlsr6o9_test.go:58: expected 'Hi am Hussein', got 'H i  I  a m  H u s s e i n'\n    --- FAIL: TestWords_In_Sentence/test_num__4 (0.00s)\n        tmpojlsr6o9_test.go:58: expected 'go for it', got 'g o  f o r  i t'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpojlsr6o9_test.go:58: expected '', got 'h e r e'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpojlsr6o9_test.go:58: expected 'is', got 'h e r e  i s'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 2)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 3)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 5)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 7)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 11)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 13)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 17)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 19)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 23)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 29)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 31)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 37)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 41)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 43)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 47)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 53)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 59)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 61)\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkzpieatx_test.go:44:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq6a22s1x_test.go:78:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxw891nb6_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmpxw891nb6_test.go:41:12: undefined: isPrime\n/tmp/tmpxw891nb6_test.go:45:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            if len(words) > 0 {\n                words = append(words, \"\")\n            }\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i, word := range words {\n        if len(word) > 0 {\n            if isPrime(len(word)) {\n                words[i] = word\n            } else {\n                words[i] = \"\"\n            }\n        }\n    }\n    \n    for i, word := range words {\n        if len(word) > 0 {\n            words[i] = word\n        }\n    }\n    \n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp234tfiic_test.go:34:27: cannot use word (type rune) as type string in append\n/tmp/tmp234tfiic_test.go:40:16: undefined: isPrime\n/tmp/tmp234tfiic_test.go:54:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9t5t21d4_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmp9t5t21d4_test.go:44:12: undefined: is_prime\n/tmp/tmp9t5t21d4_test.go:49:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdnyq0r4f_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmpdnyq0r4f_test.go:33:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1g3mx9a2_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmp1g3mx9a2_test.go:41:12: undefined: isPrime\n/tmp/tmp1g3mx9a2_test.go:45:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if is_prime(sentence[i]) {\n            res += sentence[i]\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxh38_8g_test.go:26:12: undefined: is_prime\n/tmp/tmpxxh38_8g_test.go:27:17: invalid operation: res += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/4]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/4:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp417sk83f_test.go:75:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8pdx402q_test.go:74:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i], words[j] = words[j], words[i]\n            }\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprl20d3d9_test.go:76:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4d7yn52k_test.go:28:20: invalid operation: result += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk_5wjdz0_test.go:87:30: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if is_prime(sentence[i]) {\n            res += string(sentence[i])\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq64ma00v_test.go:25:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if is_prime(sentence[i]) {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdjgrhj0q_test.go:25:12: undefined: is_prime\n/tmp/tmpdjgrhj0q_test.go:26:20: invalid operation: result += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp254utnsj_test.go:89:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7_kdsfav_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmp7_kdsfav_test.go:34:13: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \" \" + words[i]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \" \" {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprfovbtpp_test.go:76:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1qxwo9zj_test.go:85:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4d7yn52k_test.go:28:20: invalid operation: result += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1l6nolfm_test.go:75:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) < 2 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) < 2 {\n                continue\n            }\n            if words[i][0] == words[j][0] && words[i][len(words[i])-1] == words[j][len(words[j])-1] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) < 2 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) < 2 {\n                continue\n            }\n            if words[i][0] == words[j][0] && words[i][len(words[i])-1] == words[j][len(words[j])-1] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) < 2 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) < 2 {\n                continue\n            }\n            \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpiy6j7nnr_test.go:79:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpp9gf5_ol_test.go:80:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxumo_dg6_test.go:80:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    // fmt.Printf(\"len(words) = %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words)\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz1og5vng_test.go:53:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/5:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5ipv2uja_test.go:83:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpri5vq5fj_test.go:75:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4d7yn52k_test.go:28:20: invalid operation: result += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf1f1b4h7_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpf1f1b4h7_test.go:37:13: undefined: is_prime\n/tmp/tmpf1f1b4h7_test.go:43:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := strings.Split(sentence, \" \")\n    // fmt.Printf(\"words = %v\\n\", words)\n    new_words := make([]string, 0)\n    for _, word := range words {\n        if is_prime(len(word)) {\n            new_words = append(new_words, word)\n        }\n    }\n    // fmt.Printf(\"new_words = %v\\n\", new_words)\n    return strings.Join(new_words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqcgfqn37_test.go:24:14: undefined: strings\n/tmp/tmpqcgfqn37_test.go:28:12: undefined: is_prime\n/tmp/tmpqcgfqn37_test.go:33:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb65zh1ty_test.go:92:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2ui1wq_f_test.go:77:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpye71erpe_test.go:95:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    if words[i] == words[j] {\n                        words[i] = \"\"\n                        words[j] = \"\"\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    if words[i] == words[j] {\n                        words[i] = \"\"\n                        words[j] = \"\"\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] =\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxc9_krjv_test.go:85:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"words: %s\\n\", words)\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0m_9sfnx_test.go:48:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8jy8unz0_test.go:74:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var words []string\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjsa2jx3i_test.go:76:20: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        if !isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1znlmtvy_test.go:79:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \" \" + words[i]\n        }\n    }\n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfnyq_nxg_test.go:27:27: cannot use word (type rune) as type string in append\n/tmp/tmpfnyq_nxg_test.go:40:12: undefined: is_prime\n/tmp/tmpfnyq_nxg_test.go:44:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] =\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmposcpjloa_test.go:88:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8nryhut8_test.go:90:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, string(sentence[i]))\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8k_ejsw3_test.go:66:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence = \", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg50yw60__test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpg50yw60__test.go:47:12: undefined: isPrime\n/tmp/tmpg50yw60__test.go:52:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmc44r1m7_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmpmc44r1m7_test.go:32:12: undefined: isPrime\n/tmp/tmpmc44r1m7_test.go:36:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[i] += \" \" + words[j]\n                    words[j] = \"\"\n                    break\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcyb609b8_test.go:78:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"words: %s\\n\", words)\n    words := []string{}\n    for _, word := range strings.Split(sentence, \" \") {\n        if len(word) > 0 {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if isPrime(len(words[i])) {\n                words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5u5em7x4_test.go:26:26: undefined: strings\n/tmp/tmp5u5em7x4_test.go:44:16: undefined: isPrime\n/tmp/tmp5u5em7x4_test.go:50:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var words []string\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy180iv50_test.go:85:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4u1uyi48_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmp4u1uyi48_test.go:43:12: undefined: is_prime\n/tmp/tmp4u1uyi48_test.go:48:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/4]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/4:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9h8pkpy3_test.go:80:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprjp5e0p4_test.go:89:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4d7yn52k_test.go:28:20: invalid operation: result += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if is_prime(words[i] + words[j]) {\n                words[i], words[j] = words[j], words[i]\n            }\n        }\n    }\n    // fmt.Println(\"words\", words)\n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3s29t96_test.go:27:27: cannot use word (type rune) as type string in append\n/tmp/tmpe3s29t96_test.go:33:16: undefined: is_prime\n/tmp/tmpe3s29t96_test.go:39:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/5:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcdywia4z_test.go:85:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1l6nolfm_test.go:75:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9e9f6m59_test.go:98:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5o_3tb37_test.go:32:23: cannot use word (type rune) as type string in append\n/tmp/tmp5o_3tb37_test.go:50:12: undefined: is_prime\n/tmp/tmp5o_3tb37_test.go:57:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/5:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu35mmgy4_test.go:75:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]int{}\n    words := make(map[string]int)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words[word]++\n    }\n    for word, count := range words {\n        if count % 2 == 0 {\n            words[word]--\n        }\n    }\n    words_list := make([]string, 0)\n    for word, count := range words {\n        if count > 0 {\n            words_list = append(words_list, word)\n        }\n    }\n    return strings.Join(words_list, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw7_uu9qt_test.go:29:14: cannot use word (type rune) as type string in map index\n/tmp/tmpw7_uu9qt_test.go:42:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxssamdwc_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpxssamdwc_test.go:47:12: undefined: isPrime\n/tmp/tmpxssamdwc_test.go:52:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words[len(words)-1] += string(sentence[i])\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf1xhwecb_test.go:36:12: undefined: is_prime\n/tmp/tmpf1xhwecb_test.go:41:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374750,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5lm415co_test.go:88:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9gsvlhn8_test.go:94:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:2]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:3]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:4]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:5]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words);\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4lcxqbao_test.go:74:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Print\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptmef525b_test.go:77:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkgp075nu_test.go:83:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:4]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:5]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:6]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:7]\n        }\n    }\n    \n    for i := 0; i < len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyar7j6or_test.go:88:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbm6zqp76_test.go:74:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph2htyana_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmph2htyana_test.go:37:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words[len(words)-1] += string(sentence[i])\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxmk943q0_test.go:82:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            for j := 0; j < len(words[i]); j++ {\n                if words[i][j] == ' ' {\n                    words[i] = words[i][j+1:]\n                    break\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            for j := 0; j < len(words[i]); j++ {\n                if words[i][j] == ' ' {\n                    words[i] = words[i][j+1:]\n                    break\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            for j := 0; j < len(words[i]); j++ {\n                if words[i][j] == ' ' {\n                    words[i] = words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7kh9u_s1_test.go:71:39: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpereqrmsa_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpereqrmsa_test.go:47:12: undefined: isPrime\n/tmp/tmpereqrmsa_test.go:52:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfu2v4ejf_test.go:87:34: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \" \" + words[i]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt69krhn5_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmpt69krhn5_test.go:33:12: undefined: is_prime\n/tmp/tmpt69krhn5_test.go:38:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmjr6u6bv_test.go:74:20: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence): %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplxhj1c1g_test.go:46:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var words []string\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[i] = words[i][1:]\n                words[j] = words[j][1:]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[i] = words[i][1:]\n                words[j] = words[j][1:]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[i] = words[i][1:]\n                words[j] = words[j][1:]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpr4wn047i_test.go:82:24: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4ytp5gf0_test.go:78:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjtxgtv49_test.go:70:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1j4c5ekx_test.go:30:27: cannot use word (type rune) as type string in append\n/tmp/tmp1j4c5ekx_test.go:45:12: undefined: is_prime\n/tmp/tmp1j4c5ekx_test.go:50:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjic3hyte_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmpjic3hyte_test.go:43:12: undefined: isPrime\n/tmp/tmpjic3hyte_test.go:48:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp254utnsj_test.go:89:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcg0khpwv_test.go:45:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4a8vrdbp_test.go:85:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8pdx402q_test.go:74:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0f367l17_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmp0f367l17_test.go:43:12: undefined: isPrime\n/tmp/tmp0f367l17_test.go:48:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptmhop6nh_test.go:74:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" {\n                break\n            }\n            if words[j] == \"\" {\n                break\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwwigo6ym_test.go:77:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if res != \"\" {\n                res += \" \"\n            }\n        } else {\n            if isPrime(len(res)) {\n                res += sentence[i]\n            }\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2tt2tryy_test.go:31:16: undefined: isPrime\n/tmp/tmp2tt2tryy_test.go:32:21: invalid operation: res += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    // fmt.Println(\"\")\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7vih1zq5_test.go:93:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) ==\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgyxv_4vx_test.go:78:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var words []string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, string(sentence[i]))\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpza7a29s0_test.go:81:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            if len(words) > 0 {\n                words = words[:len(words)-1]\n            }\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = words[:i]\n            break\n        }\n    }\n    \n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw6mg2qti_test.go:33:27: cannot use word (type rune) as type string in append\n/tmp/tmpw6mg2qti_test.go:38:13: undefined: is_prime\n/tmp/tmpw6mg2qti_test.go:44:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            if len(words) > 0 {\n                words = append(words, \"\")\n            }\n        } else {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe4msxm0g_test.go:76:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if words[i][0] == ' ' {\n            words[i] = words[i][1:]\n        }\n        if words[i][len(words[i])-1] == ' ' {\n            words[i] = words[i][:len(words[i])-1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if words[i][0] == ' ' {\n            words[i] = words[i][1:]\n        }\n        if words[i][len(words[i])-1] == ' ' {\n            words[i] = words[i][:len(words[i])-1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if words[i][0] == ' ' {\n            words[i] = words[i][1:]\n        }\n        if words[i][len(words[i])-1] == ' ' {\n            words[i] = words[i][:len(words[i])-1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if words[i][0] == ' ' {\n            words[i] = words[i][1:]\n        }\n        if words[i][len(words[i])-1] == ' ' {\n            words[i] = words[i][:len(words[i])-1\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3pppe9a7_test.go:77:49: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    // fmt.Println(\"\")\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words);\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps3mwxhko_test.go:87:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp99l3grf5_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmp99l3grf5_test.go:47:12: undefined: isPrime\n/tmp/tmp99l3grf5_test.go:58:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf1f1b4h7_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpf1f1b4h7_test.go:37:13: undefined: is_prime\n/tmp/tmpf1f1b4h7_test.go:43:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7inck00n_test.go:86:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !isPrime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvbxhh0zy_test.go:33:23: cannot use word (type rune) as type string in append\n/tmp/tmpvbxhh0zy_test.go:37:13: undefined: isPrime\n/tmp/tmpvbxhh0zy_test.go:43:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3lrswjw8_test.go:98:36: expected '{', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    // fmt.Println(\"\")\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkhymx6nt_test.go:34:23: cannot use word (type rune) as type string in append\n/tmp/tmpkhymx6nt_test.go:48:12: undefined: isPrime\n/tmp/tmpkhymx6nt_test.go:53:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_5lbica4_test.go:87:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i])\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5otgmenw_test.go:69:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i], words[j] = words[j], words[i]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx2pn30ak_test.go:83:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp97atgksb_test.go:73:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5q3sm3ff_test.go:32:23: cannot use word (type rune) as type string in append\n/tmp/tmp5q3sm3ff_test.go:50:12: undefined: isPrime\n/tmp/tmp5q3sm3ff_test.go:57:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppeojkvsm_test.go:80:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1l6nolfm_test.go:75:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var res []string\n    for _, word := range sentence {\n        if isPrime(len(word)) {\n            res = append(res, word)\n        }\n    }\n    return strings.Join(res, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp743e5fal_test.go:26:12: undefined: isPrime\n/tmp/tmp743e5fal_test.go:26:23: invalid argument word (type rune) for len\n/tmp/tmp743e5fal_test.go:27:25: cannot use word (type rune) as type string in append\n/tmp/tmp743e5fal_test.go:30:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2ui1wq_f_test.go:77:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words[len(words) - 1] += string(sentence[i])\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if isPrime(len(words[i])) {\n                words[i] = string(words[i][0]) + words[i][1:]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnraly9bu_test.go:70:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpdd9iz1sh_test.go:53: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcg0khpwv_test.go:45:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfsykhsj5_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmpfsykhsj5_test.go:33:12: undefined: isPrime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        if !isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgfttyjbc_test.go:84:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpao3ryq8t_test.go:102:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpquocn00v_test.go:29:23: cannot use word (type rune) as type string in append\n/tmp/tmpquocn00v_test.go:34:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[j] = \"\"\n            }\n        }\n    }\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt8fcfykq_test.go:82:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"words: %s\\n\", words)\n    words := []string{}\n    for _, word := range words {\n        words = append(words, word)\n    }\n    return words[0]\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000154000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000154000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.words_in_sentence(0x547133, 0xe, 0x5fa260, 0x5825e3)\n\t/tmp/tmpitv1jls7_test.go:29 +0x18\ncommand-line-arguments_test.TestWords_In_Sentence(0xc000102600)\n\t/tmp/tmpitv1jls7_test.go:39 +0x56\ntesting.tRunner(0xc000102600, 0x54f290)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7inck00n_test.go:86:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/4]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/4:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqk2n23gp_test.go:73:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_5lbica4_test.go:87:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if len(result) > 0 {\n                result += \" \"\n            }\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestWords_In_Sentence (0.00s)\n    --- FAIL: TestWords_In_Sentence/test_num__0 (0.00s)\n        tmpcim14vea_test.go:56: expected 'is', got 'This is a test'\n    --- FAIL: TestWords_In_Sentence/test_num__1 (0.00s)\n        tmpcim14vea_test.go:56: expected 'go for', got 'lets go for swimming'\n    --- FAIL: TestWords_In_Sentence/test_num__2 (0.00s)\n        tmpcim14vea_test.go:56: expected 'there is no place', got 'there is no place available here'\n    --- FAIL: TestWords_In_Sentence/test_num__3 (0.00s)\n        tmpcim14vea_test.go:56: expected 'Hi am Hussein', got 'Hi I am Hussein'\n    --- FAIL: TestWords_In_Sentence/test_num__5 (0.00s)\n        tmpcim14vea_test.go:56: expected '', got 'here'\n    --- FAIL: TestWords_In_Sentence/test_num__6 (0.00s)\n        tmpcim14vea_test.go:56: expected 'is', got 'here is'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i :=\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp00u4un5i_test.go:79:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    words := strings.Split(sentence, \" \")\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbqq2gwyn_test.go:24:14: undefined: strings\n/tmp/tmpbqq2gwyn_test.go:26:12: undefined: isPrime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb82qw0we_test.go:88:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt4x7lqis_test.go:56:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4d7yn52k_test.go:28:20: invalid operation: result += sentence[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, string(sentence[i]))\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j]\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi781amrg_test.go:80:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcg0khpwv_test.go:45:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    // words := []string{\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp66yqadda_test.go:35:6: expected '(', found TestWords_In_Sentence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    words := strings.Split(sentence, \" \")\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbqq2gwyn_test.go:24:14: undefined: strings\n/tmp/tmpbqq2gwyn_test.go:26:12: undefined: isPrime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}