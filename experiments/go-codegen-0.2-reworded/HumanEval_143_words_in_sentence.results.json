{
  "name": "HumanEval_143_words_in_sentence",
  "language": "go_test.go",
  "prompt": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n",
  "tests": "func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    // fmt.Printf(\"words = %s\\n\", words)\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var words []string\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/5:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] !=\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i :=\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = words[j][0:1]\n                }\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if len(words) > 0 {\n                words = append(words, \"\")\n            }\n        } else {\n            words = append(words, string(sentence[i]))\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) > 1 {\n                for j := i + 1; j < len(words); j++ {\n                    if len(words[j]) > 1 {\n                        if words[i][0] == words[j][0] {\n                            words[i] = words[i][1:]\n                            words[j] = words[j][1:]\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 1 {\n            for j := i + 1; j < len(words); j++ {\n                if len(words[j]) > 1 {\n                    if words[i][0] == words[j][0] {\n                        words[i] = words[i][1:]\n                        words[j] = words[j][1:]\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 1 {\n            for j := i + 1; j < len(words); j++ {\n                if len(words[j]) > 1 {\n                    if words[i][0] == words[j][0] {\n                        words[i] = words[i][1:]\n                        words[j] = words[j][1:]\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 1 {\n            for j := i + 1; j < len(words); j++ {\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/4]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/4:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence): %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = strings.ToLower(words[i])\n            return strings.Join(words, \" \")\n        }\n    }\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if len(res) > 0 {\n                res += \" \"\n            }\n        } else {\n            if len(res) > 0 {\n                res += \" \"\n            }\n            res += sentence[i : i+1]\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if len(words[i]) == len(words[j]) && words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\",\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\",\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\",\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) ==\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][1:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][1:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][1:]\n        }\n    }\n    // fmt.Printf\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if len(res) > 0 {\n                res += \" \"\n            }\n        } else {\n            if len(res) > 0 {\n                res += \" \"\n            }\n            res += string(sentence[i])\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 2)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 3)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 5)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 7)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 11)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 13)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 17)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 19)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 23)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 29)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 31)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 37)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 41)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 43)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 47)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 53)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 59)\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence) % 61)\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            if len(words) > 0 {\n                words = append(words, \"\")\n            }\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i, word := range words {\n        if len(word) > 0 {\n            if isPrime(len(word)) {\n                words[i] = word\n            } else {\n                words[i] = \"\"\n            }\n        }\n    }\n    \n    for i, word := range words {\n        if len(word) > 0 {\n            words[i] = word\n        }\n    }\n    \n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if is_prime(sentence[i]) {\n            res += sentence[i]\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/4]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/4:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i], words[j] = words[j], words[i]\n            }\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Println(\"words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if is_prime(sentence[i]) {\n            res += string(sentence[i])\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if is_prime(sentence[i]) {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \" \" + words[i]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \" \" {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) < 2 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) < 2 {\n                continue\n            }\n            if words[i][0] == words[j][0] && words[i][len(words[i])-1] == words[j][len(words[j])-1] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) < 2 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) < 2 {\n                continue\n            }\n            if words[i][0] == words[j][0] && words[i][len(words[i])-1] == words[j][len(words[j])-1] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) < 2 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) < 2 {\n                continue\n            }\n            \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    // fmt.Printf(\"len(words) = %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words) %d\\n\", len(words))\n    // fmt.Printf(\"len(words)\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/5:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := strings.Split(sentence, \" \")\n    // fmt.Printf(\"words = %v\\n\", words)\n    new_words := make([]string, 0)\n    for _, word := range words {\n        if is_prime(len(word)) {\n            new_words = append(new_words, word)\n        }\n    }\n    // fmt.Printf(\"new_words = %v\\n\", new_words)\n    return strings.Join(new_words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    if words[i] == words[j] {\n                        words[i] = \"\"\n                        words[j] = \"\"\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    if words[i] == words[j] {\n                        words[i] = \"\"\n                        words[j] = \"\"\n                    }\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] =\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"words: %s\\n\", words)\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\", len(words))\n    // fmt.Printf(\"len(words): %d\\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var words []string\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        if !isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \" \" + words[i]\n        }\n    }\n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] =\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    // fmt.Println(\"words:\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, string(sentence[i]))\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence = \", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293466,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[i] += \" \" + words[j]\n                    words[j] = \"\"\n                    break\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][:len(words[i]) - 1]\n        }\n    }\n    \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"words: %s\\n\", words)\n    words := []string{}\n    for _, word := range strings.Split(sentence, \" \") {\n        if len(word) > 0 {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if isPrime(len(words[i])) {\n                words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var words []string\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words = words[:i]\n            i--\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/4]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/4:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    // fmt.Println(\"words\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if is_prime(words[i] + words[j]) {\n                words[i], words[j] = words[j], words[i]\n            }\n        }\n    }\n    // fmt.Println(\"words\", words)\n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/5:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        \n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    \n    for i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:j], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/5:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]int{}\n    words := make(map[string]int)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words[word]++\n    }\n    for word, count := range words {\n        if count % 2 == 0 {\n            words[word]--\n        }\n    }\n    words_list := make([]string, 0)\n    for word, count := range words {\n        if count > 0 {\n            words_list = append(words_list, word)\n        }\n    }\n    return strings.Join(words_list, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words[len(words)-1] += string(sentence[i])\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293467,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n\n    // fmt.Println(\"words:\", words)\n\n    for i := 0; i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293481,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:2]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:3]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:4]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:5]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words);\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Print\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    // fmt.Printf(\"words: %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:2]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:3]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:4]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:5]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:6]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:7]\n        }\n    }\n    \n    for i := 0; i < len(\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words[len(words)-1] += string(sentence[i])\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = \"\"\n            }\n        }\n    }\n    for i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            for j := 0; j < len(words[i]); j++ {\n                if words[i][j] == ' ' {\n                    words[i] = words[i][j+1:]\n                    break\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            for j := 0; j < len(words[i]); j++ {\n                if words[i][j] == ' ' {\n                    words[i] = words[i][j+1:]\n                    break\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            for j := 0; j < len(words[i]); j++ {\n                if words[i][j] == ' ' {\n                    words[i] = words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \" \" + words[i]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence): %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var words []string\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[i] = words[i][1:]\n                words[j] = words[j][1:]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[i] = words[i][1:]\n                words[j] = words[j][1:]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[i] = words[i][1:]\n                words[j] = words[j][1:]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[i+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) == 1 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293451,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" {\n                break\n            }\n            if words[j] == \"\" {\n                break\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var res string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if res != \"\" {\n                res += \" \"\n            }\n        } else {\n            if isPrime(len(res)) {\n                res += sentence[i]\n            }\n        }\n    }\n    return res\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    // fmt.Println(\"\")\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293482,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) ==\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var words []string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, string(sentence[i]))\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            if len(words) > 0 {\n                words = words[:len(words)-1]\n            }\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = words[:i]\n            break\n        }\n    }\n    \n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            if len(words) > 0 {\n                words = append(words, \"\")\n            }\n        } else {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if len(words[i]) % 2 == 0 {\n                words[i] = words[i][1:]\n            }\n        }\n    }\n    // fmt.Printf(\"words = %s\\n\", words)\n    for\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if words[i][0] == ' ' {\n            words[i] = words[i][1:]\n        }\n        if words[i][len(words[i])-1] == ' ' {\n            words[i] = words[i][:len(words[i])-1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if words[i][0] == ' ' {\n            words[i] = words[i][1:]\n        }\n        if words[i][len(words[i])-1] == ' ' {\n            words[i] = words[i][:len(words[i])-1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if words[i][0] == ' ' {\n            words[i] = words[i][1:]\n        }\n        if words[i][len(words[i])-1] == ' ' {\n            words[i] = words[i][:len(words[i])-1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        if words[i][0] == ' ' {\n            words[i] = words[i][1:]\n        }\n        if words[i][len(words[i])-1] == ' ' {\n            words[i] = words[i][:len(words[i])-1\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    // fmt.Println(\"\")\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words);\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    return strings.Join(words, \"\")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !is_prime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if !isPrime(len(words[i])) {\n            words = append(words[:i], words[i+1:]...)\n            i--\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    // fmt.Println(\"\")\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if is_prime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i])\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[i], words[j] = words[j], words[i]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 1 {\n            continue\n        }\n        if len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    // fmt.Println(words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words = append(words[:i], words[j+1:]...)\n                i--\n                break\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = words[i][:len(words[i])/2] + words[i][len(words[i])/2:]\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    return strings.Join(words, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if isPrime(len(words[i])) {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    // map[string]bool{}\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var res []string\n    for _, word := range sentence {\n        if isPrime(len(word)) {\n            res = append(res, word)\n        }\n    }\n    return strings.Join(res, \" \")\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    // fmt.Printf(\"\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293452,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words[len(words) - 1] += string(sentence[i])\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            if isPrime(len(words[i])) {\n                words[i] = string(words[i][0]) + words[i][1:]\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = string(words[i][0]) + words[i][1:]\n        }\n    }\n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == \"\" || words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        if !isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            words[i] = words[i][0:1]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := make([]string, 0)\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        \n        words = append(words, word)\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        \n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            \n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        \nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if is_prime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[j] == \"\" {\n                continue\n            }\n            if words[i] == words[j] {\n                words[i] = \"\"\n                words[j] = \"\"\n            }\n        }\n    }\n    \n    // fmt.Printf(\"words = %v\\n\", words)\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            return words[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[j] = \"\"\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[j]) == 0 {\n                continue\n            }\n            if words[i][0] == words[j][0] {\n                words[j] = \"\"\n            }\n        }\n    }\n    //\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293512,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    // fmt.Printf(\"words: %s\\n\", words)\n    words := []string{}\n    for _, word := range words {\n        words = append(words, word)\n    }\n    return words[0]\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293512,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word != ' ' {\n            words = append(words, word)\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/2]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/2:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/3]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/3:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/4]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][len(words[i])/4:]\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > 0 {\n            words[i] = words[i][0:len(words[i])/5]\n        }\n    }\n    for i := 0;\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    for i := 0; i < len(words); i++ {\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if words[i] == words[j] {\n                words[j] = \"\"\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        if len(words[i]) % 2 == 0 {\n            words[i] = \"\"\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            if len(result) > 0 {\n                result += \" \"\n            }\n        } else {\n            result += string(sentence[i])\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293512,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    words := make([]string, 0)\n    for _, word := range sentence {\n        if word == ' ' {\n            continue\n        }\n        words = append(words, word)\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if isPrime(len(words[i])) {\n            words[i] = \"\"\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i := 0; i < len(words); i++ {\n        if words[i] != \"\" {\n            for j := i + 1; j < len(words); j++ {\n                if words[j] != \"\" {\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    // fmt.Printf(\"words = %v\\n\", words)\n    for i :=\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293512,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    words := strings.Split(sentence, \" \")\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293512,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(\"words_in_sentence\")\n    // fmt.Println(\"sentence:\", sentence)\n    \n    words := []string{}\n    \n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if words[i] == \"\" {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[i+1] = \"\"\n            i--\n        }\n    }\n    \n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            words[i] = words[i+1]\n            words[\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    // fmt.Println(len(sentence))\n    // fmt.Println(len(sentence)%2)\n    // fmt.Println(len(sentence)%3)\n    // fmt.Println(len(sentence)%5)\n    // fmt.Println(len(sentence)%7)\n    // fmt.Println(len(sentence)%11)\n    // fmt.Println(len(sentence)%13)\n    // fmt.Println(len(sentence)%17)\n    // fmt.Println(len(sentence)%19)\n    // fmt.Println(len(sentence)%23)\n    // fmt.Println(len(sentence)%29)\n    // fmt.Println(len(sentence)%31)\n    // fmt.Println(len(sentence)%37)\n    // fmt.Println(len(sentence)%41)\n    // fmt.Println(len(sentence)%43)\n    // fmt.Println(len(sentence)%47)\n    // fmt.Println(len(sentence)%53)\n    // fmt.Println(len(sentence)%59)\n    // fmt.Println(len(sentence)%61)\n    // fmt.Println(len(sentence)%67)\n    // fmt.Println(len(sentence)%71)\n    // fmt.Println(len(sentence)%73)\n    // fmt.Println(len(sentence)%79)\n    // fmt.Println(len(sentence)%83)\n    // fmt.Println(len(sentence)%89)\n    // fmt.Println(len(sentence)%97)\n    // fmt.Println(len(sentence)%101)\n    // fmt.Println(len(sentence)%103)\n    // fmt.Println(len(sentence)%107)\n    // fmt.Println(len(sentence)%109)\n    // fmt.Println(len(sentence)%113)\n    // fmt.Println(len\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            result += \" \"\n        } else {\n            result += sentence[i]\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293436,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Println(sentence)\n    words := make([]string, 0)\n    for i := 0; i < len(sentence); i++ {\n        if sentence[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, string(sentence[i]))\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j] = \"\"\n                }\n            }\n        }\n    }\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) == 0 {\n            continue\n        }\n        for j := i + 1; j < len(words); j++ {\n            if len(words[i]) == len(words[j]) {\n                if words[i] == words[j] {\n                    words[i] = \"\"\n                    words[j]\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293512,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence = %s\\n\", sentence)\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %d\\n\", len(sentence))\n    // fmt.Printf(\"len(sentence) = %\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293421,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    // fmt.Printf(\"sentence: %s\\n\", sentence)\n    words := []string{}\n    for _, word := range sentence {\n        if word == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, word)\n        }\n    }\n    // fmt.Printf(\"words: %s\\n\", words)\n    \n    // words := []string{\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293512,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence string) string {\n    var result string\n    words := strings.Split(sentence, \" \")\n    for _, word := range words {\n        if isPrime(len(word)) {\n            result += word\n        }\n    }\n    return result\n}\n\nfunc TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\" },\n     { actual: candidate(\"there is no place available here\"), expected: \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected: \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual: candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293512,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    }
  ]
}