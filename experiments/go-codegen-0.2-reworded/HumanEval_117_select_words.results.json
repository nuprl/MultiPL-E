{
  "name": "HumanEval_117_select_words",
  "language": "go_test.go",
  "prompt": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n",
  "tests": "func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp1wids0ti_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp1wids0ti_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp1wids0ti_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp1wids0ti_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp1wids0ti_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp1wids0ti_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        words = append(words, s[i:])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp_ubp39cp_test.go:65: expected '[little]', got '[Mary had a little lamb ad a little lamb ittle lamb ttle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp_ubp39cp_test.go:65: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb little lamb ittle lamb ttle lamb tle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp_ubp39cp_test.go:65: expected '[]', got '[simple white space imple white space mple white space ple white space le white space hite space ite space te space pace ace ce e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp_ubp39cp_test.go:65: expected '[world]', got '[Hello world ello world orld rld ld d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp_ubp39cp_test.go:65: expected '[Uncle]', got '[Uncle sam ncle sam cle sam am m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp_ubp39cp_test.go:65: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    var words []string\n    for _, word := range strings.Split(s, \" \") {\n        if len(word) == 0 {\n            continue\n        }\n        words = append(words, word)\n    }\n    for _, word := range words {\n        if len(word) == 0 {\n            continue\n        }\n        if len(word) == n {\n            result = append(result, word)\n        }\n        for i := 0; i < len(word); i++ {\n            if word[i] == ' ' {\n                continue\n            }\n            if i + 1 < len(word) {\n                if word[i] == word[i + 1] {\n                    continue\n                }\n            }\n            if i + 2 < len(word) {\n                if word[i] == word[i + 2] {\n                    continue\n                }\n            }\n            if i + 3 < len(word) {\n                if word[i] == word[i + 3] {\n                    continue\n                }\n            }\n            if i + 4 < len(word) {\n                if word[i] == word[i + 4] {\n                    continue\n                }\n            }\n            if i + 5 < len(word) {\n                if word[i] == word[i + 5] {\n                    continue\n                }\n            }\n            if i + 6 < len(word) {\n                if word[i] == word[i + 6] {\n                    continue\n                }\n            }\n            if i + 7 < len(word) {\n                if word[i] == word[i + 7] {\n                    continue\n                }\n            }\n            if i + 8 < len(word) {\n                if word[i] == word[i + 8] {\n                    continue\n                }\n            }\n            if i + 9 < len(word) {\n                if word[i] == word[i + 9] {\n                    continue\n                }\n            }\n            if i + 10 < len(word) {\n                if word[i] == word[i + 10] {\n                    continue\n                }\n            }\n            if i + 11 < len(word) {\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8es__3cf_test.go:95:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    \n    if len(s) == 0 {\n        return result\n    }\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        words = append(words, s[i:i+1])\n        \n        if len(words) == n {\n            result = append(result, words)\n            words = make([]string, 0)\n        }\n    }\n    \n    if len(words) > 0 {\n        result = append(result, words)\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc5_vga8f_test.go:42:28: cannot use words (type []string) as type string in append\n/tmp/tmpc5_vga8f_test.go:48:24: cannot use words (type []string) as type string in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] != ' ' {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpbw7q9a83_test.go:68: expected '[little]', got '[M a r y ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbw7q9a83_test.go:68: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpbw7q9a83_test.go:68: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpbw7q9a83_test.go:68: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbw7q9a83_test.go:68: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpbw7q9a83_test.go:68: expected '[b c d f]', got '[a ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // Create a map to store the words and their frequency\n    words := make(map[string]int)\n    \n    // Create a slice to store the words\n    var result []string\n    \n    // Iterate through the string\n    for i := 0; i < len(s); i++ {\n        \n        // If the current character is a space, skip it\n        if s[i] == ' ' {\n            continue\n        }\n        \n        // If the current character is a letter, add it to the word\n        if is_letter(s[i]) {\n            word := s[i:]\n            \n            // If the word is not in the map, add it\n            if _, ok := words[word]; !ok {\n                words[word] = 1\n            } else {\n                // If the word is in the map, increment its frequency\n                words[word]++\n            }\n        }\n    }\n    \n    // Iterate through the map and add the words to the result\n    for word, _ := range words {\n        if words[word] == n {\n            result = append(result, word)\n        }\n    }\n    \n    return result\n}\n\n// Helper function to check if a character is a letter\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvqi3ctat_test.go:41:12: undefined: is_letter\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        words = append(words, s[i:])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpgtbhpulr_test.go:62: expected '[little]', got '[Mary had a little lamb ad a little lamb ittle lamb ttle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpgtbhpulr_test.go:62: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb little lamb ittle lamb ttle lamb tle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpgtbhpulr_test.go:62: expected '[]', got '[simple white space imple white space mple white space ple white space le white space hite space ite space te space pace ace ce e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpgtbhpulr_test.go:62: expected '[world]', got '[Hello world ello world orld rld ld d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpgtbhpulr_test.go:62: expected '[Uncle]', got '[Uncle sam ncle sam cle sam am m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpgtbhpulr_test.go:62: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            break\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:i+1])\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpk6dawbow_test.go:69: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpk6dawbow_test.go:69: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpk6dawbow_test.go:69: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpk6dawbow_test.go:69: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpk6dawbow_test.go:69: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpk6dawbow_test.go:69: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpino2m9yu_test.go:106:42: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5p_2bulh_test.go:94:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp8nqdlevo_test.go:77: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8nqdlevo_test.go:77: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp8nqdlevo_test.go:77: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp8nqdlevo_test.go:77: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp8nqdlevo_test.go:77: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            return words\n        }\n        words = append(words, s[i:i+1])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpbtp6yh7__test.go:61: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbtp6yh7__test.go:61: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpbtp6yh7__test.go:61: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpbtp6yh7__test.go:61: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbtp6yh7__test.go:61: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpbtp6yh7__test.go:61: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // TODO: implement this function\n    \n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpyrc3evdt_test.go:50: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpyrc3evdt_test.go:50: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpyrc3evdt_test.go:50: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpyrc3evdt_test.go:50: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpyrc3evdt_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    var words []string\n    words = strings.Split(s, \" \")\n    for _, word := range words {\n        if len(word) == n {\n            result = append(result, word)\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptdfuk0ji_test.go:27:13: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    if len(s) == 0 {\n        return result\n    }\n    \n    words := make(map[string]int)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        word := s[i:]\n        if len(word) > n {\n            word = word[:n]\n        }\n        \n        if _, ok := words[word]; ok {\n            words[word]++\n        } else {\n            words[word] = 1\n        }\n    }\n    \n    for word, count := range words {\n        if count == n {\n            result = append(result, word)\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpys298b_y_test.go:78: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpys298b_y_test.go:78: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpys298b_y_test.go:78: expected '[]', got '[e ]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpys298b_y_test.go:78: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpys298b_y_test.go:78: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpys298b_y_test.go:78: expected '[b c d f]', got '[f a b c d e]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[j] == s[i] {\n                if n == 1 {\n                    words = append(words, s[i:j])\n                    break\n                }\n                n--\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp7hk8xrpx_test.go:65: expected '[little]', got '[              ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp7hk8xrpx_test.go:65: expected '[Mary lamb]', got '[               ]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp7hk8xrpx_test.go:65: expected '[]', got '[              ]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp7hk8xrpx_test.go:65: expected '[world]', got '[l       ]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp7hk8xrpx_test.go:65: expected '[Uncle]', got '[     ]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp7hk8xrpx_test.go:65: expected '[b c d f]', got '[     ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i > 0 && s[i] == s[i-1] {\n            continue\n        }\n        \n        words = append(words, s[i:i+1])\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp95bvc3z2_test.go:66: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp95bvc3z2_test.go:66: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp95bvc3z2_test.go:66: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp95bvc3z2_test.go:66: expected '[world]', got '[H e l o]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp95bvc3z2_test.go:66: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp95bvc3z2_test.go:66: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    var words []string\n    words = strings.Split(s, \" \")\n    for _, word := range words {\n        if len(word) == n {\n            result = append(result, word)\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphojsboim_test.go:28:13: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i + n <= len(s) {\n            if s[i:i+n] == \" \" {\n                continue\n            }\n            \n            words = append(words, s[i:i+n])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpt8shci46_test.go:68: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpt8shci46_test.go:68: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpt8shci46_test.go:68: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpt8shci46_test.go:68: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpt8shci46_test.go:68: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpt8shci46_test.go:68: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // Create a map to store the words\n    words := make(map[string]bool)\n    \n    // Create a list to store the words\n    var result []string\n    \n    // Iterate through the string\n    for i := 0; i < len(s); i++ {\n        \n        // If the current character is a space\n        if s[i] == ' ' {\n            \n            // If the number of consonants is equal to the number of spaces\n            if n == 0 {\n                \n                // Add the word to the list\n                result = append(result, s[i+1:])\n            }\n            \n            // If the number of consonants is less than the number of spaces\n            else if n > 0 {\n                \n                // If the word is not in the map\n                if _, ok := words[s[i+1:]]; !ok {\n                    \n                    // Add the word to the list\n                    result = append(result, s[i+1:])\n                }\n            }\n        }\n        \n        // If the current character is not a space\n        else {\n            \n            // If the number of consonants is equal to the number of spaces\n            if n == 0 {\n                \n                // Add the word to the map\n                words[s[i:i+1]] = true\n            }\n            \n            // If the number of consonants is less than the number of spaces\n            else if n > 0 {\n                \n                // If the word is not in the map\n                if _, ok := words[s[i:i+1]]; !ok {\n                    \n                    // Add the word to the map\n                    words[s[i:i+1]] = true\n                }\n            }\n        }\n    }\n    \n    // Return the list of words\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp96lc42m3_test.go:46:13: expected statement, found 'else'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(result) == n {\n                break\n            }\n            continue\n        }\n        if len(result) == n {\n            break\n        }\n        result = append(result, s[i:i+1])\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var res []string\n    if len(s) == 0 {\n        return res\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i + n > len(s) {\n            break\n        }\n        \n        if s[i:i+n] == \" \" {\n            continue\n        }\n        \n        res = append(res, s[i:i+n])\n    }\n    \n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpc2ylwivp_test.go:69: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpc2ylwivp_test.go:69: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpc2ylwivp_test.go:69: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpc2ylwivp_test.go:69: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpc2ylwivp_test.go:69: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpc2ylwivp_test.go:69: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(result) == n {\n            return result\n        }\n        \n        if i == len(s) - 1 {\n            result = append(result, s[i:])\n            return result\n        }\n        \n        if s[i] == s[i+1] {\n            result = append(result, s[i:i+2])\n            i++\n        } else {\n            result = append(result, s[i:])\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpmv2myvil_test.go:71: expected '[little]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb y had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpmv2myvil_test.go:71: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpmv2myvil_test.go:71: expected '[]', got '[simple white space imple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpmv2myvil_test.go:71: expected '[world]', got '[Hello world ello world ll o world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpmv2myvil_test.go:71: expected '[Uncle]', got '[Uncle sam ncle sam cle sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpmv2myvil_test.go:71: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := make([]string, 0)\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        words = append(words, s[i:])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpopsg9bfu_test.go:61: expected '[little]', got '[Mary had a little lamb ad a little lamb ittle lamb ttle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpopsg9bfu_test.go:61: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb little lamb ittle lamb ttle lamb tle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpopsg9bfu_test.go:61: expected '[]', got '[simple white space imple white space mple white space ple white space le white space hite space ite space te space pace ace ce e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpopsg9bfu_test.go:61: expected '[world]', got '[Hello world ello world orld rld ld d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpopsg9bfu_test.go:61: expected '[Uncle]', got '[Uncle sam ncle sam cle sam am m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpopsg9bfu_test.go:61: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            break\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i++\n        } else {\n            words = append(words, s[i:])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[little]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb y had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[]', got '[simple white space imple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[world]', got '[Hello world ello world ll o world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[Uncle]', got '[Uncle sam ncle sam cle sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(result) == n {\n            break\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, \"\")\n            continue\n        }\n        \n        result = append(result, s[i:i+1])\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp79ipv5gs_test.go:66: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp79ipv5gs_test.go:66: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp79ipv5gs_test.go:66: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp79ipv5gs_test.go:66: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp79ipv5gs_test.go:66: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp79ipv5gs_test.go:66: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            words = append(words, s[i-n:i])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var res []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(res) == n {\n            break\n        }\n        if i == len(s) - 1 {\n            res = append(res, s[i:])\n        } else {\n            res = append(res, s[i:i+1])\n        }\n    }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpd4v1go3h_test.go:62: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpd4v1go3h_test.go:62: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpd4v1go3h_test.go:62: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpd4v1go3h_test.go:62: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpd4v1go3h_test.go:62: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpd4v1go3h_test.go:62: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            break\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i+1:])\n            n--\n            i--\n            continue\n        }\n        if s[i] == ' ' {\n            result =\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz5s6iz00_test.go:102:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i + 1; j < len(s); j++ {\n            if s[j] == ' ' {\n                continue\n            }\n            if s[i] == s[j] {\n                if n == 1 {\n                    result = append(result, s[i:j])\n                    break\n                } else {\n                    n--\n                }\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp26kfbm1h_test.go:68: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp26kfbm1h_test.go:68: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp26kfbm1h_test.go:68: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp26kfbm1h_test.go:68: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp26kfbm1h_test.go:68: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        count := 0\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[j] == s[i] {\n                count++\n                if count == n {\n                    words = append(words, s[i:j])\n                    break\n                }\n            }\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpzzlfnci5_test.go:70: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpzzlfnci5_test.go:70: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpzzlfnci5_test.go:70: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpzzlfnci5_test.go:70: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpzzlfnci5_test.go:70: expected '[b c d f]', got '[     ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i + n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        if i + n == len(s) {\n            words = append(words, s[i:i+n])\n            i += n\n            continue\n        }\n        if i + n + 1 < len(s) {\n            if s[i + n + 1] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        if i + n + 1 == len(s) {\n            words = append(words, s[i:i+n])\n            i += n\n            continue\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpos93jsxr_test.go:77: expected '[little]', got '[Mary had  ittl lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpos93jsxr_test.go:77: expected '[Mary lamb]', got '[Mar had ttl lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpos93jsxr_test.go:77: expected '[]', got '[pl it ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpos93jsxr_test.go:77: expected '[world]', got '[Hell worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpos93jsxr_test.go:77: expected '[Uncle]', got '[ncl sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpos93jsxr_test.go:77: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            i++\n            continue\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i += 2\n            continue\n        }\n        \n        words = append(words, s[i:i+1])\n        i++\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmph_tc7tim_test.go:80: expected '[little]', got '[M r h d]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph_tc7tim_test.go:80: expected '[Mary lamb]', got '[M r h]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmph_tc7tim_test.go:80: expected '[]', got '[s m]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmph_tc7tim_test.go:80: expected '[world]', got '[H ll w r]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph_tc7tim_test.go:80: expected '[Uncle]', got '[U c e]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmph_tc7tim_test.go:80: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.019s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i + n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        words = append(words, s[i:])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp6rz82p8m_test.go:61: expected '[little]', got '[Mary had a little lamb ad a little lamb ittle lamb ttle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp6rz82p8m_test.go:61: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb little lamb ittle lamb ttle lamb tle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp6rz82p8m_test.go:61: expected '[]', got '[simple white space imple white space mple white space ple white space le white space hite space ite space te space pace ace ce e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp6rz82p8m_test.go:61: expected '[world]', got '[Hello world ello world orld rld ld d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp6rz82p8m_test.go:61: expected '[Uncle]', got '[Uncle sam ncle sam cle sam am m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp6rz82p8m_test.go:61: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Write your code here\n    var result []string\n    if len(s) == 0 {\n        return result\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(result) == n {\n            return result\n        }\n        \n        result = append(result, s[i:i+1])\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp54m2lxce_test.go:65: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp54m2lxce_test.go:65: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp54m2lxce_test.go:65: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp54m2lxce_test.go:65: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp54m2lxce_test.go:65: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp54m2lxce_test.go:65: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:i+1])\n            continue\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        \n        words = append(words, s[i:i+1])\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpkq_hsw5w_test.go:73: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpkq_hsw5w_test.go:73: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpkq_hsw5w_test.go:73: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpkq_hsw5w_test.go:73: expected '[world]', got '[H e ll o]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkq_hsw5w_test.go:73: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpkq_hsw5w_test.go:73: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // convert string to array of runes\n    runes := []rune(s)\n    \n    // create a map of runes to count\n    counts := make(map[rune]int)\n    \n    // iterate through runes\n    for _, r := range runes {\n        counts[r] += 1\n    }\n    \n    // create a slice of words\n    words := make([]string, 0)\n    \n    // iterate through runes\n    for _, r := range runes {\n        \n        // if the count is less than n, continue\n        if counts[r] < n {\n            continue\n        }\n        \n        // if the count is equal to n, add the word to the slice\n        if counts[r] == n {\n            words = append(words, string(r))\n        }\n        \n        // if the count is greater than n, decrement the count\n        if counts[r] > n {\n            counts[r] -= 1\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpz4j8vrap_test.go:81: expected '[little]', got '[a   a   a     a]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpz4j8vrap_test.go:81: expected '[Mary lamb]', got '[a   a   l l   l a]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpz4j8vrap_test.go:81: expected '[]', got '[s i p   i e   s p e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpz4j8vrap_test.go:81: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpz4j8vrap_test.go:81: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpz4j8vrap_test.go:81: expected '[b c d f]', got '[a b c d e   f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(s) - i >= n {\n            words = append(words, s[i:i+n])\n        }\n        \n        if len(s) - i < n {\n            break\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpylb0ixj__test.go:64: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpylb0ixj__test.go:64: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpylb0ixj__test.go:64: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpylb0ixj__test.go:64: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpylb0ixj__test.go:64: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpylb0ixj__test.go:64: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            words = append(words, s[i-n:i])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpegqbjsxg_test.go:57: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(s) - i >= n {\n            words = append(words, s[i:i+n])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmppwkcwlgi_test.go:60: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmppwkcwlgi_test.go:60: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmppwkcwlgi_test.go:60: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmppwkcwlgi_test.go:60: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmppwkcwlgi_test.go:60: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmppwkcwlgi_test.go:60: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5p_2bulh_test.go:94:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // Create a map of all words in the string\n    words := make(map[string]bool)\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        word := s[i:]\n        words[word] = true\n    }\n    \n    // Create a list of words that contain exactly n consonants\n    var result []string\n    for word, _ := range words {\n        if len(word) == n {\n            result = append(result, word)\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpi_rx_tlh_test.go:66: expected '[little]', got '[lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpi_rx_tlh_test.go:66: expected '[Mary lamb]', got '[amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpi_rx_tlh_test.go:66: expected '[]', got '[ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpi_rx_tlh_test.go:66: expected '[world]', got '[orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpi_rx_tlh_test.go:66: expected '[Uncle]', got '[sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpi_rx_tlh_test.go:66: expected '[b c d f]', got '[f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // TODO: implement function\n    \n    return []string{}\n}\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpcdtgsqea_test.go:66: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpcdtgsqea_test.go:66: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpcdtgsqea_test.go:66: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpcdtgsqea_test.go:66: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpcdtgsqea_test.go:66: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp0ms4uih6_test.go:77: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp0ms4uih6_test.go:77: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp0ms4uih6_test.go:77: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp0ms4uih6_test.go:77: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp0ms4uih6_test.go:77: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(result) == n {\n            break\n        }\n        \n        if i == len(s) - 1 {\n            result = append(result, s[i:])\n            break\n        }\n        \n        if s[i] == s[i+1] {\n            result = append(result, s[i:i+2])\n            i += 1\n        } else {\n            result = append(result, s[i:])\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmporj0t749_test.go:71: expected '[little]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb y had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmporj0t749_test.go:71: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmporj0t749_test.go:71: expected '[]', got '[simple white space imple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmporj0t749_test.go:71: expected '[world]', got '[Hello world ello world ll o world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmporj0t749_test.go:71: expected '[Uncle]', got '[Uncle sam ncle sam cle sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmporj0t749_test.go:71: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            words = append(words, s[i:i+n])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:i+1])\n            continue\n        }\n        \n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            continue\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            continue\n        }\n        \n        words = append(words, s[i:i+1])\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpzu7ub6ke_test.go:81: expected '[little]', got '[M a r y ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpzu7ub6ke_test.go:81: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpzu7ub6ke_test.go:81: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpzu7ub6ke_test.go:81: expected '[world]', got '[H e ll l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpzu7ub6ke_test.go:81: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpzu7ub6ke_test.go:81: expected '[b c d f]', got '[a ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsfztm5pi_test.go:105:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp57bbro0u_test.go:95:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            return words\n        }\n        if i == len(s) - 1 {\n            words = append(words, s[i:i+1])\n        } else {\n            words = append(words, s[i:i+1])\n            for j := i + 1; j < len(s); j++ {\n                if s[j] == ' ' {\n                    continue\n                }\n                if len(words) == n {\n                    return words\n                }\n                words = append(words, s[j:j+1])\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpuj4locrs_test.go:70: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpuj4locrs_test.go:70: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpuj4locrs_test.go:70: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpuj4locrs_test.go:70: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpuj4locrs_test.go:70: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpuj4locrs_test.go:70: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // Create a list of words\n    words := make([]string, 0)\n    \n    // Create a map of words and their counts\n    word_counts := make(map[string]int)\n    \n    // Iterate over each character in the string\n    for i := 0; i < len(s); i++ {\n        \n        // If the character is a space, then we need to skip it\n        if s[i] == ' ' {\n            continue\n        }\n        \n        // If the character is a letter, then we need to add it to the word\n        if s[i] >= 'a' && s[i] <= 'z' {\n            \n            // Get the word\n            word := s[i : i + 1]\n            \n            // Increment the count\n            count := word_counts[word]\n            word_counts[word] = count + 1\n            \n            // If the count is equal to the number of consonants, then we need to add it to the list\n            if count == n {\n                words = append(words, word)\n            }\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpobtbrvmo_test.go:79: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpobtbrvmo_test.go:79: expected '[Mary lamb]', got '[a]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpobtbrvmo_test.go:79: expected '[]', got '[e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpobtbrvmo_test.go:79: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpobtbrvmo_test.go:79: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpobtbrvmo_test.go:79: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // Create a map of words and their counts\n    words := make(map[string]int)\n    \n    // Create a list of words\n    words_list := make([]string, 0)\n    \n    // Create a word\n    word := \"\"\n    \n    // Iterate over the string\n    for i := 0; i < len(s); i++ {\n        \n        // If the character is a space\n        if s[i] == ' ' {\n            \n            // If the word is not empty\n            if word != \"\" {\n                \n                // Increment the count of the word\n                words[word]++\n                \n                // Append the word to the list\n                words_list = append(words_list, word)\n                \n                // Reset the word\n                word = \"\"\n            }\n        } else {\n            \n            // Append the character to the word\n            word += string(s[i])\n        }\n    }\n    \n    // If the word is not empty\n    if word != \"\" {\n        \n        // Increment the count of the word\n        words[word]++\n        \n        // Append the word to the list\n        words_list = append(words_list, word)\n    }\n    \n    // Iterate over the words\n    for _, word := range words_list {\n        \n        // If the word has exactly n consonants\n        if len(word) == n {\n            \n            // Return the word\n            return []string{word}\n        }\n    }\n    \n    // Return an empty list\n    return []string{}\n}\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n//\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp32l96avn_test.go:115: expected '[little]', got '[Mary]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp32l96avn_test.go:115: expected '[Mary lamb]', got '[had]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp32l96avn_test.go:115: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp32l96avn_test.go:115: expected '[Uncle]', got '[sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp32l96avn_test.go:115: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var words []string\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:i+1+n])\n            n -= 1\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:i+1+n])\n            n -= 1\n            continue\n        }\n        \n        words = append(words, s[i:i+1])\n        n--\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpo146tac4_test.go:80: expected '[little]', got '[M a r y h a d a l i t t l e l a m b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpo146tac4_test.go:80: expected '[Mary lamb]', got '[M a r y h a d a l i t t l e l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpo146tac4_test.go:80: expected '[]', got '[s i m p l e w h i t e s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpo146tac4_test.go:80: expected '[world]', got '[H e l l o w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpo146tac4_test.go:80: expected '[Uncle]', got '[U n c l e s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpo146tac4_test.go:80: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var res []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(res) == n {\n            break\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        res = append(res, s[i:i+1])\n    }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpltb1_bbg_test.go:64: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpltb1_bbg_test.go:64: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpltb1_bbg_test.go:64: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpltb1_bbg_test.go:64: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpltb1_bbg_test.go:64: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpltb1_bbg_test.go:64: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(result) == n {\n                break\n            }\n            continue\n        }\n        if len(result) == n {\n            break\n        }\n        result = append(result, s[i:i+1])\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i + 1; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[i] == s[j] {\n                if len(s) - i - j == n {\n                    result = append(result, s[i:j+1])\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp8oxlljvj_test.go:64: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8oxlljvj_test.go:64: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp8oxlljvj_test.go:64: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp8oxlljvj_test.go:64: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp8oxlljvj_test.go:64: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            words = append(words, s[i-n:i])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            result = append(result, s[i - n:i])\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i+n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        \n        if i+n < len(s) {\n            if s[i+n] != ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        \n        words = append(words, s[i:])\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpfgo2exj6_test.go:74: expected '[little]', got '[Mary had  litt e la b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpfgo2exj6_test.go:74: expected '[Mary lamb]', got '[Mar had a l ttl lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpfgo2exj6_test.go:74: expected '[]', got '[si pl wh te sp ce e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpfgo2exj6_test.go:74: expected '[world]', got '[Hell worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpfgo2exj6_test.go:74: expected '[Uncle]', got '[Unc e s m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpfgo2exj6_test.go:74: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            break\n        }\n        n--\n        if i > 0 && s[i-1] == ' ' {\n            continue\n        }\n        if i > 0 && s[i-1] != ' ' {\n            result = append(result, s[i-1:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp5bezrxkk_test.go:63: expected '[little]', got '[Ma ar ry]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp5bezrxkk_test.go:63: expected '[Mary lamb]', got '[Ma ar]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp5bezrxkk_test.go:63: expected '[]', got '[si]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp5bezrxkk_test.go:63: expected '[world]', got '[He el ll]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp5bezrxkk_test.go:63: expected '[Uncle]', got '[Un nc]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp5bezrxkk_test.go:63: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i++\n        } else {\n            words = append(words, s[i:])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpw0c2mobo_test.go:66: expected '[little]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb y had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpw0c2mobo_test.go:66: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpw0c2mobo_test.go:66: expected '[]', got '[simple white space imple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpw0c2mobo_test.go:66: expected '[world]', got '[Hello world ello world ll o world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpw0c2mobo_test.go:66: expected '[Uncle]', got '[Uncle sam ncle sam cle sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpw0c2mobo_test.go:66: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps3k6rx2d_test.go:104:15: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6mpt1s1l_test.go:107:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(s) - i >= n {\n            words = append(words, s[i:i+n])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpj1ixhcwp_test.go:63: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpj1ixhcwp_test.go:63: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpj1ixhcwp_test.go:63: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpj1ixhcwp_test.go:63: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpj1ixhcwp_test.go:63: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpj1ixhcwp_test.go:63: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i+1:i+1+n])\n            n -= len(s[i+1:i+1+n])\n            i += len(s[i+1:i+1+n])\n            continue\n        }\n        if n == 1 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i+1:i+1+n])\n            n -= len(s[i+1:i+1+n])\n            i += len(s[i+1:i+1+n])\n            continue\n        }\n        if n == 2 {\n            words = append(words, s[i:i+2])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i+1:i+1+n])\n            n -= len(s[i+1:i+1+n])\n            i += len(s[i+1:i+1+n])\n            continue\n        }\n        words = append(words, s[i:i+n])\n        n -= len(s[i:i+n])\n        i += len(s[i:i+n])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: slice bounds out of range [2:1] [recovered]\n\tpanic: runtime error: slice bounds out of range [2:1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.select_words(0x548e1e, 0x16, 0x4, 0x0, 0x609a20, 0x5fa280)\n\t/tmp/tmppc0wns8__test.go:63 +0x3c5\ncommand-line-arguments_test.TestSelect_Words(0xc000186300)\n\t/tmp/tmppc0wns8__test.go:77 +0x5f\ntesting.tRunner(0xc000186300, 0x54f248)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i + 1; j < len(s); j++ {\n            if s[j] == ' ' {\n                continue\n            }\n            if n == 0 {\n                break\n            }\n            n--\n            result = append(result, s[i:j])\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpv6fo_4se_test.go:63: expected '[little]', got '[M Ma Mar Mary ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpv6fo_4se_test.go:63: expected '[Mary lamb]', got '[M Ma Mar]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpv6fo_4se_test.go:63: expected '[]', got '[s si]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpv6fo_4se_test.go:63: expected '[world]', got '[H He Hel Hell]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpv6fo_4se_test.go:63: expected '[Uncle]', got '[U Un Unc]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpv6fo_4se_test.go:63: expected '[b c d f]', got '[a ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            break\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            i++\n            continue\n        }\n        \n        for j := i + 1; j < len(s); j++ {\n            if s[i] == s[j] {\n                words = append(words, s[i:j+1])\n                i = j\n                break\n            }\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmptg1tqawh_test.go:88: expected '[little]', got '[ary ha a little la b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptg1tqawh_test.go:88: expected '[Mary lamb]', got '[ary ha a little la b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmptg1tqawh_test.go:88: expected '[]', got '[simple white s e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmptg1tqawh_test.go:88: expected '[world]', got '[ll o wo d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptg1tqawh_test.go:88: expected '[Uncle]', got '[m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmptg1tqawh_test.go:88: expected '[b c d f]', got '[f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // TODO: Implement this function\n    \n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp5lmn8qbp_test.go:50: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp5lmn8qbp_test.go:50: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp5lmn8qbp_test.go:50: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp5lmn8qbp_test.go:50: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp5lmn8qbp_test.go:50: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i = i + 2\n        } else {\n            words = append(words, s[i:])\n            i = i + 1\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpu2kp6rhs_test.go:81: expected '[little]', got '[Mary had a little lamb ry had a little lamb had a little lamb d a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpu2kp6rhs_test.go:81: expected '[Mary lamb]', got '[Mary had a little lamb ry had a little lamb had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpu2kp6rhs_test.go:81: expected '[]', got '[simple white space mple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpu2kp6rhs_test.go:81: expected '[world]', got '[Hello world ll world rld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpu2kp6rhs_test.go:81: expected '[Uncle]', got '[Uncle sam cle sam e sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpu2kp6rhs_test.go:81: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            words = append(words, s[i:i+n])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp8gh2fctr_test.go:60: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8gh2fctr_test.go:60: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp8gh2fctr_test.go:60: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp8gh2fctr_test.go:60: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp8gh2fctr_test.go:60: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp8gh2fctr_test.go:60: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n > len(s) {\n            break\n        }\n        words = append(words, s[i:i+n])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpd7od3f01_test.go:58: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpd7od3f01_test.go:58: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpd7od3f01_test.go:58: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpd7od3f01_test.go:58: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpd7od3f01_test.go:58: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpd7od3f01_test.go:58: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:])\n            break\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            break\n        }\n        n--\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpv1ky0nc__test.go:62: expected '[little]', got '[had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpv1ky0nc__test.go:62: expected '[Mary lamb]', got '[y had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpv1ky0nc__test.go:62: expected '[]', got '[mple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpv1ky0nc__test.go:62: expected '[world]', got '[o world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpv1ky0nc__test.go:62: expected '[Uncle]', got '[le sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpv1ky0nc__test.go:62: expected '[b c d f]', got '[b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            words = append(words, s[i - n:i])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp54uqpu4d_test.go:56: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp54uqpu4d_test.go:56: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp54uqpu4d_test.go:56: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp54uqpu4d_test.go:56: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp54uqpu4d_test.go:56: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp54uqpu4d_test.go:56: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    var words []string\n    words = strings.Split(s, \" \")\n    for _, word := range words {\n        if len(word) > n {\n            continue\n        }\n        result = append(result, word)\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2vkblbew_test.go:27:13: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374747,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5p_2bulh_test.go:94:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            break\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 1 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4serne86_test.go:124:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[i] == s[j] {\n                if len(result) == n {\n                    break\n                }\n                result = append(result, s[i:j])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp22e156ym_test.go:64: expected '[little]', got '[   ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp22e156ym_test.go:64: expected '[Mary lamb]', got '[  ]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp22e156ym_test.go:64: expected '[]', got '[ ]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp22e156ym_test.go:64: expected '[world]', got '[   l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp22e156ym_test.go:64: expected '[Uncle]', got '[  ]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp22e156ym_test.go:64: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    if len(s) == 0 {\n        return result\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i + n > len(s) {\n            break\n        }\n        \n        if s[i:i+n] == \" \" {\n            continue\n        }\n        \n        result = append(result, s[i:i+n])\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp_wcp0juv_test.go:68: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp_wcp0juv_test.go:68: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp_wcp0juv_test.go:68: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp_wcp0juv_test.go:68: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp_wcp0juv_test.go:68: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp_wcp0juv_test.go:68: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(result) == n {\n            break\n        }\n        result = append(result, s[i:i+1])\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqs19v72s_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqs19v72s_test.go:58: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpqs19v72s_test.go:58: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqs19v72s_test.go:58: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqs19v72s_test.go:58: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqs19v72s_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Write your code here\n    var words []string\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            if n == 1 {\n                words = append(words, s[i:i+n])\n            } else {\n                for j := i; j < i + n; j++ {\n                    if s[j] == ' ' {\n                        continue\n                    }\n                    words = append(words, s[i:j])\n                }\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp_733zvxg_test.go:69: expected '[little]', got '[ M Ma Mar  a ar  r ry   y  y h  h ha  a ad   d   a  a l  l li lit  i it itt  t tt ttl  t tl  l le   e  e l  l la lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp_733zvxg_test.go:69: expected '[Mary lamb]', got '[ M Ma  a ar  r  y   h ha  a  d   a   l li  i it  t tt  t tl  l  e   l la  a am]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp_733zvxg_test.go:69: expected '[]', got '[ s  i  m  p  l   w  h  i  t   s  p  a  c]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp_733zvxg_test.go:69: expected '[world]', got '[ H He Hel  e el ell  l ll  l lo   o  o w  w wo wor  o or orl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp_733zvxg_test.go:69: expected '[Uncle]', got '[ U Un  n nc  c cl  l  e   s sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp_733zvxg_test.go:69: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(result) == n {\n            break\n        }\n        \n        if i == len(s) - 1 {\n            result = append(result, s[i:])\n            break\n        }\n        \n        if s[i+1] == ' ' {\n            result = append(result, s[i:i+2])\n            i++\n            continue\n        }\n        \n        if s[i+1] != ' ' {\n            result = append(result, s[i:i+1])\n            i++\n            continue\n        }\n        \n        if s[i+2] == ' ' {\n            result = append(result, s[i:i+3])\n            i += 2\n            continue\n        }\n        \n        if s[i+2] != ' ' {\n            result = append(result, s[i:i+2])\n            i += 2\n            continue\n        }\n        \n        if s[i+3] == ' ' {\n            result = append(result, s[i:i+4])\n            i += 3\n            continue\n        }\n        \n        if s[i+3] != ' ' {\n            result = append(result, s[i:i+3])\n            i += 3\n            continue\n        }\n        \n        if s[i+4] == ' ' {\n            result = append(result, s[i:i+5])\n            i += 4\n            continue\n        }\n        \n        if s[i+4] != ' ' {\n            result = append(result, s[i:i+4])\n            i += 4\n            continue\n        }\n        \n        if s[i+5] == ' ' {\n            result = append(result, s[i:i+6])\n            i += 5\n            continue\n        }\n        \n        if s[i+5] != ' ' {\n            result = append(result, s[i:i+5])\n            i += 5\n            continue\n        }\n        \n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvlpba80r_test.go:102:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i + n <= len(s) {\n            if s[i:i+n] == \" \" {\n                continue\n            }\n            \n            words = append(words, s[i:i+n])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp8d0m2ykj_test.go:64: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8d0m2ykj_test.go:64: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp8d0m2ykj_test.go:64: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp8d0m2ykj_test.go:64: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp8d0m2ykj_test.go:64: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp8d0m2ykj_test.go:64: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        words = append(words, s[i:i+1])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[i] == s[j] {\n                if n == 1 {\n                    result = append(result, s[i:j+1])\n                    break\n                } else {\n                    n--\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpltx29pxf_test.go:66: expected '[little]', got '[y h a d a l i t t l e l a m b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpltx29pxf_test.go:66: expected '[Mary lamb]', got '[r y h a d a l i t t l e l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpltx29pxf_test.go:66: expected '[]', got '[i m p l e w h i t e s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpltx29pxf_test.go:66: expected '[world]', got '[ll l o w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpltx29pxf_test.go:66: expected '[Uncle]', got '[c l e s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpltx29pxf_test.go:66: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj6z95jcv_test.go:92:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp87mlnqcv_test.go:104:38: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[i] == s[j] {\n                if len(s) - i - j == n {\n                    result = append(result, s[i:j+1])\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[little]', got '[a]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[]', got '[h]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[Uncle]', got '[l]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] != ' ' {\n            words = append(words, s[i:i+1])\n            i++\n            continue\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpfcs3emw4_test.go:70: expected '[little]', got '[M r h d ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpfcs3emw4_test.go:70: expected '[Mary lamb]', got '[M r h]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpfcs3emw4_test.go:70: expected '[]', got '[s m]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpfcs3emw4_test.go:70: expected '[world]', got '[H l o  w]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpfcs3emw4_test.go:70: expected '[Uncle]', got '[U c e ]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpfcs3emw4_test.go:70: expected '[b c d f]', got '[a ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Write your code here\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            words = append(words, s[i-n:i])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpbc4y7w7g_test.go:57: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbc4y7w7g_test.go:57: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpbc4y7w7g_test.go:57: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpbc4y7w7g_test.go:57: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbc4y7w7g_test.go:57: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpbc4y7w7g_test.go:57: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    if len(s) == 0 {\n        return result\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(s) - i >= n {\n            result = append(result, s[i:i+n])\n        }\n        \n        if i + n > len(s) {\n            break\n        }\n        \n        for j := i + 1; j < i + n; j++ {\n            if s[j] == ' ' {\n                continue\n            }\n            \n            if i + n - j >= n {\n                result = append(result, s[i:i+n-j])\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp8u7ok9lg_test.go:77: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8u7ok9lg_test.go:77: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp8u7ok9lg_test.go:77: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp8u7ok9lg_test.go:77: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp8u7ok9lg_test.go:77: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp8u7ok9lg_test.go:77: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            result = append(result, s[i-n:i+1])\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpekhk8171_test.go:56: expected '[little]', got '[ary h ry ha y had had a d a l  a li a lit  litt littl ittle tle l le la e lam  lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpekhk8171_test.go:56: expected '[Mary lamb]', got '[Mary ry h y ha  had ad a  a l a li  lit litt ittl ttle le l e la  lam lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpekhk8171_test.go:56: expected '[]', got '[sim imp mpl ple e w  wh whi hit ite e s  sp spa pac ace]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpekhk8171_test.go:56: expected '[world]', got '[Hello llo w lo wo o wor  worl world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpekhk8171_test.go:56: expected '[Uncle]', got '[Uncl ncle le s e sa  sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpekhk8171_test.go:56: expected '[b c d f]', got '[ b  c  d  e  f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            words = append(words, s[i:i+n])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpjz7jy6w8_test.go:56: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        words = append(words, s[i:i+1])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmphw_fls5q_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmphw_fls5q_test.go:58: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmphw_fls5q_test.go:58: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmphw_fls5q_test.go:58: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmphw_fls5q_test.go:58: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmphw_fls5q_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // if the string is empty return an empty list\n    if len(s) == 0 {\n        return []string{}\n    }\n    \n    // create a map to store the words\n    words := make(map[string]bool)\n    \n    // create a slice to store the words\n    var words_list []string\n    \n    // iterate through the string\n    for i := 0; i < len(s); i++ {\n        \n        // if the current character is a space\n        if s[i] == ' ' {\n            \n            // if the word is not in the map\n            if _, ok := words[s[0:i]]; !ok {\n                \n                // add the word to the map\n                words[s[0:i]] = true\n                \n                // add the word to the list\n                words_list = append(words_list, s[0:i])\n            }\n        }\n    }\n    \n    // return the list of words\n    return words_list\n}\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp9jys3avw_test.go:94: expected '[little]', got '[Mary Mary had Mary had a Mary had a little]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp9jys3avw_test.go:94: expected '[Mary lamb]', got '[Mary Mary had Mary had a Mary had a little]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp9jys3avw_test.go:94: expected '[]', got '[simple simple white]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp9jys3avw_test.go:94: expected '[world]', got '[Hello]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp9jys3avw_test.go:94: expected '[b c d f]', got '[a a b a b c a b c d a b c d e]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            return words\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i++\n        } else {\n            words = append(words, s[i:])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpg9jo_nq8_test.go:72: expected '[little]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb y had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpg9jo_nq8_test.go:72: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpg9jo_nq8_test.go:72: expected '[]', got '[simple white space imple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpg9jo_nq8_test.go:72: expected '[world]', got '[Hello world ello world ll o world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpg9jo_nq8_test.go:72: expected '[Uncle]', got '[Uncle sam ncle sam cle sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpg9jo_nq8_test.go:72: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[j] == s[i] {\n                if len(words) == n {\n                    break\n                }\n                words = append(words, s[i:j+1])\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp4esezres_test.go:64: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp4esezres_test.go:64: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp4esezres_test.go:64: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp4esezres_test.go:64: expected '[world]', got '[H e l ll]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp4esezres_test.go:64: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp4esezres_test.go:64: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if len(s) - i >= n {\n            words = append(words, s[i:i+n])\n        }\n        \n        for j := i + 1; j < len(s); j++ {\n            if s[j] == ' ' {\n                continue\n            }\n            \n            if len(words) == n {\n                return words\n            }\n            \n            if len(s) - j >= n {\n                words = append(words, s[j:j+n])\n            }\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpd1y27mfj_test.go:82: expected '[little]', got '[Mary ary  ry h y ha]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpd1y27mfj_test.go:82: expected '[Mary lamb]', got '[Mar ary ry ]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpd1y27mfj_test.go:82: expected '[]', got '[si im]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpd1y27mfj_test.go:82: expected '[world]', got '[Hell ello llo  lo w]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpd1y27mfj_test.go:82: expected '[Uncle]', got '[Unc ncl cle]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpd1y27mfj_test.go:82: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        words = append(words, s[i:])\n        break\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp5rhpzdzv_test.go:62: expected '[little]', got '[Mary had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp5rhpzdzv_test.go:62: expected '[Mary lamb]', got '[Mary had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp5rhpzdzv_test.go:62: expected '[]', got '[simple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp5rhpzdzv_test.go:62: expected '[world]', got '[Hello world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp5rhpzdzv_test.go:62: expected '[Uncle]', got '[Uncle sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp5rhpzdzv_test.go:62: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[i] == s[j] {\n                if len(s) - i - j == n {\n                    result = append(result, s[i:j+1])\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[little]', got '[a]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[]', got '[h]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[Uncle]', got '[l]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    var words []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        \n        words = append(words, s[i:])\n        break\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp45tq6xe6_test.go:67: expected '[little]', got '[Mary had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp45tq6xe6_test.go:67: expected '[Mary lamb]', got '[Mary had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp45tq6xe6_test.go:67: expected '[]', got '[simple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp45tq6xe6_test.go:67: expected '[world]', got '[Hello world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp45tq6xe6_test.go:67: expected '[Uncle]', got '[Uncle sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp45tq6xe6_test.go:67: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // create a map to store the words\n    words := make(map[string]bool)\n    \n    // create a list to store the words\n    words_list := make([]string, 0)\n    \n    // create a string to store the word\n    word := \"\"\n    \n    // iterate through the string\n    for i := 0; i < len(s); i++ {\n        \n        // if the current character is a space\n        if s[i] == ' ' {\n            \n            // if the word is not empty\n            if word != \"\" {\n                \n                // add the word to the list\n                words_list = append(words_list, word)\n                \n                // clear the word\n                word = \"\"\n            }\n        } else {\n            \n            // if the current character is a letter\n            if s[i] >= 'a' && s[i] <= 'z' {\n                \n                // add the current character to the word\n                word += string(s[i])\n            } else {\n                \n                // if the word is not empty\n                if word != \"\" {\n                    \n                    // add the word to the list\n                    words_list = append(words_list, word)\n                    \n                    // clear the word\n                    word = \"\"\n                }\n            }\n        }\n    }\n    \n    // if the word is not empty\n    if word != \"\" {\n        \n        // add the word to the list\n        words_list = append(words_list, word)\n    }\n    \n    // iterate through the list\n    for _, word := range words_list {\n        \n        // if the word contains exactly n consonants\n        if len(word) == n {\n            \n            // add the word to the list\n            words[word] = true\n        }\n    }\n    \n    // iterate through the map\n    for word, _ := range words {\n        \n        // add the word to the list\n        words_list = append(words_list, word)\n    }\n    \n    // return the list\n    return words_list\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp9gzuy5yk_test.go:120: expected '[little]', got '[ary had a little lamb lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp9gzuy5yk_test.go:120: expected '[Mary lamb]', got '[ary had a little lamb had ary]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp9gzuy5yk_test.go:120: expected '[]', got '[simple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp9gzuy5yk_test.go:120: expected '[world]', got '[ello world ello]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp9gzuy5yk_test.go:120: expected '[Uncle]', got '[ncle sam sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp9gzuy5yk_test.go:120: expected '[b c d f]', got '[a b c d e f b c d e f a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        words = append(words, s[i:])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpd_48rkzs_test.go:61: expected '[little]', got '[Mary had a little lamb ad a little lamb ittle lamb ttle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpd_48rkzs_test.go:61: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb little lamb ittle lamb ttle lamb tle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpd_48rkzs_test.go:61: expected '[]', got '[simple white space imple white space mple white space ple white space le white space hite space ite space te space pace ace ce e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpd_48rkzs_test.go:61: expected '[world]', got '[Hello world ello world orld rld ld d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpd_48rkzs_test.go:61: expected '[Uncle]', got '[Uncle sam ncle sam cle sam am m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpd_48rkzs_test.go:61: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            if n == 1 {\n                words = append(words, s[i:i+n])\n            } else {\n                words = append(words, s[i:i+n])\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp058ddaq9_test.go:64: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp058ddaq9_test.go:64: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp058ddaq9_test.go:64: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp058ddaq9_test.go:64: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp058ddaq9_test.go:64: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp058ddaq9_test.go:64: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Write your code here\n    var result []string\n    if len(s) == 0 {\n        return result\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp60xkj1_f_test.go:87: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp60xkj1_f_test.go:87: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp60xkj1_f_test.go:87: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp60xkj1_f_test.go:87: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp60xkj1_f_test.go:87: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[i] == s[j] {\n                if len(s) - i - j == n {\n                    result = append(result, s[i:j+1])\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[little]', got '[a]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[]', got '[h]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[Uncle]', got '[l]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpjlaqv8x1_test.go:63: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            break\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp81fpl6h9_test.go:115:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            if s[i:i+n] == \" \" {\n                words = append(words, s[i:i+n])\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpi4n8qdrl_test.go:58: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpi4n8qdrl_test.go:58: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpi4n8qdrl_test.go:58: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpi4n8qdrl_test.go:58: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpi4n8qdrl_test.go:58: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            result = append(result, s[i - n:i])\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpjmrimgwg_test.go:56: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] != ' ' {\n            words = append(words, s[i:i+1])\n            i++\n            continue\n        }\n        words = append(words, s[i:i+2])\n        i++\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpts7btlz5_test.go:72: expected '[little]', got '[M r h d ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpts7btlz5_test.go:72: expected '[Mary lamb]', got '[M r h]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpts7btlz5_test.go:72: expected '[]', got '[s m]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpts7btlz5_test.go:72: expected '[world]', got '[H l o  w]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpts7btlz5_test.go:72: expected '[Uncle]', got '[U c e ]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpts7btlz5_test.go:72: expected '[b c d f]', got '[a ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu0ue2ylc_test.go:82:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    if len(s) == 0 {\n        return result\n    }\n    \n    var word string\n    var count int\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if count == n {\n                word = word + \" \"\n                count = 0\n            }\n        } else {\n            if count < n {\n                count++\n                word = word + s[i]\n            } else {\n                if len(word) > 0 {\n                    result = append(result, word)\n                }\n                word = \"\"\n                count = 0\n            }\n        }\n    }\n    \n    if len(word) > 0 {\n        result = append(result, word)\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptkcsy7xq_test.go:42:29: invalid operation: word + s[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    if len(s) == 0 {\n        return result\n    }\n    \n    words := strings.Split(s, \" \")\n    for _, word := range words {\n        if len(word) == 0 {\n            continue\n        }\n        \n        consonants := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            \n            consonants++\n            if consonants == n {\n                result = append(result, word)\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp1i02vh7_test.go:31:14: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk5jkyvqz_test.go:93:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        if s[i+1] == ' ' {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        if s[i+1] != ' ' {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpfu9cbbt8_test.go:68: expected '[little]', got '[M a r y ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpfu9cbbt8_test.go:68: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpfu9cbbt8_test.go:68: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpfu9cbbt8_test.go:68: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpfu9cbbt8_test.go:68: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpfu9cbbt8_test.go:68: expected '[b c d f]', got '[a ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i + n <= len(s) {\n            if s[i:i+n] == \" \" {\n                continue\n            }\n            \n            words = append(words, s[i:i+n])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpe77ob_1k_test.go:64: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpe77ob_1k_test.go:64: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpe77ob_1k_test.go:64: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpe77ob_1k_test.go:64: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpe77ob_1k_test.go:64: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpe77ob_1k_test.go:64: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    \n    if len(s) == 0 {\n        return result\n    }\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            break\n        }\n        \n        words = append(words, s[i:i+1])\n    }\n    \n    for i := 0; i < len(words); i++ {\n        for j := 0; j < len(words); j++ {\n            if words[i] == words[j] {\n                result = append(result, words[i])\n                break\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpt0kcyj12_test.go:77: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpt0kcyj12_test.go:77: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpt0kcyj12_test.go:77: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpt0kcyj12_test.go:77: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpt0kcyj12_test.go:77: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpt0kcyj12_test.go:77: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            if n == 0 {\n                words = append(words, s[i:i+n])\n            } else {\n                words = append(words, s[i:i+n])\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpytvwo9_l_test.go:63: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpytvwo9_l_test.go:63: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpytvwo9_l_test.go:63: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpytvwo9_l_test.go:63: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpytvwo9_l_test.go:63: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpytvwo9_l_test.go:63: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpf5dri2fc_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpf5dri2fc_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpf5dri2fc_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpf5dri2fc_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpf5dri2fc_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            words = append(words, s[i-n:i])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpkgo1i425_test.go:59: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpkgo1i425_test.go:59: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpkgo1i425_test.go:59: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpkgo1i425_test.go:59: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkgo1i425_test.go:59: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpkgo1i425_test.go:59: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    \n    if len(s) == 0 {\n        return result\n    }\n    \n    words := strings.Split(s, \" \")\n    \n    for _, word := range words {\n        if len(word) == 0 {\n            continue\n        }\n        \n        consonants := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            \n            consonants += 1\n        }\n        \n        if consonants == n {\n            result = append(result, word)\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp31pbi4qg_test.go:32:14: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:i+1])\n            continue\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i++\n            continue\n        }\n        \n        words = append(words, s[i:i+1])\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpgdwocu_i_test.go:73: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpgdwocu_i_test.go:73: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpgdwocu_i_test.go:73: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpgdwocu_i_test.go:73: expected '[world]', got '[H e ll o]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpgdwocu_i_test.go:73: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpgdwocu_i_test.go:73: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(s) - i >= n {\n            words = append(words, s[i:i+n])\n        }\n        \n        if i + n > len(s) {\n            break\n        }\n        \n        for j := i + 1; j < i + n; j++ {\n            if s[j] == ' ' {\n                continue\n            }\n            \n            if len(s) - j >= n {\n                words = append(words, s[j:j+n])\n            }\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzrkx7n3_test.go:77: expected '[little]', got '[Mary ary  ry h y ha ary  ry h y ha ry h y ha had  y ha had  ad a had  ad a d a  ad a d a  a li d a  a li a li litt ittl litt ittl ttle tle  ittl ttle tle  le l ttle tle  le l e la tle  le l e la le l e la lamb e la lamb lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzrkx7n3_test.go:77: expected '[Mary lamb]', got '[Mar ary ry  ary ry  y h ry  y h y h had had ad  d a ad  d a d a a l a l lit lit itt ttl itt ttl tle ttl tle le  tle le  e l le  e l e l lam lam amb amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpqzrkx7n3_test.go:77: expected '[]', got '[si im im mp mp pl pl le le e  e  wh hi hi it it te te e  e  sp pa pa ac ac ce ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzrkx7n3_test.go:77: expected '[world]', got '[Hell ello llo  lo w ello llo  lo w o wo llo  lo w o wo lo w o wo worl o wo worl orld worl orld orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzrkx7n3_test.go:77: expected '[Uncle]', got '[Unc ncl cle ncl cle le  cle le  e s le  e s e s sam sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzrkx7n3_test.go:77: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i + n <= len(s) {\n            words = append(words, s[i:i+n])\n        }\n        \n        if i + n < len(s) {\n            i += n - 1\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmprkul2ebe_test.go:67: expected '[little]', got '[Mary had  a li ttle lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmprkul2ebe_test.go:67: expected '[Mary lamb]', got '[Mar y h ad  a l itt le  lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmprkul2ebe_test.go:67: expected '[]', got '[si mp le wh it e  sp ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmprkul2ebe_test.go:67: expected '[world]', got '[Hell o wo]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmprkul2ebe_test.go:67: expected '[Uncle]', got '[Unc le  sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmprkul2ebe_test.go:67: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    words := make([]string, 0)\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(s) - i >= n {\n            words = append(words, s[i:i+n])\n        }\n        \n        if len(s) - i < n {\n            break\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp9dq68z3b_test.go:67: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp9dq68z3b_test.go:67: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp9dq68z3b_test.go:67: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp9dq68z3b_test.go:67: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp9dq68z3b_test.go:67: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp9dq68z3b_test.go:67: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[j] == s[i] {\n                if n == 1 {\n                    result = append(result, s[i:j])\n                    break\n                } else {\n                    n--\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpt0jg_m8f_test.go:66: expected '[little]', got '[              ]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpt0jg_m8f_test.go:66: expected '[Mary lamb]', got '[               ]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpt0jg_m8f_test.go:66: expected '[]', got '[              ]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpt0jg_m8f_test.go:66: expected '[world]', got '[l       ]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpt0jg_m8f_test.go:66: expected '[Uncle]', got '[     ]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpt0jg_m8f_test.go:66: expected '[b c d f]', got '[     ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            words = append(words, s[i:i+n])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpbclr4vvl_test.go:59: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbclr4vvl_test.go:59: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpbclr4vvl_test.go:59: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpbclr4vvl_test.go:59: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbclr4vvl_test.go:59: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpbclr4vvl_test.go:59: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(result) == n {\n            break\n        }\n        result = append(result, s[i:i+1])\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmplk_xur6k_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmplk_xur6k_test.go:58: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmplk_xur6k_test.go:58: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmplk_xur6k_test.go:58: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmplk_xur6k_test.go:58: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmplk_xur6k_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                break\n            }\n            continue\n        }\n        words = append(words, s[i:i+1])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpxfbrccjo_test.go:57: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpxfbrccjo_test.go:57: expected '[Mary lamb]', got '[M a r y h a d a l i t t l e l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpxfbrccjo_test.go:57: expected '[]', got '[s i m p l e w h i t e s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpxfbrccjo_test.go:57: expected '[world]', got '[H e l l o w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpxfbrccjo_test.go:57: expected '[Uncle]', got '[U n c l e s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpxfbrccjo_test.go:57: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp84fmvsis_test.go:97:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i - n >= 0 {\n            words = append(words, s[i-n:i])\n        }\n        \n        for j := i + 1; j < len(s); j++ {\n            if s[j] == ' ' {\n                continue\n            }\n            \n            if j - n >= 0 {\n                words = append(words, s[j-n:j])\n            }\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpilemu7h5_test.go:74: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam had  d a   a l a li  lit litt ittl tle  le l e la  lam d a   a l a li  lit litt ittl tle  le l e la  lam  a l a li  lit litt ittl tle  le l e la  lam a li  lit litt ittl tle  le l e la  lam  lit litt ittl tle  le l e la  lam litt ittl tle  le l e la  lam ittl tle  le l e la  lam tle  le l e la  lam le l e la  lam e la  lam  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpilemu7h5_test.go:74: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam y h  ha ad   a  a l  li lit itt ttl le  e l  la lam  ha ad   a  a l  li lit itt ttl le  e l  la lam ad   a  a l  li lit itt ttl le  e l  la lam  a  a l  li lit itt ttl le  e l  la lam a l  li lit itt ttl le  e l  la lam  li lit itt ttl le  e l  la lam lit itt ttl le  e l  la lam itt ttl le  e l  la lam ttl le  e l  la lam le  e l  la lam e l  la lam  la lam lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpilemu7h5_test.go:74: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac si im mp pl e   w wh hi it e   s sp pa ac si im mp pl e   w wh hi it e   s sp pa ac im mp pl e   w wh hi it e   s sp pa ac mp pl e   w wh hi it e   s sp pa ac pl e   w wh hi i",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            words = append(words, s[i-n:i])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpyt74n65d_test.go:56: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpyt74n65d_test.go:56: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpyt74n65d_test.go:56: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpyt74n65d_test.go:56: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpyt74n65d_test.go:56: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpyt74n65d_test.go:56: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        words = append(words, s[i:i+1])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            words = append(words, s[i:i+n])\n        }\n        i++\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp365h03v6_test.go:61: expected '[little]', got '[Mary ry h had  d a  a li litt ttle le l lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp365h03v6_test.go:61: expected '[Mary lamb]', got '[Mar ry  had d a a l lit ttl le  lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp365h03v6_test.go:61: expected '[]', got '[si mp le wh it e  sp ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp365h03v6_test.go:61: expected '[world]', got '[Hell llo  o wo worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp365h03v6_test.go:61: expected '[Uncle]', got '[Unc cle e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp365h03v6_test.go:61: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    if len(s) == 0 {\n        return result\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(result) == n {\n            break\n        }\n        \n        if s[i] == ' ' {\n            continue\n        }\n        \n        result = append(result, s[i:i+1])\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqdh62_lu_test.go:69: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqdh62_lu_test.go:69: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpqdh62_lu_test.go:69: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqdh62_lu_test.go:69: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqdh62_lu_test.go:69: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqdh62_lu_test.go:69: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8norb8ig_test.go:94:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            break\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 1 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 2 {\n            result = append(result, s[i:i+2])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 3 {\n            result = append(result, s[i:i+3])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 4 {\n            result = append(result, s[i:i+4])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 5 {\n            result = append(result, s[i:i+5])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 6 {\n            result = append(result, s[i:i+6])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 7 {\n            result = append(result, s[i:i+7])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        \n        if n == 8 {\n            result = append(result, s[i:i+8])\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpth7q8chq_test.go:122:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    words := make([]string, 0)\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        if i + n < len(s) {\n            if s[i+n] != ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpk7zwemi2_test.go:74: expected '[little]', got '[Mary had  litt e la]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpk7zwemi2_test.go:74: expected '[Mary lamb]', got '[Mar had a l ttl lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpk7zwemi2_test.go:74: expected '[]', got '[si pl wh te sp]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpk7zwemi2_test.go:74: expected '[world]', got '[Hell worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpk7zwemi2_test.go:74: expected '[Uncle]', got '[Unc e s]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpk7zwemi2_test.go:74: expected '[b c d f]', got '[a b c d e]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        count := 0\n        for j := i; j < len(s); j++ {\n            if s[j] == ' ' {\n                break\n            }\n            if s[j] == s[i] {\n                count++\n                if count == n {\n                    result = append(result, s[i:j])\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmposny5_bs_test.go:66: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmposny5_bs_test.go:66: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmposny5_bs_test.go:66: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmposny5_bs_test.go:66: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmposny5_bs_test.go:66: expected '[b c d f]', got '[     ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                result = append(result, s[i:i+n])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpcewxnkvo_test.go:58: expected '[little]', got '[Mary ad a ttle]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpcewxnkvo_test.go:58: expected '[Mary lamb]', got '[ary had d a tle]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpcewxnkvo_test.go:58: expected '[]', got '[le te]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpcewxnkvo_test.go:58: expected '[world]', got '[ello]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpcewxnkvo_test.go:58: expected '[Uncle]', got '[cle]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpcewxnkvo_test.go:58: expected '[b c d f]', got '[a b c d e]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            break\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            break\n        }\n        \n        if s[i] == s[i+1] {\n            words = append(words, s[i:i+2])\n            i++\n        } else {\n            words = append(words, s[i:])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[little]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb y had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb ry had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[]', got '[simple white space imple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[world]', got '[Hello world ello world ll o world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[Uncle]', got '[Uncle sam ncle sam cle sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpr2kd25ry_test.go:72: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps3k6rx2d_test.go:104:15: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        words = append(words, s[i:i+1])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk5jkyvqz_test.go:93:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n < len(s) {\n            if s[i+n] == ' ' {\n                result = append(result, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        result = append(result, s[i:])\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpteegiba8_test.go:61: expected '[little]', got '[Mary had a little lamb ad a little lamb ittle lamb ttle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpteegiba8_test.go:61: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb little lamb ittle lamb ttle lamb tle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpteegiba8_test.go:61: expected '[]', got '[simple white space imple white space mple white space ple white space le white space hite space ite space te space pace ace ce e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpteegiba8_test.go:61: expected '[world]', got '[Hello world ello world orld rld ld d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpteegiba8_test.go:61: expected '[Uncle]', got '[Uncle sam ncle sam cle sam am m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpteegiba8_test.go:61: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpqzdzizmq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if len(words) == 0 {\n            words = append(words, s[i:i+1])\n            continue\n        }\n        \n        if len(words) < n {\n            words = append(words, s[i:i+1])\n            continue\n        }\n        \n        if len(words) == n {\n            words = append(words, s[i:i+1])\n            continue\n        }\n        \n        if len(words) > n {\n            words = append(words[:len(words)-1], s[i:i+1])\n            continue\n        }\n        \n        if len(words) == n {\n            words = append(words, s[i:i+1])\n            continue\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmppzasmp3p_test.go:89: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmppzasmp3p_test.go:89: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmppzasmp3p_test.go:89: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmppzasmp3p_test.go:89: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmppzasmp3p_test.go:89: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmppzasmp3p_test.go:89: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] == ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] != ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] != ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] != ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] != ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] != ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] != ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] != ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] != ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] != ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] != ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] != ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] != ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] != ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1] != ' ' {\n            continue\n        }\n        if i + 1 < len(s) && s[i + 1] != ' ' {\n            continue\n        }\n        if i - 1 >= 0 && s[i - 1]\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpulxdu8lx_test.go:83:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i - 1 >= 0 && s[i-1] == ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s) && s[i+1] == ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s) && s[i+1] != ' ' {\n            continue\n        }\n        \n        if i - 1 >= 0 && s[i-1] != ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s) && s[i+1] != ' ' {\n            continue\n        }\n        \n        if i - 1 >= 0 && s[i-1] != ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s) && s[i+1] != ' ' {\n            continue\n        }\n        \n        if i - 1 >= 0 && s[i-1] != ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s) && s[i+1] != ' ' {\n            continue\n        }\n        \n        if i - 1 >= 0 && s[i-1] != ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s) && s[i+1] != ' ' {\n            continue\n        }\n        \n        if i - 1 >= 0 && s[i-1] != ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s) && s[i+1] != ' ' {\n            continue\n        }\n        \n        if i - 1 >= 0 && s[i-1] != ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s) && s[i+1] != ' ' {\n            continue\n        }\n        \n        if i - 1 >= 0 && s[i-1] != ' ' {\n            continue\n        }\n        \n        if i + 1 < len(s\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz1dw6idg_test.go:97:25: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    var words []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i+n <= len(s) {\n            if s[i:i+n] == \" \" {\n                words = append(words, s[i:i+n])\n            }\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmps5rtsuip_test.go:62: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmps5rtsuip_test.go:62: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmps5rtsuip_test.go:62: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmps5rtsuip_test.go:62: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmps5rtsuip_test.go:62: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            result = append(result, s[\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_4tq7oxx_test.go:97:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i+n < len(s) {\n            if s[i+n] == ' ' {\n                words = append(words, s[i:i+n])\n                i += n\n                continue\n            }\n        }\n        \n        words = append(words, s[i:])\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpkm8udt92_test.go:66: expected '[little]', got '[Mary had a little lamb ad a little lamb ittle lamb ttle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpkm8udt92_test.go:66: expected '[Mary lamb]', got '[Mary had a little lamb ary had a little lamb little lamb ittle lamb ttle lamb tle lamb amb mb b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpkm8udt92_test.go:66: expected '[]', got '[simple white space imple white space mple white space ple white space le white space hite space ite space te space pace ace ce e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpkm8udt92_test.go:66: expected '[world]', got '[Hello world ello world orld rld ld d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkm8udt92_test.go:66: expected '[Uncle]', got '[Uncle sam ncle sam cle sam am m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpkm8udt92_test.go:66: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        words = append(words, s[i:i+1])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpgpsvhh8m_test.go:61: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := make([]string, 0)\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i:i+1])\n            n--\n            continue\n        }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxfd896jh_test.go:105:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Write your code here\n    var res []string\n    if len(s) == 0 {\n        return res\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            res = append(res, s[i:])\n            break\n        }\n        \n        if n > 0 {\n            n--\n        }\n        \n        if s[i] == ' ' {\n            for j := i + 1; j < len(s); j++ {\n                if s[j] == ' ' {\n                    continue\n                }\n                \n                if n == 0 {\n                    res = append(res, s[i:j])\n                    break\n                }\n                \n                if n > 0 {\n                    n--\n                }\n            }\n        }\n    }\n    \n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp8cu4ugfc_test.go:85: expected '[little]', got '[had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp8cu4ugfc_test.go:85: expected '[Mary lamb]', got '[y had a little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp8cu4ugfc_test.go:85: expected '[]', got '[mple white space]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp8cu4ugfc_test.go:85: expected '[world]', got '[o world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp8cu4ugfc_test.go:85: expected '[Uncle]', got '[le sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp8cu4ugfc_test.go:85: expected '[b c d f]', got '[b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i > 0 && s[i-1] == ' ' {\n            continue\n        }\n        \n        words = append(words, s[i:i+1])\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpj5n2d1qj_test.go:66: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpj5n2d1qj_test.go:66: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpj5n2d1qj_test.go:66: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpj5n2d1qj_test.go:66: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpj5n2d1qj_test.go:66: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpj5n2d1qj_test.go:66: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // Your code here\n    words := []string{}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if s[i] == ' ' {\n            words = append(words, \"\")\n        } else {\n            words = append(words, string(s[i]))\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpgh9p9qnx_test.go:62: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpgh9p9qnx_test.go:62: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpgh9p9qnx_test.go:62: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpgh9p9qnx_test.go:62: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpgh9p9qnx_test.go:62: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpgh9p9qnx_test.go:62: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    // Create a map of all words in the string s\n    words := make(map[string]bool)\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        word := s[i:]\n        words[word] = true\n    }\n    \n    // Create a list of words that contain exactly n consonants\n    var result []string\n    for word, _ := range words {\n        if len(word) == n {\n            result = append(result, word)\n        }\n    }\n    \n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmplkmxgr6g_test.go:66: expected '[little]', got '[lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmplkmxgr6g_test.go:66: expected '[Mary lamb]', got '[amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmplkmxgr6g_test.go:66: expected '[]', got '[ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmplkmxgr6g_test.go:66: expected '[world]', got '[orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmplkmxgr6g_test.go:66: expected '[Uncle]', got '[sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmplkmxgr6g_test.go:66: expected '[b c d f]', got '[f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        if s[i] == ' ' {\n            n--\n            continue\n        }\n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp_mvuacxt_test.go:76: expected '[little]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp_mvuacxt_test.go:76: expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp_mvuacxt_test.go:76: expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp_mvuacxt_test.go:76: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp_mvuacxt_test.go:76: expected '[b c d f]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(result) == n {\n                break\n            }\n            continue\n        }\n        if len(result) == n {\n            break\n        }\n        result = append(result, s[i:i+1])\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmp9icv3e75_test.go:60: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(words) == n {\n                return words\n            }\n            words = append(words, \"\")\n        } else {\n            words = append(words, s[i:i+1])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Mary lamb]', got '[M a r y  h a d  a  l i t t l e  l a m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[]', got '[s i m p l e  w h i t e  s p a c e]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[world]', got '[H e l l o  w o r l d]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[Uncle]', got '[U n c l e  s a m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpn5g1q41a_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    var words []string\n    words = strings.Split(s, \" \")\n    for _, word := range words {\n        if len(word) == n {\n            result = append(result, word)\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptdfuk0ji_test.go:27:13: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if i - n >= 0 {\n            words = append(words, s[i-n:i+1])\n        }\n        \n        if i + n < len(s) {\n            words = append(words, s[i:i+n])\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpfjie1ebx_test.go:64: expected '[little]', got '[Mary ary  ry h y ha ary h had  ry ha ad a y had d a  had a a li d a l litt  a li ittl a lit ttle  litt tle  littl le l ittle e la tle l le la e lam  lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpfjie1ebx_test.go:64: expected '[Mary lamb]', got '[Mar ary ry  Mary y h ry h had y ha ad   had d a ad a a l  a l lit a li itt  lit ttl litt tle ittl le  ttle e l le l lam e la  lam lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpfjie1ebx_test.go:64: expected '[]', got '[si im sim mp imp pl mpl le ple e  e w wh  wh hi whi it hit te ite e  e s sp  sp pa spa ac pac ace]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpfjie1ebx_test.go:64: expected '[world]', got '[Hell ello llo  lo w Hello o wo llo w worl lo wo o wor  worl world]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpfjie1ebx_test.go:64: expected '[Uncle]', got '[Unc ncl cle Uncl le  ncle e s le s e sa  sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpfjie1ebx_test.go:64: expected '[b c d f]', got '[a  b b  c c  d d  e e  f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i - n >= 0 {\n            words = append(words, s[i-n:i])\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[little]', got '[ary  ry h y ha had  d a   a l a li  lit litt ittl tle  le l e la  lam]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[Mary lamb]', got '[Mar ry  y h  ha ad   a  a l  li lit itt ttl le  e l  la lam]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[]', got '[si im mp pl e   w wh hi it e   s sp pa ac]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[world]', got '[Hell llo  lo w o wo  wor worl]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[Uncle]', got '[Unc ncl le  e s  sa]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpkhsq1ffa_test.go:56: expected '[b c d f]', got '[         ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n > len(s) {\n            break\n        }\n        result = append(result, s[i:i+n])\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpwtmb0n5l_test.go:57: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpwtmb0n5l_test.go:57: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpwtmb0n5l_test.go:57: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpwtmb0n5l_test.go:57: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpwtmb0n5l_test.go:57: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpwtmb0n5l_test.go:57: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    // write your code here\n    words := []string{}\n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        words = append(words, s[i:i+1])\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmph59bpmqn_test.go:65: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph59bpmqn_test.go:65: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmph59bpmqn_test.go:65: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmph59bpmqn_test.go:65: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph59bpmqn_test.go:65: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmph59bpmqn_test.go:65: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if len(words) == n {\n            break\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        if s[i] == ' ' {\n            continue\n        }\n        words = append(words, s[i:i+1])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpe98s1srb_test.go:63: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var words []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if i + n <= len(s) {\n            if s[i:i+n] == \" \" {\n                words = append(words, \" \")\n            } else {\n                words = append(words, s[i:i+n])\n            }\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpk1w4d5lu_test.go:60: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpk1w4d5lu_test.go:60: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpk1w4d5lu_test.go:60: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpk1w4d5lu_test.go:60: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpk1w4d5lu_test.go:60: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpk1w4d5lu_test.go:60: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(words) == n {\n            return words\n        }\n        \n        if i == len(s) - 1 {\n            words = append(words, s[i:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            return words\n        }\n        \n        if s[i] == ' ' {\n            words = append(words, s[i+1:])\n            \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv8xv6qwg_test.go:100:6: expected '(', found TestSelect_Words\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        if n == 0 {\n            break\n        }\n        n--\n        result = append(result, s[i:i+1])\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpkpq877x7_test.go:58: expected '[little]', got '[M a r y]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpkpq877x7_test.go:58: expected '[Mary lamb]', got '[M a r]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpkpq877x7_test.go:58: expected '[]', got '[s i]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpkpq877x7_test.go:58: expected '[world]', got '[H e l l]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpkpq877x7_test.go:58: expected '[Uncle]', got '[U n c]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpkpq877x7_test.go:58: expected '[b c d f]', got '[a]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    var result []string\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if n == 0 {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i] == ' ' {\n            result = append(result, s[i:i+1])\n            n--\n            continue\n        }\n        \n        if s[i\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps3k6rx2d_test.go:104:15: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n// >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string {\n    \n    words := []string{}\n    \n    if len(s) == 0 {\n        return words\n    }\n    \n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            continue\n        }\n        \n        if len(s) - i >= n {\n            words = append(words, s[i:i+n])\n        }\n        \n        if len(s) - i < n {\n            break\n        }\n    }\n    \n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpjjh1q466_test.go:68: expected '[little]', got '[Mary ary  ry h y ha had  ad a d a  a li litt ittl ttle tle  le l e la lamb]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjjh1q466_test.go:68: expected '[Mary lamb]', got '[Mar ary ry  y h had ad  d a a l lit itt ttl tle le  e l lam amb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpjjh1q466_test.go:68: expected '[]', got '[si im mp pl le e  wh hi it te e  sp pa ac ce]'\n    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpjjh1q466_test.go:68: expected '[world]', got '[Hell ello llo  lo w o wo worl orld]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjjh1q466_test.go:68: expected '[Uncle]', got '[Unc ncl cle le  e s sam]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpjjh1q466_test.go:68: expected '[b c d f]', got '[a b c d e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}