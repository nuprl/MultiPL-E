{
  "name": "HumanEval_9_rolling_max",
  "language": "go_test.go",
  "prompt": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n",
  "tests": "func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result)-1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\n// Given a list of integers, return a list of the maximum elements found in the sequence.\n// >>> max_elements([1, 2, 3, 2, 3, 4, 2])\n// [3, 4, 2]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpkom74w0f_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpkom74w0f_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        result = append(result, max(result, number))\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdghjha91_test.go:15:33: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > result[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp7mkjx7bb_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp7mkjx7bb_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp7mkjx7bb_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpznyahl0f_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpznyahl0f_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpznyahl0f_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        if numbers[i] > numbers[i + 1] {\n            result = append(result, numbers[i])\n        } else {\n            result = append(result, numbers[i + 1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpjrxzprn__test.go:15\ncommand-line-arguments_test.TestRolling_Max(0xc000001380)\n\t/tmp/tmpjrxzprn__test.go:32 +0x97f\ntesting.tRunner(0xc000001380, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, 0)\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result) - 1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i + 1] = result[i]\n                    } else {\n                        result[i + 1] = number\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1] with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(0xc00011ae60, 0x4, 0x4, 0xc000156000, 0x4, 0x4)\n\t/tmp/tmpidut905v_test.go:25 +0x1b5\ncommand-line-arguments_test.TestRolling_Max(0xc000102600)\n\t/tmp/tmpidut905v_test.go:44 +0x177\ntesting.tRunner(0xc000102600, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmphm6itbxh_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmphm6itbxh_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp2jfv6h4v_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp2jfv6h4v_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    max_so_far := numbers[0]\n    result := []int{max_so_far}\n    \n    for _, number := range numbers {\n        if number > max_so_far {\n            max_so_far = number\n        }\n        result = append(result, max_so_far)\n    }\n    \n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpo2_6lgdr_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpo2_6lgdr_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpo2_6lgdr_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        if numbers[i] > numbers[i+1] {\n            result = append(result, numbers[i])\n        } else {\n            result = append(result, numbers[i+1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp7tnw75_w_test.go:15\ncommand-line-arguments_test.TestRolling_Max(0xc000102600)\n\t/tmp/tmp7tnw75_w_test.go:32 +0x97f\ntesting.tRunner(0xc000102600, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpyuygab2l_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpyuygab2l_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpsng3b8ft_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpsng3b8ft_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    // Create a list of maximum elements\n    max_elements := make([]int, len(numbers))\n    // Initialize the maximum elements\n    for i := 0; i < len(numbers); i++ {\n        max_elements[i] = numbers[i]\n    }\n    // Iterate over the list of numbers\n    for i := 0; i < len(numbers); i++ {\n        // If the current element is greater than the maximum element, replace it\n        if numbers[i] > max_elements[i] {\n            max_elements[i] = numbers[i]\n        }\n    }\n    // Return the list of maximum elements\n    return max_elements\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmplnml5z5l_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmplnml5z5l_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        if i > 0 && numbers[i] > numbers[i - 1] {\n            result = append(result, numbers[i - 1])\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpm0uiwnil_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpm0uiwnil_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpm0uiwnil_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result)-1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i+1] = result[i]\n                    } else {\n                        result[i+1] = number\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1] with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc0001d0000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000182600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc0001d0000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(0xc000192e60, 0x4, 0x4, 0xc0001ce000, 0x4, 0x4)\n\t/tmp/tmppyfh3zex_test.go:25 +0x19e\ncommand-line-arguments_test.TestRolling_Max(0xc000182600)\n\t/tmp/tmppyfh3zex_test.go:44 +0x177\ntesting.tRunner(0xc000182600, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.012s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, value := range numbers {\n        if len(result) == 0 {\n            result = append(result, value)\n        } else {\n            if value > result[len(result) - 1] {\n                result = append(result, value)\n            } else {\n                result = append(result, result[len(result) - 1])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpeuqozs8b_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpeuqozs8b_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    // Create a list to store the maximum elements\n    max_elements := make([]int, len(numbers))\n    // Initialize the maximum elements to the first element\n    max_elements[0] = numbers[0]\n    // Iterate through the list and find the maximum elements\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max_elements[i-1] {\n            max_elements[i] = numbers[i]\n        } else {\n            max_elements[i] = max_elements[i-1]\n        }\n    }\n    // Return the maximum elements\n    return max_elements\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x535060, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x535060, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpdq6nmdoo_test.go:16\ncommand-line-arguments_test.TestRolling_Max(0xc000102600)\n\t/tmp/tmpdq6nmdoo_test.go:36 +0x3f\ntesting.tRunner(0xc000102600, 0x54df00)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, num := range numbers {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else {\n            if num > result[len(result)-1] {\n                result = append(result, num)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if num > result[i] {\n                        result[i] = num\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp8_n_1b9m_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp8_n_1b9m_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    max_elements := make([]int, len(numbers))\n    \n    for i := 0; i < len(numbers); i++ {\n        max_elements[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > max_elements[i] {\n                max_elements[i] = numbers[j]\n            }\n        }\n    }\n    \n    return max_elements\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmptkag_vac_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmptkag_vac_test.go:47: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmptkag_vac_test.go:47: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, numbers[i])\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                numbers[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpcsnbjbd5_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpcsnbjbd5_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        if i > 0 && numbers[i] > numbers[i-1] {\n            result = append(result, numbers[i-1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5l9qdqnb_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5l9qdqnb_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5l9qdqnb_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.024s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        if numbers[i] > numbers[i + 1] {\n            result = append(result, numbers[i])\n        } else {\n            result = append(result, numbers[i + 1])\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc00014e000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc00014e000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpi417x_c6_test.go:15\ncommand-line-arguments_test.TestRolling_Max(0xc000102600)\n\t/tmp/tmpi417x_c6_test.go:36 +0x97f\ntesting.tRunner(0xc000102600, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp1kl50dig_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp1kl50dig_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    max_index := 0\n    max_value := numbers[0]\n\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n\n    result := []int{max_value}\n    for i := max_index; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n        result = append(result, max_value)\n    }\n\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpmn_jmqsy_test.go:59: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmn_jmqsy_test.go:59: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmn_jmqsy_test.go:59: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    var max int\n    var i int\n    for i = 0; i < len(numbers); i++ {\n        if max < numbers[i] {\n            max = numbers[i]\n        }\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n\n    return result\n}\n\n// Given a list of integers, return a list of the maximum elements found until given moment in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpbonpvfkz_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpbonpvfkz_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.013s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > result[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpw6ycreks_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpw6ycreks_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        result = append(result, number)\n        for len(result) > 1 && result[len(result) - 1] < result[len(result) - 2] {\n            result = result[0 : len(result) - 1]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpui6ezvr2_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpui6ezvr2_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpeuqozs8b_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpeuqozs8b_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, numbers[i])\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result = append(result, numbers[j])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpy6_g0gjr_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpy6_g0gjr_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpy6_g0gjr_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.014s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    max_numbers := []int{}\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            max_numbers = append(max_numbers, numbers[i])\n        } else {\n            if numbers[i] > max_numbers[len(max_numbers)-1] {\n                max_numbers = append(max_numbers, numbers[i])\n            } else {\n                max_numbers = append(max_numbers, max_numbers[len(max_numbers)-1])\n            }\n        }\n    }\n\n    return max_numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    max_so_far := numbers[0]\n    result := []int{max_so_far}\n\n    for _, number := range numbers {\n        if number > max_so_far {\n            max_so_far = number\n        }\n        result = append(result, max_so_far)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpicc2rf5t_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpicc2rf5t_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpicc2rf5t_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        if i > 0 && numbers[i] > numbers[i - 1] {\n            result = append(result, numbers[i - 1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpxpvupxk3_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpxpvupxk3_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpxpvupxk3_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpyuygab2l_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpyuygab2l_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result) - 1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i] = number\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpp7h1bvnf_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpp7h1bvnf_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\n// Test rolling_max function\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpe81r5k7a_test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpe81r5k7a_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpe81r5k7a_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    var max int\n    for _, number := range numbers {\n        if max < number {\n            max = number\n        }\n    }\n    result = append(result, max)\n    for _, number := range numbers {\n        if max < number {\n            max = number\n        } else {\n            result = append(result, max)\n            max = number\n        }\n    }\n    result = append(result, max)\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__0 (0.00s)\n        tmpnb6d4y8g_test.go:53: expected '[]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpnb6d4y8g_test.go:53: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpnb6d4y8g_test.go:53: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpnb6d4y8g_test.go:53: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    // Create a list of maximum elements\n    max_elements := make([]int, len(numbers))\n    // Initialize the maximum elements\n    for i := 0; i < len(numbers); i++ {\n        max_elements[i] = numbers[i]\n    }\n    // Iterate over the list of numbers\n    for i := 0; i < len(numbers); i++ {\n        // If the current element is greater than the maximum element, update the maximum element\n        if numbers[i] > max_elements[i] {\n            max_elements[i] = numbers[i]\n        }\n    }\n    // Return the maximum elements\n    return max_elements\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpg9f3ls9b_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpg9f3ls9b_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result)-1] {\n            result = append(result, numbers[i])\n        } else {\n            for j := len(result) - 1; j >= 0; j-- {\n                if numbers[i] > result[j] {\n                    result[j] = numbers[i]\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp1geoqbgl_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp1geoqbgl_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpt082rlqi_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpt082rlqi_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmphm6itbxh_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmphm6itbxh_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result)-1] {\n                result = append(result, number)\n            } else {\n                result = append(result, result[len(result)-1])\n            }\n        }\n    }\n    return result\n}\n\n// Test rolling_max function\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > result[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        if i > 0 && numbers[i] > numbers[i-1] {\n            result = append(result, numbers[i-1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5l9qdqnb_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5l9qdqnb_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5l9qdqnb_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.024s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmphm6itbxh_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmphm6itbxh_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result)-1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i] = number\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp2izv_e7b_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp2izv_e7b_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        result = append(result, max(result, number))\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgm52md18_test.go:15:33: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, numbers[i])\n        for j := 0; j < len(result); j++ {\n            if result[j] < numbers[i] {\n                result[j] = numbers[i]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp9vwn42zd_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp9vwn42zd_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp9vwn42zd_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        for j := i - 1; j >= 0; j-- {\n            if numbers[j] > numbers[j+1] {\n                numbers[j] = numbers[j+1]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp_2sdi1qq_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp_2sdi1qq_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp_2sdi1qq_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result) - 1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i] = number\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpxxn9j4cv_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpxxn9j4cv_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, max(numbers[i:i+len(numbers)]))\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_zbbbtxz_test.go:15:33: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, 0)\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result) - 1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i + 1] = result[i]\n                    } else {\n                        break\n                    }\n                }\n                result[0] = number\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpnlbjj4b0_test.go:51: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpnlbjj4b0_test.go:51: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, n := range numbers {\n        if len(result) == 0 {\n            result = append(result, n)\n        } else {\n            if n > result[len(result) - 1] {\n                result = append(result, n)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if n > result[i] {\n                        result[i + 1] = result[i]\n                    } else {\n                        result[i + 1] = n\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(0xc00007e660, 0x4, 0x4, 0xc00001a2a0, 0x4, 0x4)\n\t/tmp/tmp9lqk_466_test.go:25 +0x19e\ncommand-line-arguments_test.TestRolling_Max(0xc000001380)\n\t/tmp/tmp9lqk_466_test.go:44 +0x177\ntesting.tRunner(0xc000001380, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        result = append(result, max(result, number))\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgm52md18_test.go:15:33: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    // Create a list of maximum elements\n    max_elements := make([]int, len(numbers))\n    // Initialize the maximum elements\n    for i := 0; i < len(numbers); i++ {\n        max_elements[i] = numbers[i]\n    }\n    // Iterate over the list of numbers\n    for i := 0; i < len(numbers); i++ {\n        // Check if the current element is greater than the maximum element\n        if numbers[i] > max_elements[i] {\n            // If so, update the maximum element\n            max_elements[i] = numbers[i]\n        }\n    }\n    // Return the maximum elements\n    return max_elements\n}\n\n// Test function\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp7toovjbs_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp7toovjbs_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result)-1] {\n            result = append(result, numbers[i])\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp8s1pfxq2_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp8s1pfxq2_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmph9v6rzpf_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmph9v6rzpf_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, v := range numbers {\n        if len(result) == 0 || v > result[len(result)-1] {\n            result = append(result, v)\n        } else if v > result[len(result)-1] {\n            result[len(result)-1] = v\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmphaxdloyi_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmphaxdloyi_test.go:40: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := make([]int, len(numbers))\n    \n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    \n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpnguzajy7_test.go:51: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpnguzajy7_test.go:51: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpnguzajy7_test.go:51: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        if numbers[i] > numbers[i + 1] {\n            result = append(result, numbers[i])\n        } else {\n            result = append(result, numbers[i + 1])\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc00014e000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc00014e000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpi417x_c6_test.go:15\ncommand-line-arguments_test.TestRolling_Max(0xc000102600)\n\t/tmp/tmpi417x_c6_test.go:36 +0x97f\ntesting.tRunner(0xc000102600, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqgp6k34d_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqgp6k34d_test.go:52: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpeuqozs8b_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpeuqozs8b_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > result[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result[len(result) - 1] = numbers[i]\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp0yfjmodj_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp0yfjmodj_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    var max int\n    for _, number := range numbers {\n        if max < number {\n            max = number\n        }\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5lt3equm_test.go:47: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5lt3equm_test.go:47: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmphm6itbxh_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmphm6itbxh_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        result = append(result, number)\n        for i := len(result) - 1; i >= 0; i-- {\n            if number > result[i] {\n                result[i] = number\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpfda_fohk_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpfda_fohk_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    max_so_far := numbers[0]\n    result := []int{max_so_far}\n    \n    for _, number := range numbers {\n        if number > max_so_far {\n            max_so_far = number\n        }\n        result = append(result, max_so_far)\n    }\n    \n    return result\n}\n\n// Test rolling_max function\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpu705hisu_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpu705hisu_test.go:47: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpu705hisu_test.go:47: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result)-1] {\n                result = append(result, number)\n            } else {\n                result[len(result)-1] = number\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpypzu3lnu_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpypzu3lnu_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, n := range numbers {\n        if len(result) == 0 {\n            result = append(result, n)\n        } else {\n            if n > result[len(result)-1] {\n                result = append(result, n)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if n > result[i] {\n                        result[i] = n\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpybk4j6lx_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpybk4j6lx_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, max(numbers[i:]))\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7lpueu7y_test.go:15:33: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, numbers[i])\n        if i < len(numbers) - 1 {\n            if numbers[i] < numbers[i + 1] {\n                result = append(result, numbers[i + 1])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpqh3f50w0_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqh3f50w0_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqh3f50w0_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, numbers[i])\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result = append(result, numbers[j])\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp0_g5ijny_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp0_g5ijny_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp0_g5ijny_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > result[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    // Create a slice of the same size as the input\n    output := make([]int, len(numbers))\n\n    // Initialize the output with the first element\n    output[0] = numbers[0]\n\n    // Iterate through the input slice\n    for i := 1; i < len(numbers); i++ {\n        // If the current element is greater than the previous one, update the output\n        if numbers[i] > output[i-1] {\n            output[i] = numbers[i]\n        }\n    }\n\n    // Return the output slice\n    return output\n}\n\n// Test function\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x535060, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x535060, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpdo_dy3y3_test.go:17\ncommand-line-arguments_test.TestRolling_Max(0xc000001380)\n\t/tmp/tmpdo_dy3y3_test.go:39 +0x3f\ntesting.tRunner(0xc000001380, 0x54df00)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpeuqozs8b_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpeuqozs8b_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpu09cw3_0_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpu09cw3_0_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, 0)\n    for _, num := range numbers {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else {\n            if num > result[len(result)-1] {\n                result = append(result, num)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if num > result[i] {\n                        result[i] = num\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqaxgi5bh_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqaxgi5bh_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    // Initialize the result\n    result := []int{}\n    // Initialize the max\n    max := numbers[0]\n    // Iterate over the numbers\n    for _, number := range numbers {\n        // If the current number is greater than the max, update the max\n        if number > max {\n            max = number\n        }\n        // Add the current number to the result\n        result = append(result, max)\n    }\n    return result\n}\n\n// Test 1: empty list\n// >>> rolling_max([])\n// []\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc0001ce000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000182600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc0001ce000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(0xc0000785f8, 0x0, 0x0, 0x5825a3, 0xf, 0x0)\n\t/tmp/tmpsi9vbpos_test.go:16 +0xf6\ncommand-line-arguments_test.TestRolling_Max(0xc000182600)\n\t/tmp/tmpsi9vbpos_test.go:39 +0x53\ntesting.tRunner(0xc000182600, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmph9v6rzpf_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmph9v6rzpf_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result[len(result) - 1] = numbers[i]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpyqf68hn0_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpyqf68hn0_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result)-1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpz8rw22tb_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpz8rw22tb_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result)-1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i] = number\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpyvs4m5el_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpyvs4m5el_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        if numbers[i] > numbers[i+1] {\n            result = append(result, numbers[i])\n        } else {\n            result = append(result, numbers[i+1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp7tnw75_w_test.go:15\ncommand-line-arguments_test.TestRolling_Max(0xc000102600)\n\t/tmp/tmp7tnw75_w_test.go:32 +0x97f\ntesting.tRunner(0xc000102600, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqw0a_28g_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    var max int\n    for i := 0; i < len(numbers); i++ {\n        if max < numbers[i] {\n            max = numbers[i]\n        }\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    var max int\n    for _, number := range numbers {\n        if number > max {\n            max = number\n        }\n    }\n    result = append(result, max)\n    for _, number := range numbers {\n        if number == max {\n            continue\n        }\n        if number > max {\n            max = number\n        }\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__0 (0.00s)\n        tmpx34x5r21_test.go:49: expected '[]', got '[%!s(int=0)]'\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpx34x5r21_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpx34x5r21_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result)-1] {\n            result = append(result, numbers[i])\n        }\n    }\n    \n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp3yteh8gk_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp3yteh8gk_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    var max int\n    for _, number := range numbers {\n        if max < number {\n            max = number\n        }\n        result = append(result, max)\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        if numbers[i] > numbers[i + 1] {\n            result = append(result, numbers[i])\n        } else {\n            result = append(result, numbers[i + 1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpjrxzprn__test.go:15\ncommand-line-arguments_test.TestRolling_Max(0xc000001380)\n\t/tmp/tmpjrxzprn__test.go:32 +0x97f\ntesting.tRunner(0xc000001380, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        result = append(result, number)\n        for len(result) > 1 && result[len(result)-1] < result[len(result)-2] {\n            result = result[0:len(result)-1]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpm3g1hitg_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpm3g1hitg_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpqgp6k34d_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpqgp6k34d_test.go:52: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, n := range numbers {\n        if len(result) == 0 {\n            result = append(result, n)\n        } else {\n            if n > result[len(result)-1] {\n                result = append(result, n)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if n > result[i] {\n                        result[i] = n\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpybk4j6lx_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpybk4j6lx_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result)-1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i] = number\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp8d268hcy_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp8d268hcy_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp_glkifna_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp_glkifna_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        if numbers[i] > numbers[i + 1] {\n            result = append(result, numbers[i])\n        } else {\n            result = append(result, numbers[i + 1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpjrxzprn__test.go:15\ncommand-line-arguments_test.TestRolling_Max(0xc000001380)\n\t/tmp/tmpjrxzprn__test.go:32 +0x97f\ntesting.tRunner(0xc000001380, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        result = append(result, number)\n        for i := len(result) - 1; i >= 0; i-- {\n            if number > result[i] {\n                result[i] = number\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpfda_fohk_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpfda_fohk_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    // Create a list of maximum elements\n    max_elements := make([]int, len(numbers))\n    // Initialize the maximum elements with the first element\n    max_elements[0] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[1] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[2] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[3] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[4] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[5] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[6] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[7] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[8] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[9] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[10] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[11] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[12] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[13] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[14] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[15] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[16] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[17] = numbers[0]\n    // Initialize the maximum elements with the first element\n    max_elements[\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppr5w3aym_test.go:53:6: expected '(', found TestRolling_Max\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result)-1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmph9v6rzpf_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmph9v6rzpf_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > result[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result[len(result) - 1] = numbers[i]\n            }\n        }\n    }\n    return result\n}\n\n// Test 1: empty list\n// >>> rolling_max([])\n// []\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp0xxdqxc0_test.go:47: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp0xxdqxc0_test.go:47: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp6z3ehnfg_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 || number > result[len(result)-1] {\n            result = append(result, number)\n        } else if number > result[len(result)-1] {\n            result[len(result)-1] = number\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpj6blqz8e_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpj6blqz8e_test.go:40: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        if i > 0 && numbers[i] > numbers[i - 1] {\n            result = append(result, numbers[i - 1])\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpyj10jy2b_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpyj10jy2b_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpyj10jy2b_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        for j := i - 1; j >= 0; j-- {\n            if numbers[j] > numbers[i] {\n                numbers[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp2mrg_7_i_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp2mrg_7_i_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp2mrg_7_i_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result)-1] {\n            result = append(result, numbers[i])\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374934,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp8s1pfxq2_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp8s1pfxq2_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    max_numbers := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max_numbers[len(max_numbers) - 1] {\n            max_numbers = append(max_numbers, numbers[i])\n        } else {\n            max_numbers = append(max_numbers, numbers[i])\n        }\n    }\n    \n    return max_numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpt_k5a3li_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpt_k5a3li_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > result[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, max(numbers[i:i+len(numbers)]))\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_zbbbtxz_test.go:15:33: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    max_list := []int{}\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            max_list = append(max_list, numbers[i])\n        } else {\n            if numbers[i] > max_list[len(max_list)-1] {\n                max_list = append(max_list, numbers[i])\n            } else {\n                max_list = append(max_list, max_list[len(max_list)-1])\n            }\n        }\n    }\n\n    return max_list\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, 0)\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result) - 1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i] = number\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp16tyzceu_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp16tyzceu_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result) - 1] {\n                result = append(result, number)\n            } else {\n                result = append(result, result[len(result) - 1])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        if numbers[i] > numbers[i - 1] {\n            continue\n        }\n        for j := i - 1; j >= 0; j-- {\n            if numbers[j] > numbers[i] {\n                numbers[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpv5gphwm6_test.go:16\ncommand-line-arguments_test.TestRolling_Max(0xc000001380)\n\t/tmp/tmpv5gphwm6_test.go:36 +0x8bf\ntesting.tRunner(0xc000001380, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        if i > 0 && numbers[i] > numbers[i - 1] {\n            result = append(result, numbers[i - 1])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpxpvupxk3_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpxpvupxk3_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpxpvupxk3_test.go:39: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    var max int\n    for _, number := range numbers {\n        if max < number {\n            max = number\n        }\n    }\n    result = append(result, max)\n    for _, number := range numbers {\n        if max < number && number > result[len(result) - 1] {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\n// Test rolling_max function\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__0 (0.00s)\n        tmpce1vqehe_test.go:46: expected '[]', got '[%!s(int=0)]'\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpce1vqehe_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpce1vqehe_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpce1vqehe_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    \n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n    \n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5z5jisnt_test.go:47: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5z5jisnt_test.go:47: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp58dopxnj_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                result[len(result) - 1] = numbers[i]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374935,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpyqf68hn0_test.go:44: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpyqf68hn0_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=2) %!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        if numbers[i] > numbers[i - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpe3_rs5c__test.go:15\ncommand-line-arguments_test.TestRolling_Max(0xc000001380)\n\t/tmp/tmpe3_rs5c__test.go:30 +0x81f\ntesting.tRunner(0xc000001380, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > numbers[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpznyahl0f_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpznyahl0f_test.go:45: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpznyahl0f_test.go:45: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=3) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        result = append(result, numbers[i])\n        for j := 0; j < len(numbers) - i - 1; j++ {\n            if numbers[j] > numbers[j + 1] {\n                numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpm609llpw_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpm609llpw_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := []int{}\n    for _, num := range numbers {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else {\n            if num > result[len(result)-1] {\n                result = append(result, num)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if num > result[i] {\n                        result[i] = num\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp8_n_1b9m_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp8_n_1b9m_test.go:50: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp_glkifna_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp_glkifna_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    // Create a new slice to store the maximum elements\n    result := make([]int, len(numbers))\n    // Initialize the maximum elements to the first element of the given list\n    result[0] = numbers[0]\n    // Initialize the maximum elements to the first element of the given list\n    max_elements := []int{numbers[0]}\n    // Iterate over the given list\n    for i := 1; i < len(numbers); i++ {\n        // If the current element is greater than the maximum element, update the maximum element\n        if numbers[i] > max_elements[len(max_elements) - 1] {\n            max_elements = append(max_elements, numbers[i])\n        }\n        // If the current element is less than the maximum element, update the maximum element\n        if numbers[i] < max_elements[len(max_elements) - 1] {\n            max_elements[len(max_elements) - 1] = numbers[i]\n        }\n        // Update the maximum element in the result\n        result[i] = max_elements[len(max_elements) - 1]\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536400, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.rolling_max(0xc00007e5f8, 0x0, 0x0, 0x5825a3, 0xf, 0x0)\n\t/tmp/tmpsr0zi92v_test.go:16 +0x1ad\ncommand-line-arguments_test.TestRolling_Max(0xc000001380)\n\t/tmp/tmpsr0zi92v_test.go:42 +0x53\ntesting.tRunner(0xc000001380, 0x54f2c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpmy7cl9p0_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    var max_value int\n    var max_index int\n    for i := 0; i < len(numbers); i++ {\n        if max_value < numbers[i] {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n    result = append(result, max_value)\n    for i := max_index; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n    result = append(result, max_value)\n    for i := max_index; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n    result = append(result, max_value)\n    for i := max_index; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n    result = append(result, max_value)\n    for i := max_index; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n    result = append(result, max_value)\n    for i := max_index; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n    result = append(result, max_value)\n    for i := max_index; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n            max_index = i\n        }\n    }\n    result = append(result, max_value)\n    for i := max_index; i < len(numbers); i++ {\n        if numbers[i] > max_value {\n            \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374936,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp290oaz7x_test.go:68:6: expected '(', found TestRolling_Max\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := len(numbers) - 1; i >= 0; i-- {\n        result = append(result, numbers[i])\n        if i > 0 && numbers[i] > numbers[i - 1] {\n            result = append(result, numbers[i - 1])\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374929,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmpm0uiwnil_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpm0uiwnil_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpm0uiwnil_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        result = append(result, max(result, number))\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsw_hkd6b_test.go:15:33: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 {\n            result = append(result, number)\n        } else {\n            if number > result[len(result)-1] {\n                result = append(result, number)\n            } else {\n                for i := len(result) - 1; i >= 0; i-- {\n                    if number > result[i] {\n                        result[i] = number\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374933,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp2izv_e7b_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp2izv_e7b_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for _, number := range numbers {\n        if len(result) == 0 || number > result[len(result)-1] {\n            result = append(result, number)\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp89jw0dor_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp89jw0dor_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, len(numbers))\n    for i := 0; i < len(numbers); i++ {\n        result[i] = numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n            if numbers[j] > result[i] {\n                result[i] = numbers[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374931,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5c9hyqei_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    result := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[len(result) - 1] {\n            result = append(result, numbers[i])\n        }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmpyuygab2l_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpyuygab2l_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374928,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp5q0yrxlv_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    var result []int\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            }\n        }\n    }\n    return result\n}\n\n// From a given list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\n// >>> rolling_min([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 2, 2, 2, 2, 2}\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp4q355iaf_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp4q355iaf_test.go:46: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int {\n    result := make([]int, 0)\n    for i := 0; i < len(numbers); i++ {\n        if i == 0 {\n            result = append(result, numbers[i])\n        } else {\n            if numbers[i] > result[len(result) - 1] {\n                result = append(result, numbers[i])\n            } else {\n                for j := 0; j < len(result); j++ {\n                    if numbers[i] > result[j] {\n                        result[j] = numbers[i]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374937,
      "stdout": "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp_3p48ovz_test.go:48: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp_3p48ovz_test.go:48: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}